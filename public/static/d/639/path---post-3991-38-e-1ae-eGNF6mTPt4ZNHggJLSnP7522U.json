{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cassandra - to BATCH or not to BATCH","alternative_id":3991,"content":"<p>This post is about Cassandra’s batch statements and which kind of batch statements are ok and which not. Often, when batch statements are discussed,\nit’s not clear if a particular statement refers to single- or multi-partition batches or to both - which is the most important question IMO (you should know\nwhy after you’ve read this post).</p><p>Instead, it is often differentiated between logged and unlogged batches (<a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#1\">[1]</a>, <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#2\">[2]</a>, <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#3\">[3]</a>). For one thing, logged/unlogged\nmay cause misunderstandings (more on this below). For another thing, unlogged batches (for multiple partitions) are deprecated since Cassandra 2.1.6\n(<a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#1\">[1]</a>, <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#4\">[4]</a>, <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#5\">[5]</a>). Therefore I think that the distinction between logged/unlogged is not that (no longer) useful.</p>\n<p>In the following I’m describing multi- and single-partition batches: what they provide, what they cost and when it’s ok to use them.</p>\n<p><strong>TL;DR</strong>:\nMulti partition batches should only be used to achieve atomicity for a few writes on different tables. Apart from this they should be avoided because they’re too expensive.\nSingle partition batches can be used to get atomicity + isolation, they’re not much more expensive than normal writes.</p>\n<h2>Definitions</h2>\n<p>At first, what are single partition and what are multi partition batches?</p>\n<p>A single partition BATCH only contains statements with a single <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#6\">partition key</a>.\nIf, for example, we have a table <code>user_tweets</code> with <code>PRIMARY KEY(user_id, tweet_id)</code>, then a batch with inserts with <code>user_id=1, tweet_id=1</code> and <code>user_id=1,tweet_id=2</code>\nwould target the same partition (on a single node).</p>\n<p>A multi partition batch is a BATCH that contains statements with different partition keys.\nIf, for example, we have a table <code>users</code> with <code>PRIMARY KEY(user_id)</code>, then a batch with inserts for <code>user_id=1</code> and <code>user_id=2</code> would target 2 partitions (which may live on different nodes).\nThe same holds true if a batch contains writes for different tables or even keyspaces: obviously such writes also target different partitions (maybe on different nodes).</p>\n<h2>Multi Partition Batches</h2>\n<p>Let’s see what the characteristics of multi partition batches are…</p>\n<h4>What does a multi partition batch provide?</h4>\n<p>Atomicity. Nothing more, notably no isolation.</p>\n<p>That means that from the writers point of view all or nothing gets written (atomicity).\nBut other clients can see the first write (insert/update/delete) before other writes from the batch\nare applied (no isolation).</p>\n<h4>What does a multi partition batch cost?</h4>\n<p>Let me just quote Christopher Batey, because he has summarized this very well in his post\n“Cassandra anti-pattern: Logged batches” <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#3\">[3]</a>:</p>\n<blockquote><p>Cassandra [is first] writing all the statements to a batch log. That batch log is replicated to two other nodes in case the coordinator fails.\nIf the coordinator fails then another replica for the batch log will take over. [..] The coordinator has to do a lot more work than any other node in the cluster.</p></blockquote>\n<p>Again, in bullets what has to be done:</p>\n<ul><li>serialize the batch statements</li>\n<li>write the serialized batch to the batch log system table</li>\n<li>replicate of this serialized batch to 2 nodes</li>\n<li>coordinate writes to nodes holding the different partitions</li>\n<li>on success remove the serialized batch from the batch log (also on the 2 replicas)</li>\n</ul><p>Here’s an image (from Christopher Batey’s blog post) that visualizes this for a batch with 8 insert statements for different partitions\n(equally distributed across nodes) in a 8 node cluster:</p>\n<p><a href=\"http://3.bp.blogspot.com/-dv9zIC84QD4/VNoNE0YXn8I/AAAAAAAAAX0/b3wtV48fuB0/s1600/Screenshot%2B2015-02-10%2B13.51.56.png\">\n  <img border=\"0\" src=\"http://3.bp.blogspot.com/-dv9zIC84QD4/VNoNE0YXn8I/AAAAAAAAAX0/b3wtV48fuB0/s1600/Screenshot%2B2015-02-10%2B13.51.56.png\" alt=\"image\" /></a></p>\n<p>And this does even not show arrows for responses and batch log cleanup (between the coordinator and batch log replicas).</p>\n<p>Hopefully it’s clear that such a multi partition batch is very expensive!</p>\n<h4>What are the limitations of multi partition batches?</h4>\n<p>Cassandra by default logs warnings for batches &gt; 5kb and fails/refuses batches &gt; 50kb, according to the configuration of <code>batch_size_{warn|fail}_threshold_in_kb</code>\n(<a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#7\">[7]</a>, <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#8\">[8]</a>).</p>\n<h4>When should you use logged / multi partition batches?</h4>\n<p>Usually - just don’t!</p>\n<p>When you’re writing to multiple partitions you should prefer multiple async writes, as described in\n“Cassandra: Batch loading without the Batch keyword” <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#9\">[9]</a>.</p>\n<p>Multi partition batches can be used when atomicity / consistency across tables is needed - in such cases very small “logged” batches are fine.</p>\n<p>But imagine a situation where you’re writing to two tables <code>users</code> (PK: id) and <code>users_by_username</code> (PK: username) in the context of a “batch” job\n(e.g. data import/replication, housekeeping, whatever). Then maybe tens of thousands of records might be updated in a very short time. In such a case I’d also\nprefer two async writes for each user (plus appropriate failure handling) because I’d consider batches too expensive in this case.</p>\n<h2>Single Partition Batches</h2>\n<p>Now let’s see what the characteristics of single partition batches are…</p>\n<h4>What does a single partition batch provide?</h4>\n<p>Atomicity + isolation.</p>\n<p>That means that all or nothing gets written. Other clients don’t see partial updates, but only all of them after they’ve been applied.</p>\n<p>Single partition batches (compared to multiple async statements) save network round-trips between the client and the server and therefore may improve throughput.</p>\n<h4>What does a single partition batch cost?</h4>\n<p>There’s no batch log written for single partition batches. The coordinator doesn’t have any extra work (as for multi partition writes) because everything goes into a single partition.\nSingle partition batches are optimized: they are applied with a single RowMutation <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#10\">[10]</a>.</p>\n<p>In a few words: single partition batches don’t put much more load on the server than normal writes.</p>\n<p>Sorry that I have no image for this, but a single arrow between client and server would be just too boring ;-)</p>\n<h4>What are the limitations of single partition batches?</h4>\n<p>Today (01/2016) Cassandra’s <code>batch_size_{warn|fail}_threshold_in_kb</code> config is also applied to single partition batches. Therefore also\nfor a batch targeting a single partition you’ll get warnings. This should be resolved soon <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#11\">[11]</a> so that single partition batches then are free to use.</p>\n<p>As it’s the case for other writes single partition batches should not be too large, because otherwise they would cause heap pressure\nand in consequence lead to long gc pauses <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#12\">[12]</a>.</p>\n<p>Because single partition batches are often used in combination with wide rows you should make sure that a row (partition) doesn’t become too large.\nThe recommendation of Datastax is that rows should not become much bigger than 100mb (you can check this with <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#13\">nodetool</a>).\nWhile this is not directly a limitation of single partition batches you should be aware of this fact to keep your C* cluster happy - partition your partitions.</p>\n<h4>When should you use single partition batches?</h4>\n<p>Single partition batches should be used when atomicity and isolation is required.</p>\n<p>Even if you only need atomicity (and no isolation) you should model your data so that you can use single partition\ninstead of multi partition batches.</p>\n<p>Single partition batches may also be used to increase the throughput compared to multiple un-batched statements.\nOf course you must benchmark your workload with your own setup/infrastructure to verify this assumption. If you don’t want to do this\nyou shouldn’t use single partition batches if you don’t need atomicity/isolation.</p>\n<h2>Logged vs. Unlogged</h2>\n<p>In this paragraph I want to explain why I find the differentiation in the first place between logged and unlogged not that useful.</p>\n<p>I think a major issue is that “logged” or “unlogged” may refer to different things:</p>\n<ul><li><strong>server side:</strong> “logged” means that C* writes a batch log (plus all the ceremony around this), “unlogged” means that no batch log is written.</li>\n<li><strong>client side:</strong> “logged” refers to <code>BEGIN BATCH</code> (respectively the driver’s logged batch), “unlogged” refers to <code>BEGIN UNLOGGED BATCH</code>.\nE.g. the java driver allows to create a <code>new BatchStatement(BatchStatement.Type.UNLOGGED)</code>, the default type being <code>Type.LOGGED</code>.</li>\n</ul><p>Even when the client is asking for a <em>logged</em> batch (with <code>BEGIN BATCH</code> or the driver’s equivalent) this does not necessarily mean that the\nserver (C*) will really write a batch log (and do all these costly things).\nLet’s have a look at the possible combinations of the client’s instruction for LOGGED/UNLOGGED and\nthe partition property (single/multi). For each combination we see if C* is writing a batch log,\nif the batch is applied atomically and if it’s applied in isolatation.</p>\n<table><thead><tr><td>↓ client: (un)logged // single/multi partition →</td>\n      <td>single partition</td>\n      <td>multi partition</td>\n    </tr></thead><tbody><tr><td>\n        logged <small>(BEGIN BATCH)</small>\n      </td>\n      <td>no batch log, atomic, isolated</td>\n      <td>batch log, atomic</td>\n    </tr><tr><td>\n        unlogged <small>(BEGIN UNLOGGED BATCH)</small>\n      </td>\n      <td>no batch log, atomic, isolated</td>\n      <td>no batch log</td>\n    </tr></tbody></table><p>Remember that unlogged batches for multiple partitions are deprecated since Cassandra 2.1.6 (<a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#1\">[1]</a>, <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#4\">[4]</a>, <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#5\">[5]</a>)?\nWith the table above it should be clear that one can just forget this “unlogged” thing. Hopefully at some\npoint it will be completely removed from CQL and drivers.</p>\n<h4>Rant: Improve the docs!</h4>\n<p>An issue today (01/2016) is that blog posts and documentation often only talk about multi partition batches (without making this explicit).</p>\n<p>E.g. the CQL commands reference for BATCH <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#14\">[14]</a> explains all the bad things around BATCHes and talks about logged and unlogged.\nUnfortunately it does not make clear how important it is if the batch targets a single or multiple partitions.\nToday it only says ”<em>However, transactional row updates within a partition key are isolated: clients cannot read a partial update.</em>”.\nNothing more about single partition batches.</p>\n<p>The same holds true for the “Using and misusing batches” section <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#1\">[1]</a> in the CQL docs. There you can read</p>\n<blockquote><p>Batches place a burden on the coordinator for both logged and unlogged batches.</p></blockquote>\n<p>True for multi partition batches, wrong for single partition batches.</p>\n<p>Another example is the javadoc for the java driver’s <code>BatchStatement.Type</code> <a href=\"https://inoio.de/blog/2016/01/13/cassandra-to-batch-or-not-to-batch/#15\">[15]</a>. There <code>LOGGED</code> is documented with</p>\n<blockquote><p>A logged batch: Cassandra will first write the batch to its distributed batch log to ensure the atomicity of the batch\n (atomicity meaning that if any statement in the batch succeeds, all will eventually succeed).</p></blockquote>\n<p>And for <code>UNLOGGED</code> you read</p>\n<blockquote><p>A batch that doesn’t use Cassandra’s distributed batch log. Such batch are not guaranteed to be atomic.</p></blockquote>\n<p>This should also mention the relevance of the partition keys involved in the batch statement.</p>\n<p><em>C* docs team, please mention that for single partition batches there’s no batch log and no ceremony involved and they’re atomic and isolated!</em></p>\n<h2>Summary</h2>\n<ul><li>When you hear/read s.th. about C* batch statements, ask (yourself) if it’s about single- or multi-partition batches.</li>\n<li>The common mantra that batch statements should be avoided most often refers to multi-partition batches.</li>\n<li>Multi partition batches should only be used to achieve atomicity for a few writes on different tables. Apart from this they should be avoided because they’re too expensive.</li>\n<li>Single partition batches can be used to achieve atomicity and isolation. They’re not much more expensive than normal writes.</li>\n</ul><h2>References</h2>\n<ol><li><a name=\"1\" href=\"http://docs.datastax.com/en/cql/3.3/cql/cql_using/useBatch.html\" id=\"1\">CQL for Cassandra 2.2+: Using and misusing batches</a> (<a href=\"http://docs.datastax.com/en/latest-cql/cql/cql_using/useBatch.html\">latest version</a>)</li>\n<li><a name=\"2\" href=\"http://christopher-batey.blogspot.de/2015/02/cassandra-anti-pattern-misuse-of.html\" id=\"2\">Christopher Batey’s Blog: Cassandra anti-pattern: Misuse of unlogged batches</a></li>\n<li><a name=\"3\" href=\"http://christopher-batey.blogspot.de/2015/03/cassandra-anti-pattern-cassandra-logged.html\" id=\"3\">Christopher Batey’s Blog: Cassandra anti-pattern: Logged batches</a></li>\n<li><a name=\"4\" href=\"https://issues.apache.org/jira/browse/CASSANDRA-9282\" id=\"4\">CASSANDRA-9282: Warn on unlogged batches</a></li>\n<li><a name=\"5\" href=\"https://support.datastax.com/hc/en-us/articles/205581555-New-messages-about-the-use-of-batches-in-Cassandra-2-1\" id=\"5\">DataStax Help Center: New messages about the use of batches in Cassandra 2.1</a></li>\n<li><a name=\"6\" href=\"https://docs.datastax.com/en/latest-cql/share/glossary/gloss_partition_key.html\" id=\"6\">CQL Glossary: partition key</a></li>\n<li><a name=\"7\" href=\"https://issues.apache.org/jira/browse/CASSANDRA-6487\" id=\"7\">CASSANDRA-6487: Log WARN on large batch sizes</a></li>\n<li><a name=\"8\" href=\"https://issues.apache.org/jira/browse/CASSANDRA-8011\" id=\"8\">CASSANDRA-8011: Fail on large batch sizes</a></li>\n<li><a name=\"9\" href=\"https://lostechies.com/ryansvihla/2014/08/28/cassandra-batch-loading-without-the-batch-keyword/\" id=\"9\">Cassandra: Batch loading without the Batch keyword</a></li>\n<li><a name=\"10\" href=\"https://issues.apache.org/jira/browse/CASSANDRA-6737\" id=\"10\">CASSANDRA-6737: A batch statements on a single partition should not create a new CF object for each update</a></li>\n<li><a name=\"11\" href=\"https://issues.apache.org/jira/browse/CASSANDRA-10876\" id=\"11\">CASSANDRA-10876: Alter behavior of batch WARN and fail on single partition batches</a></li>\n<li><a name=\"12\" href=\"https://support.datastax.com/hc/en-us/articles/204226199-Common-Causes-of-GC-pauses\" id=\"12\">DataStax Help Center: Common Causes of GC pauses</a></li>\n<li><a name=\"13\" href=\"https://docs.datastax.com/en/cassandra/2.1/cassandra/tools/toolsCFhisto.html\" id=\"13\">Cassandra 2.1 tools: nodetool cfhistograms</a> (for C* 3.+ <a href=\"http://docs.datastax.com/en/cassandra/3.0/cassandra/tools/toolsTablehisto.html\">tablehistograms</a>)</li>\n<li><a name=\"14\" href=\"http://docs.datastax.com/en/cql/3.3/cql/cql_reference/batch_r.html\" id=\"14\">CQL for Cassandra 2.2+: CQL commands / BATCH</a></li>\n<li><a name=\"15\" href=\"http://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/BatchStatement.Type.html\" id=\"15\">Javadoc for BatchStatement.Type</a></li>\n</ol><br />"}}]}},"pageContext":{"alternative_id":3991}}