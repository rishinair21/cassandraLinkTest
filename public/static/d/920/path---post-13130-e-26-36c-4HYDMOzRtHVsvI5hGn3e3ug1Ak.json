{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Designing data models for Cassandra","alternative_id":13130,"content":"<figure class=\"article-image right\"><img src=\"https://d3ucjech6zwjp8.cloudfront.net/360x240/photo-1452696193712-6cabf5103b63-e163e627bc6cf83e0de3beaa0c8a68e2.jpg\" srcset=\"https://d3ucjech6zwjp8.cloudfront.net/360x240/photo-1452696193712-6cabf5103b63-e163e627bc6cf83e0de3beaa0c8a68e2.jpg 360w, https://d3ucjech6zwjp8.cloudfront.net/720x480/photo-1452696193712-6cabf5103b63-e163e627bc6cf83e0de3beaa0c8a68e2.jpg 720w, https://d3ucjech6zwjp8.cloudfront.net/1440x960/photo-1452696193712-6cabf5103b63-e163e627bc6cf83e0de3beaa0c8a68e2.jpg 1440w\" class=\"\" alt=\"image\" /><figcaption>\n          \n                  (source: <a class=\"secondary\" target=\"_blank\" href=\"https://unsplash.com/photos/hsg538WrP0Y\">By drmakete lab on Unsplash</a>)\n        \n        \n      \n    \n    \n  <figcaption></figcaption></figcaption></figure><aside data-type=\"note\"><p>Editor's note: This is <strong>Chapter 5</strong> from <a href=\"http://shop.oreilly.com/product/0636920043041.do?intcmp=il-data-books-videos-product-na_20160217_radar_chapter_5_from_cassandra:_the_definitive_guide_post_editors_note_book_link\">\"Cassandra: The Definitive Guide,\"</a> by Jeff Carpenter and Eben Hewitt.</p>\n</aside><section xmlns=\"http://www.w3.org/1999/xhtml\" data-type=\"chapter\" id=\"chp-modeling\"><h2>Data Modeling</h2>\n<p>In this chapter, you'll learn how to design data models for Cassandra, including a data modeling process and notation. To apply this knowledge, we’ll design the data model for a sample application, which we’ll build over the next several chapters. This will help show how all the parts fit together. Along the way, we’ll use a tool to help us manage our CQL scripts.</p>\n<section data-type=\"sect1\" id=\"conceptual-data-modeling-eKsxIL\"><h2>Conceptual Data Modeling</h2>\n<p>First, let’s create a simple domain model that is easy to understand in the relational world, and then see how we might map it from a relational to a distributed hashtable model in Cassandra.</p>\n<p>To create the example, we want to use something that is complex enough to show the various data structures and design patterns, but not something that will bog you down with details. Also, a domain that’s familiar to everyone will allow you to concentrate on how to work with Cassandra, not on what the application domain is all about.</p>\n<p>For our example, we'll use a domain that is easily understood and that everyone can relate to: making hotel reservations.</p>\n<p>Our conceptual domain includes hotels, guests that stay in the hotels, a collection of rooms for each hotel, the rates and availability of those rooms, and a record of reservations booked for guests. Hotels typically also maintain a collection of “points of interest,” which are parks, museums, shopping galleries, monuments, or other places near the hotel that guests might want to visit during their stay. Both hotels and points of interest need to maintain geolocation data so that they can be found on maps for mashups, and to calculate distances.</p>\n<p>We depict our conceptual domain in <a data-type=\"xref\" href=\"#fig-dm.hotel-er\">Figure 1-1</a> using the entity–relationship model popularized by Peter Chen. This simple diagram represents the entities in our domain with rectangles, and attributes of those entities with ovals. Attributes that represent unique identifiers for items are underlined. Relationships between entities are represented as diamonds, and the connectors between the relationship and each entity show the multiplicity of the connection. </p>\n<figure id=\"fig-dm.hotel-er\"><img src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0501-0dc26557af3d9d98020286c21a6be555.png\" alt=\"image\" /><figcaption>Figure 1-1. Hotel domain entity–relationship diagram</figcaption></figure><p>Obviously, in the real world, there would be many more considerations and much more complexity. For example, hotel rates are notoriously dynamic, and calculating them involves a wide array of factors. Here we’re defining something complex enough to be interesting and touch on the important points, but simple enough to maintain the focus on learning Cassandra.</p>\n</section><section data-type=\"sect1\" id=\"rdbms-design-G1sPtE\"><h2>RDBMS Design</h2>\n<p>When you set out to build a new data-driven application that will  use a relational database, you might start by modeling the domain as a set of properly normalized tables and use foreign keys to reference related data in other tables.</p>\n<p><a class=\"xref\" data-type=\"xref\" href=\"#fig-dm.hotel-rdbms\">Figure 1-2</a> shows how we might represent the data storage for our application using a relational database model. The relational model includes a couple of “join” tables in order to realize the many-to-many relationships from our conceptual model of hotels-to-points of interest, rooms-to-amenities, rooms-to-availability, and guests-to-rooms (via a reservation).</p>\n<figure id=\"fig-dm.hotel-rdbms\"><img src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0502-8a74057b3bb5a654886b1353ae010777.png\" alt=\"image\" /><figcaption>Figure 1-2. A simple hotel search system using RDBMS</figcaption></figure><section data-type=\"sect2\" id=\"design-differences-between-rdbms-and-cassandra-JMsXh7tx\"><h3>Design Differences Between RDBMS and Cassandra</h3>\n<p>Of course, because this is a Cassandra book, what we really  want is to model our data so we can store it in Cassandra.  Before we start creating our Cassandra data model, let’s take a minute to highlight some of the key differences in doing data modeling for Cassandra versus a relational database.</p>\n<section data-type=\"sect3\" id=\"no-joins-ZKsnIehMt9\"><h4>No joins</h4>\n<p>You cannot perform joins in Cassandra. If you have designed a data model and find that you need something like a join, you’ll have to either do the work on the client side, or create a denormalized second table that represents the join results for you. This latter option is preferred in Cassandra data modeling. Performing joins on the client should be a very rare case; you really want to duplicate (denormalize) the data instead.</p>\n</section><section data-type=\"sect3\" id=\"no-referential-integrity-zVsbtyhDtD\"><h4>No referential integrity</h4>\n<p>Although Cassandra supports features such as lightweight transactions and batches, Cassandra itself has no concept of referential integrity across tables. In a relational database, you could specify foreign keys in a table to reference the primary key of a record in another table. But Cassandra does not enforce this. It is still a common design requirement to store IDs related to other entities in your tables, but operations such as cascading deletes are not available.</p>\n</section><section data-type=\"sect3\" id=\"denormalization-yDsYhZhvtn\"><h4>Denormalization</h4>\n<p>In relational database design, we are often taught the importance of normalization. This is not an advantage when working with Cassandra because it performs best when the data model is denormalized. It is often the case that companies end up denormalizing data in relational databases as well. There are two common reasons for this. One is performance. Companies simply can’t get the performance they need when they have to do so many joins on years’ worth of data, so they denormalize along the lines of known queries. This ends up working, but goes against the grain of how relational databases are intended to be designed, and ultimately makes one question whether using a relational database is the best approach in these circumstances.</p>\n<p>A second reason that relational databases get denormalized on purpose is a business document structure that requires retention. That is, you have an enclosing table that refers to a lot of external tables whose data could change over time, but you need to preserve the enclosing document as a snapshot in history. The common example here is with invoices. You already have customer and product tables, and you’d think that you could just make an invoice that refers to those tables. But this should never be done in practice. Customer or price information could change, and then you would lose the integrity of the invoice document as it was on the invoice date, which could violate audits, reports, or laws, and cause other problems.</p>\n<p>In the relational world, denormalization violates Codd's normal forms, and we try to avoid it. But in Cassandra, denormalization is, well, perfectly normal. It's not required if your data model is simple. But don't be afraid of it.</p>\n<div data-type=\"note\" id=\"server-side-denormalization-with-materialized-views-aKUXhOhZhOt7\">\n<h6>Note</h6>\n<h2>Server-Side Denormalization with Materialized Views</h2>\n<p>Historically, denormalization in Cassandra has required designing and managing multiple tables using techniques we will introduce momentarily. Beginning with the 3.0 release, Cassandra provides a feature known as <em>materialized views</em> which allows us to create multiple denormalized views of data based on a base table design. Cassandra manages materialized views on the server, including the work of keeping the views in sync with the table. In this chapter, we'll see examples of both classic denormalization and materialized views.</p>\n</div>\n</section><section data-type=\"sect3\" id=\"query-first-design-V7svTwhktE\"><h4>Query-first design</h4>\n<p>Relational modeling, in simple terms, means that you start from the conceptual domain and then represent the nouns in the domain in tables. You then assign primary keys and foreign keys to model relationships. When you have a many-to-many relationship, you create the join tables that represent just those keys. The join tables don’t exist in the real world, and are a necessary side effect of the way relational models work. After you have all your tables laid out, you can start writing queries that pull together disparate data using the relationships defined by the keys. The queries in the relational world are very much secondary. It is assumed that you can always get the data you want as long as you have your tables modeled properly. Even if you have to use several complex subqueries or join statements, this is usually true.</p>\n<p>By contrast, in Cassandra you don’t start with the data model; you start with the query model. Instead of modeling the data first and then writing queries, with Cassandra you model the queries and let the data be organized around them. Think of the most common query paths your application will use, and then create the tables that you need to support them. </p>\n<p>Detractors have suggested that designing the queries first is overly constraining on application design, not to mention database modeling. But it is perfectly reasonable to expect that you should think hard about the queries in your application, just as you would, presumably, think hard about your relational domain. You may get it wrong, and then you’ll have problems in either world. Or your query needs might change over time, and then you’ll have to work to update your data set. But this is no different from defining the wrong tables, or needing additional tables, in an RDBMS.</p>\n</section><section data-type=\"sect3\" id=\"designing-for-optimal-storage-rWsNcEhxt2\"><h4>Designing for optimal storage</h4>\n<p>In a relational database, it is frequently transparent to the user how tables are stored on disk, and it is rare to hear of recommendations about data modeling based on how the RDBMS might store tables on disk. However, that is an important consideration in Cassandra. Because Cassandra tables are each stored in separate files on disk, it’s important to keep related columns defined together in the same table.</p>\n<p>A key goal that we will see as we begin creating data models in Cassandra is to minimize the number of partitions that must be searched in order to satisfy a given query. Because the partition is a unit of storage that does not get divided across nodes, a query that searches a single partition will typically yield the best performance.</p>\n</section><section data-type=\"sect3\" id=\"sorting-is-a-design-decision-wPsNiehBtn\"><h4>Sorting is a design decision</h4>\n<p>In an RDBMS, you can easily change the order in which records are returned to you by using <code>ORDER BY</code> in your query. The default sort order is not configurable; by default, records are returned in the order in which they are written. If you want to change the order, you just modify your query, and you can sort by any list of columns.</p>\n<p>In Cassandra, however, sorting is treated differently; it is a design decision. The sort order available on queries is fixed, and is determined entirely by the selection of clustering columns you supply in the <code>CREATE TABLE</code> command. The CQL <code>SELECT</code> statement does support <code>ORDER BY</code> semantics, but only in the order specified by the clustering columns.</p>\n</section></section></section><section data-type=\"sect1\" id=\"defining-application-queries-DVsGhZ\"><h2>Defining Application Queries</h2>\n<p>Let's try the query-first approach to start designing the data model for our hotel application. The user interface design for the application is often a great artifact to use to begin identifying queries. Let’s assume that we’ve talked with the project stakeholders and our UX designers have produced user interface designs or wireframes for the key use cases. We’ll likely have a list of shopping queries like the following:</p>\n<ul><li>Q1. Find hotels near a given point of interest.</li>\n\t<li>Q2. Find information about a given hotel, such as its name and location.</li>\n\t<li>Q3. Find points of interest near a given hotel.</li>\n\t<li>Q4. Find an available room in a given date range.</li>\n\t<li>Q5. Find the rate and amenities for a room.</li>\n</ul><div data-type=\"note\" id=\"number-your-queries-dLUXtoh8\">\n<h6>Note</h6>\n<h2>Number Your Queries</h2>\n<p>It is often helpful to be able to refer to queries by a shorthand number rather that explaining them in full. The queries listed here are numbered Q1, Q2, and so on, which is how we will reference them in diagrams as we move throughout our example.</p>\n</div>\n<p>Now if our application is to be a success, we’ll certainly want our customers to be able to book reservations at our hotels. This includes steps such as selecting an available room and entering their guest information. So clearly we will also need some queries that address the reservation and guest entities from our conceptual data model. Even here, however, we’ll want to think not only from the customer perspective in terms of how the data is written, but also in terms of how the data will be queried by downstream use cases.</p>\n<p>Our natural tendency as data modelers would be to focus first on designing the tables to store reservation and guest records, and only then start thinking about the queries that would access them. You may have felt a similar tension already when we began discussing the shopping queries before, thinking “but where did the hotel and point of interest data come from?” Don’t worry, we will get to this soon enough. Here are some queries that describe how our users will access reservations:</p>\n<ul><li>Q6. Lookup a reservation by confirmation number.</li>\n\t<li>Q7. Lookup a reservation by hotel, date, and guest name.</li>\n\t<li>Q8. Lookup all reservations by guest name.</li>\n\t<li>Q9. View guest details.</li>\n</ul><p>We show all of our queries in the context of the workflow of our application in <a data-type=\"xref\" href=\"#fig-dm.hotel-queries\">Figure 1-3</a>. Each box on the diagram represents a step in the application workflow, with arrows indicating the flows between steps and the associated query. If we've modeled our application well, each step of the workflow accomplishes a task that \"unlocks\" subsequent steps. For example, the \"View hotels near POI\" task helps the application learn about several hotels, including their unique keys. The key for a selected hotel may be used as part of Q2, in order to obtain detailed description of the hotel. The act of booking a room creates a reservation record that may be accessed by the guest and hotel staff at a later time through various additional queries.</p>\n<figure id=\"fig-dm.hotel-queries\"><img src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0503-1d63e7eb2bceaf72e8fb27fd1aaf0b4e.png\" alt=\"image\" /><figcaption>Figure 1-3. Hotel application queries</figcaption></figure></section><section data-type=\"sect1\" id=\"logical-data-modeling-kpsOTo\"><h2>Logical Data Modeling</h2>\n<p>Now that we have defined our queries, we’re ready to begin designing our Cassandra tables. First, we'll create a logical model containing a table for each query, capturing entities and relationships from the conceptual model.</p>\n<p>To name each table, we'll identify the primary entity type for which we are querying and use that to start the entity name. If we are querying by attributes of other related entities, we append those to the table name, separated with <code>_by_</code>. For example, <code>hotels_by_poi</code>.</p>\n<p>Next, we identify the primary key for the table, adding partition key columns based on the required query attributes, and clustering columns in order to guarantee uniqueness and support desired sort ordering.</p>\n<p>We complete each table by adding any additional attributes identified by the query. If any of these additional attributes are the same for every instance of the partition key, we mark the column as static.</p>\n<p>Now that was a pretty quick description of a fairly involved process, so it will be worth our time to work through a detailed example. First, let's introduce a notation that we can use to represent our logical models.</p>\n<aside data-type=\"sidebar\" id=\"id-wKS1coTe\"><h6>Introducing Chebotko Diagrams</h6>\n<p>Several individuals within the Cassandra community have proposed notations for capturing data models in diagrammatic form. We’ve elected to use a notation popularized by Artem Chebotko which provides a simple, informative way to visualize the relationships between queries and tables in our designs. <a data-type=\"xref\" href=\"#fig-dm.chebotko-logical\">Figure 1-4</a> shows the Chebotko notation for a logical data model.</p>\n<figure id=\"fig-dm.chebotko-logical\"><img class=\"width_80\" src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0504-958790ecce14049c328961e46f893130.png\" alt=\"image\" /><figcaption>Figure 1-4. A Chebotko logical diagram</figcaption></figure><p>Each table is shown with its title and a list of columns. Primary key columns are identified via symbols such as <strong>K</strong> for partition key columns and <strong>C↑</strong> or <strong>C↓</strong> to represent clustering columns. Lines are shown entering tables or between tables to indicate the queries that each table is designed to support.</p>\n</aside><section data-type=\"sect2\" id=\"hotel-logical-data-model-V7sBiDTl\"><h3>Hotel Logical Data Model</h3>\n<p><a data-type=\"xref\" href=\"#fig-dm.hotel-logical\">Figure 1-5</a> shows a Chebotko logical data model for the queries involving hotels, points of interest, rooms, and amenities. One thing we notice immediately is that our Cassandra design doesn't include dedicated tables for rooms or amenities, as we had in the relational design. This is because our workflow didn't identify any queries requiring this direct access.</p>\n<figure id=\"fig-dm.hotel-logical\"><img src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0505-d723dec7477b104c8bddffb61e82130d.png\" alt=\"image\" /><figcaption>Figure 1-5. Hotel domain logical model</figcaption></figure><p>Let's explore the details of each of these tables.</p>\n<p>Our first query Q1 is to find hotels near a point of interest, so we’ll call our table <code>hotels_by_poi</code>. We’re searching by a named point of interest, so that is a clue that the point of interest should be a part of our primary key. Let's reference the point of interest by name, because according to our workflow that is how our users will start their search.</p>\n<p>You’ll note that we certainly could have more than one hotel near a given point of interest, so we’ll need another component in our primary key in order to make sure we have a unique partition for each hotel. So we add the hotel key as a clustering column.</p>\n<div data-type=\"note\" id=\"make-your-primary-keys-unique-AWUNc2iATA\">\n<h6>Note</h6>\n<h2>Make Your Primary Keys Unique</h2>\n<p>An important consideration in designing your table's primary key is making sure that it defines a unique data element. Otherwise you run the risk of accidentally overwriting data.</p>\n</div>\n<p>Now for our second query (Q2), we’ll need a table to get information about a specific hotel. One approach would have been to put all of the attributes of a hotel in the <code>hotels_by_poi</code> table, but we chose to add only those attributes that were required by our application workflow.</p>\n<p>From our workflow diagram, we know that the <code>hotels_by_poi</code> table is used to display a list of hotels with basic information on each hotel, and the application knows the unique identifiers of the hotels returned. When the user selects a hotel to view details, we can then use Q2, which is used to obtain details about the hotel. Because we already have the <code>hotel_id</code> from Q1, we use that as our reference to the hotel we’re looking for. Therefore our second table is just called <code>hotels</code>.</p>\n<p>Another option would have been to store a set of <code>poi_names</code> in the hotels table. This is an equally valid approach. You’ll learn through experience which approach is best for your application.</p>\n<div data-type=\"note\" id=\"using-unique-identifiers-as-references-DDUvCViGTE\">\n<h6>Note</h6>\n<h2>Using Unique Identifiers as References</h2>\n<p>You’ll find that it's often helpful to use unique IDs to uniquely reference elements, and to use these <code>uuids</code> as references in tables representing other entities. This helps to minimize coupling between different entity types. This may prove especially helpful if you are using a microservice architectural style for your application, in which there are separate services responsible for each entity type.</p>\n<p>For the purposes of this book, however, we'll use mostly <code>text</code> attributes as identifiers, to keep our samples simple and readable. For example, a common convention in the hospitality industry is to reference properties by short codes like \"AZ123\" or \"NY229\". We'll use these values for our <code>hotel_id</code>s, while acknowledging they are not necessarily globally unique.</p>\n</div>\n<p>Q3 is just a reverse of Q1—looking for points of interest near a hotel, rather than hotels near a point of interest. This time, however, we need to access the details of each point of interest, as represented by the <code>pois_by_hotel</code> table. As we have done previously, we add the point of interest name as a clustering key to guarantee uniqueness.</p>\n<p class=\"pagebreak-before\">At this point, let's now consider how to support query Q4 to help our user find available rooms at a selected hotel for the nights they are interested in staying. Note that this query involves both a start date and an end date. Because we're querying over a range instead of a single date, we know that we'll need to use the date as a clustering key. We use the <code class=\"keep-together\">hotel_id</code> as a primary key to group room data for each hotel on a single partition, which should help our search be super fast. Let's call this the <code class=\"keep-together\">available_rooms_by_hotel_date</code> table.</p>\n<p>In order to round out the shopping portion of our data model, we add the <code class=\"keep-together\">amenities_by_room</code> table to support Q5.  This will allow our user to view the amenities of one of the rooms that is available for the desired stay dates.</p>\n</section><section data-type=\"sect2\" id=\"reservation-logical-data-model-rWsmuATN\"><h3>Reservation Logical Data Model</h3>\n<p>Now we switch gears to look at the reservation queries. <a data-type=\"xref\" href=\"#fig-dm.reservation-logical\">Figure 1-6</a> shows a logical data model for reservations. You'll notice that these tables represent a denormalized design; the same data appears in multiple tables, with differing keys. </p>\n<figure id=\"fig-dm.reservation-logical\"><img src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0506-dd6c99eb03504e827918d5bd0966805b.png\" alt=\"image\" /><figcaption>Figure 1-6. A denormalized logical model for reservations</figcaption></figure><p>In order to satisfy Q6, the <code>reservations_by_confirmation</code> table supports the look up of reservations by a unique confirmation number provided to the customer at the time of booking.</p>\n<p>If the guest doesn't have the confirmation number, the <code>reservations_by_guest</code> table can be used to look up the reservation by guest name. We could envision query Q7 being used on behalf of a guest on a self-serve website or a call center agent trying to assist the guest. Because the guest name might not be unique, we include the guest ID here as a clustering column as well.</p>\n<p>The hotel staff might wish to see a record of upcoming reservations by date in order to get insight into how the hotel is performing, such as what dates the hotel is sold out or undersold. Q8 supports the retrieval of reservations for a given hotel by date.</p>\n<p>Finally, we create a <code>guests</code> table. You'll notice that it has similar attributes to our <code>user</code> table from <a href=\"https://www.safaribooksonline.com/library/view/cassandra-the-definitive/9781491933657/ch04.html?utm_source=oreilly&amp;utm_medium=newsite&amp;utm_campaign=cassandra-data-modeling\">Chapter 4</a>. This provides a single location that we can use to store our guests. In this case, we specify a separate unique identifier for our guest records, as it is not uncommon for guests to have the same name. In many organizations, a customer database such as our <code>guests</code> table would be part of a separate customer management application, which is why we've omitted other guest access patterns from our example.</p>\n<aside data-type=\"sidebar\" id=\"id-qBSJubudTZ\"><h6>Patterns and Anti-Patterns</h6>\n<p>As with other types of software design, there are some well-known patterns and anti-patterns for data modeling in Cassandra. We've already used one of the most common patterns in our hotel model—the wide row.</p>\n<p>The time series pattern is an extension of the wide row pattern. In this pattern, a series of measurements at specific time intervals are stored in a wide row, where the measurement time is used as part of the partition key. This pattern is frequently used in domains including business analysis, sensor data management, and scientific experiments.</p>\n<p>The time series pattern is also useful for data other than measurements. Consider the example of a banking application. We could store each customer's balance in a row, but that might lead to a lot of read and write contention as various customers check their balance or make transactions. We'd probably be tempted to wrap a transaction around our writes just to protect the balance from being updated in error. In contrast, a time series–style design would store each transaction as a timestamped row and leave the work of calculating the current balance to the application.</p>\n<p>One design trap that many new users fall into is attempting to use Cassandra as a queue. Each item in the queue is stored with a timestamp in a wide row. Items are appended to the end of the queue and read from the front, being deleted after they are read. This is a design that seems attractive, especially given its apparent similarity to the time series pattern. The problem with this approach is that the deleted items are now tombstones that Cassandra must scan past in order to read from the front of the queue. Over time, a growing number of tombstones begins to degrade read performance.</p>\n<p>The queue anti-pattern serves as a reminder that any design that relies on the deletion of data is potentially a poorly performing design.</p>\n</aside></section></section><section data-type=\"sect1\" id=\"physical-data-modeling-4ksZc8\"><h2>Physical Data Modeling</h2>\n<p>Once we have a logical data model defined, creating the physical model is a relatively simple process.</p>\n<p>We walk through each of our logical model tables, assigning types to each item. We can use any of the types we covered in <a href=\"https://www.safaribooksonline.com/library/view/cassandra-the-definitive/9781491933657/ch04.html?utm_source=oreilly&amp;utm_medium=newsite&amp;utm_campaign=cassandra-data-modeling\">Chapter 4</a>, including the basic types, collections, and user-defined types. We may identify additional user-defined types that can be created to simplify our design.</p>\n<p>After we've assigned our data types, we analyze our model by performing size calculations and testing out how the model works. We may make some adjustments based on our findings. Once again we'll cover the data modeling process in more detail by working through our example.</p>\n<p>Before we get started, let's look at a few additions to the Chebotko notation for physical data models.</p>\n<aside data-type=\"sidebar\" id=\"id-wKSvTnce\"><h6>Chebotko Physical Diagrams</h6>\n<p>To draw physical models, we need to be able to add the typing information for each column. <a data-type=\"xref\" href=\"#fig-dm.chebotko-physical\">Figure 1-7</a> shows the addition of a type for each column in a sample table.</p>\n<p>The figure includes a designation of the keyspace containing each table and visual cues for columns represented using collections and user-defined types. We also note the designation of static columns and secondary index columns. There is no restriction on assigning these as part of a logical model, but they are typically more of a physical data modeling concern.</p>\n<figure id=\"fig-dm.chebotko-physical\"><img src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0507-b49ebb45c9b006f5589f8275189f4917.png\" alt=\"image\" /><figcaption>Figure 1-7. Extending the Chebotko notation for physical data models</figcaption></figure></aside><section data-type=\"sect2\" id=\"hotel-physical-data-model-V7srclcl\"><h3>Hotel Physical Data Model</h3>\n<p>Now let's get to work on our physical model. First, we need keyspaces for our tables. To keep the design relatively simple, we'll create a <code>hotel</code> keyspace to contain our tables for hotel and availability data, and a <code>reservation</code> keyspace to contain tables for reservation and guest data. In a real system, we might divide the tables across even more keyspaces in order to separate concerns.</p>\n<p>For our <code>hotels</code> table, we'll use Cassandra's <code>text</code> type to represent the hotel's <code>id</code>. For the address, we'll use the <code>address</code> type that we created in <a href=\"https://www.safaribooksonline.com/library/view/cassandra-the-definitive/9781491933657/ch04.html?utm_source=oreilly&amp;utm_medium=newsite&amp;utm_campaign=cassandra-data-modeling\">Chapter 4</a>. We use the <code>text</code> type to represent the phone number, as there is considerable variance in the formatting of numbers between countries.</p>\n<p>As we work to create physical representations of various tables in our logical hotel data model, we use the same approach. The resulting design is shown in <a data-type=\"xref\" href=\"#fig-dm.hotel-physical\">Figure 1-8</a>.</p>\n<figure id=\"fig-dm.hotel-physical\"><img src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0508-c54b64eaf48150d442c83c26bed67cf7.png\" alt=\"image\" /><figcaption>Figure 1-8. Hotel physical model</figcaption></figure><p>Note that we have also included the <code>address</code> type in our design. It is designated with an asterisk to denote that it is a user-defined type, and has no primary key columns identified. We make use of this type in the <code>hotels</code> and <code>hotels_by_poi</code> tables.</p>\n<div data-type=\"note\" id=\"taking-advantage-of-user-defined-types-AWUNcQcJcA\">\n<h6>Note</h6>\n<h2>Taking Advantage of User-Defined Types</h2>\n<p>It is often helpful to make use of user-defined types to help reduce duplication of non-primary key columns, as we have done with the <code>address</code> user-defined type. This can reduce complexity in the design.</p>\n<p>Remember that the scope of a UDT is the keyspace in which it is defined. To use <code>address</code> in the <code>reservation</code> keyspace we're about to design, we'll have to declare it again. This is just one of the many trade-offs we have to make in data model design.</p>\n</div>\n</section><section data-type=\"sect2\" id=\"reservation-physical-data-model-rWsqiqcN\"><h3>Reservation Physical Data Model</h3>\n<p>Now, let's turn our attention to the reservation tables in our design. Remember that our logical model contained three denormalized tables to support queries for reservations by confirmation number, guest, and hotel and date. As we work to implement these different designs, we'll want to consider whether to manage the denormalization manually or use Cassandra's materialized view capability.</p>\n<p>The design shown for the <code>reservation</code> keyspace in <a data-type=\"xref\" href=\"#fig-dm.reservation-physical\">Figure 1-9</a> uses both approaches. We chose to implement <code>reservations_by_hotel_date</code> and <code>reservations_by_guest</code> as regular tables, and <code>reservations_by_confirmation</code> as a materialized view on the <code>reservations_by_hotel_date</code> table. We'll discuss the reasoning behind this design choice momentarily.</p>\n<figure id=\"fig-dm.reservation-physical\"><img src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0509-4e190853a08ccd3779b19f16aee2a46a.png\" alt=\"image\" /><figcaption>Figure 1-9. Reservation physical model</figcaption></figure><p>Note that we have reproduced the <code>address</code> type in this keyspace and modeled the <code>guest_id</code> as a <code>uuid</code> type in all of our tables.  </p>\n</section><section data-type=\"sect2\" id=\"materialized-views-wPsPunce\"><h3>Materialized Views</h3>\n<p>Materialized views  were introduced to help address some of the shortcomings of secondary indexes, which we discussed in <a href=\"https://www.safaribooksonline.com/library/view/cassandra-the-definitive/9781491933657/ch04.html?utm_source=oreilly&amp;utm_medium=newsite&amp;utm_campaign=cassandra-data-modeling\">Chapter 4</a>. Creating indexes on columns with high cardinality tends to result in poor performance, because most or all of the nodes in the ring need are queried.</p>\n<p>Materialized views address this problem by storing preconfigured views that support queries on additional columns which are not part of the original clustering key. Materialized views simplify application development: instead of the application having to keep multiple denormalized tables in sync, Cassandra takes on the responsibility of updating views in order to keep them consistent with the base table.</p>\n<p>Materialized views incur a small performance impact on writes in order to maintain this consistency. However, materialized views demonstrate more efficient performance compared to managing denormalized tables in application clients. Internally, materialized view updates are implemented using batching, which we will discuss in <a href=\"https://www.safaribooksonline.com/library/view/cassandra-the-definitive/9781491933657/ch09.html?utm_source=oreilly&amp;utm_medium=newsite&amp;utm_campaign=cassandra-data-modeling\">Chapter 9</a>.</p>\n<p>Similar to secondary indexes, materialized views can be created on existing tables.</p>\n<p>To understand the syntax and constraints associated with materialized views, we'll take a look at the CQL command that creates the <code class=\"keep-together\">reservations_by_confirmation</code> table from the reservation physical model:</p>\n<pre data-type=\"programlisting\">\ncqlsh&gt; <strong>CREATE MATERIALIZED VIEW</strong> reservation.reservations_by_confirmation \n  <strong>AS SELECT</strong> * \n  <strong>FROM</strong> reservation.reservations_by_hotel_date\n  <strong>WHERE</strong> confirm_number IS NOT NULL and hotel_id IS NOT NULL and\n    start_date IS NOT NULL and room_number IS NOT NULL\n  <strong>PRIMARY KEY</strong> (confirm_number, hotel_id, start_date, room_number);\n</pre>\n<p>The order  of the clauses in the <code>CREATE MATERIALIZED VIEW</code> command can appear somewhat inverted, so we'll walk through these clauses in an order that is a bit easier to process.</p>\n<p>The first parameter after the command is the name of the materialized view—in this case, <code>reservations_by_confirmation</code>.  The <code>FROM</code> clause identifies the base table for the materialized view, <code>reservations_by_hotel_date</code>.</p>\n<p>The <code>PRIMARY KEY</code> clause identifies the primary key for the materialized view, which must include all of the columns in the primary key of the base table. This restriction keeps Cassandra from collapsing multiple rows in the base table into a single row in the materialized view, which would greatly increase the complexity of managing updates.</p>\n<p>The grouping of the primary key columns uses the same syntax as an ordinary table. The most common usage is to place the additional column first as the partition key, followed by the base table primary key columns, used as clustering columns for purposes of the materialized view.</p>\n<p>The <code>WHERE</code> clause provides support for filtering.Note that a filter must be specified for every primary key column of the materialized view, even if it is as simple as designating that the value <code>IS NOT NULL</code>.</p>\n<p>The <code>AS SELECT</code> clause identifies the columns from the base table that we want our materialized view to contain. We can reference individual columns, but in this case have chosen for all columns to be part of the view by using the wildcard <code>*</code>.</p>\n<div data-type=\"note\" id=\"enhanced-materialized-view-capabilities-ZdUKfPupc9\">\n<h6>Note</h6>\n<h2>Enhanced Materialized View Capabilities</h2>\n<p>The initial implementation of materialized views in the 3.0 release has some limitations on the selection of primary key columns and filters. There are several JIRA issues in progress to add capabilities such as multiple non-primary key columns in materialized view primary keys <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-9928\">CASSANDRA-9928</a> or using aggregates in materialized views <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-9778\">CASSANDRA-9778</a>. If you're interested in these features, track the JIRA issues to see when they will be included in a release.</p>\n</div>\n<p>Now that we have a better understanding of the design and use of materialized views, we can revisit the prior decision made for the reservation physical design. Specifically, <code class=\"keep-together\">reservations_by_confirmation</code> is a good candidate for implementation as a materialized view due to the high cardinality of the confirmation numbers—after all, you can't get any higher cardinality than a unique value per reservation.</p>\n<p>An alternate design would have been to use <code>reservations_by_confirmation</code> as the base table and <code>reservations_by_hotel_date</code> as a materialized view. However, because we cannot (at least in early 3.X releases) create a materialized view with multiple non-primary key column from the base table, this would have required us to designate either <code>hotel_id</code> or <code>date</code> as a clustering column in <code>reservations_by_confirmation</code>. Both designs are acceptable, but this should give some insight into the trade-offs you'll want to consider in selecting which of several denormalized table designs to use as the base table.</p>\n</section></section><section data-type=\"sect1\" id=\"evaluating-and-refining-JMs7iG\"><h2>Evaluating and Refining</h2>\n<p>Once we've created our physical model, there are some steps we'll want to take to evaluate and refine our table designs to help ensure optimal performance.</p>\n<section data-type=\"sect2\" id=\"calculating-partition-size-ZKsnIoi2\"><h3>Calculating Partition Size</h3>\n<p>The first thing that we want to look for is whether our tables will have partitions that will be overly large, or to put it another way, partitions that are too wide. Partition size is measured by the number of cells (values) that are stored in the partition. Cassandra's hard limit is 2 billion cells per partition, but we'll likely run into performance issues before reaching that limit.</p>\n<p>In order to calculate the size of our partitions, we use the following formula:</p>\n<p>\\(N_v = N_r (N_c - N_{pk} - N_s) + N_s\\)</p>\n<p>The number of values (or cells) in the partition (N<sub>v</sub>) is equal to the number of static columns (N<sub>s</sub>) plus the product of the number of rows (N<sub>r</sub>) and the number of of values per row. The number of values per row is defined as the number of columns (N<sub>c</sub>) minus the number of primary key columns (N<sub>pk</sub>) and static columns (N<sub>s</sub>).</p>\n<p>The number of columns tends to be relatively static, although as we have seen it is quite possible to alter tables at runtime. For this reason, a primary driver of partition size is the number of rows in the partition. This is a key factor that you must consider in determining whether a partition has the potential to get too large. Two billion values sounds like a lot, but in a sensor system where tens or hundreds of values are measured every millisecond, the number of values starts to add up pretty fast.</p>\n<p>Let's take a look at one of our tables to analyze the partition size. Because it has a wide row design with a partition per hotel, we'll choose the <code>available_rooms_​by_hotel_date</code> table. The table has four columns total (N<sub>c</sub> = 4), including three primary key columns (N<sub>pk</sub> = 3) and no static columns (N<sub>s</sub> = 0). Plugging these values into our formula, we get:</p>\n<p>\\(N_v = N_r (4 - 3 - 0) + 0 = 1N_r\\)</p>\n<p>So the number of values for this table is equal to the number of rows. We still need to determine a number of rows. To do this, we make some estimates based on the application we're designing. Our table is storing a record for each room, in each of our hotels, for every night. Let's assume that our system will be used to store two years of inventory at a time, and there are 5,000 hotels in our system, with an average of 100 rooms in each hotel.</p>\n<p>Since there is a partition for each hotel, our estimated number of rows per partition is as follows:</p>\n<p>\\(N_r = 100\\:\\mathrm{rooms/hotel} \\times 730\\:\\mathrm{days} = 73,000\\:\\mathrm{rows}\\)</p>\n<p>This relatively small number of rows per partition is not going to get us in too much trouble, but if we start storing more dates of inventory, or don’t manage the size of our inventory well using TTL, we could start having issues. We still might want to look at breaking up this large partition, which we'll do shortly.</p>\n<div data-type=\"note\" id=\"estimate-for-the-worst-case-GJUKHjIVi4\">\n<h6>Note</h6>\n<h2>Estimate for the Worst Case</h2>\n<p>When performing sizing calculations, it is tempting to assume the nominal or average case for variables such as the number of rows. Consider calculating the worst case as well, as these sorts of predictions have a way of coming true in successful systems.</p>\n</div>\n</section><section data-type=\"sect2\" id=\"calculating-size-on-disk-zVsbtAin\"><h3>Calculating Size on Disk</h3>\n<p>In addition to calculating the size of our partition, it is also an excellent idea for us to estimate the amount of disk space that will be required for each table we plan to store in the cluster. In order to determine the size, we use the following formula to determine the size S<sub>t</sub> of a partition:</p>\n<p>\\(S_t = \\displaystyle\\sum_i sizeOf\\big (c_{k_i}\\big) + \\displaystyle\\sum_j sizeOf\\big(c_{s_j}\\big) + N_r\\times\\bigg(\\displaystyle\\sum_k sizeOf\\big(c_{r_k}\\big) + \\displaystyle\\sum_l sizeOf\\big(c_{c_l}\\big)\\bigg) + N_v\\times sizeOf\\big(t_{avg}\\big)\\)</p>\n<p>This is a bit more complex than our previous formula, but we'll break it down a bit at a time. Let's take a look at the notation first:</p>\n<ul><li>In this formula, c<sub>k</sub> refers to partition key columns, c<sub>s</sub> to static columns, c<sub>r</sub> to regular columns, and c<sub>c</sub> to clustering columns.</li>\n\t<li>The term t<sub>avg</sub> refers to the average number of bytes of metadata stored per cell, such as timestamps. It is typical to use an estimate of 8 bytes for this value.</li>\n\t<li>We recognize the number of rows N<sub>r</sub> and number of values N<sub>v</sub> from our previous calculations.</li>\n\t<li>The <em>sizeOf()</em> function refers to the size in bytes of the CQL data type of each referenced column.\n</li>\n</ul><p>The first term asks us to sum the size of the partition key columns. For our example, the <code>available_rooms_by_hotel_date</code> table has a single partition key column, the <code>hotel_id</code>, which we chose to make of type <code>text</code>. Assuming our hotel identifiers are simple 5-character codes, we have a 5-byte value, so the sum of our partition key column sizes is 5 bytes.</p>\n<p>The second term asks us to sum the size of our static columns. Our table has no static columns, so in our case this is 0 bytes.</p>\n<p>The third term is the most involved, and for good reason—it is calculating the size of the cells in the partition. We sum the size of the clustering columns and regular columns. Our two clustering columns are the <code>date</code>, which we assume is 4 bytes, and the <code>room_number</code>, which is a 2-byte short integer, giving us a sum of 6 bytes. There is only a single regular column, the boolean <code>is_available</code>, which is 1 byte in size. Summing the regular column size (1 byte) plus the clustering column size (6 bytes) gives us a total of 7 bytes. To finish up the term, we multiply this value by the number of rows (73,000), giving us 511,000 bytes (0.51 MB).</p>\n<p>The fourth term is simply counting the metadata that that Cassandra stores for each cell. In the storage format used by Cassandra 3.0 and later, the amount of metadata for a given cell varies based on the type of data being stored, and whether or not custom timestamp or TTL values are specified for individual cells. For our table, we reuse the number of values from our previous calculation (73,000) and multiply by 8, which gives us 0.58 MB.</p>\n<p>Adding these terms together, we get our final estimate:</p>\n<p>Partition size = 16 bytes + 0 bytes + 0.51 MB + 0.58 MB = 1.1 MB</p>\n<p>This formula is an approximation of the actual size of a partition on disk, but is accurate enough to be quite useful. Remembering that the partition must be able to fit on a single node, it looks like our table design will not put a lot of strain on our disk storage.</p>\n<div data-type=\"note\" id=\"a-more-compact-storage-format-DDUZHmt1iE\">\n<h6>Note</h6>\n<h2>A More Compact Storage Format</h2>\n<p>As mentioned in <a href=\"https://www.safaribooksonline.com/library/view/cassandra-the-definitive/9781491933657/ch02.html?utm_source=oreilly&amp;utm_medium=newsite&amp;utm_campaign=cassandra-data-modeling\">Chapter 2</a>, Cassandra’s storage engine was re-implemented for the 3.0 release, including a new format for SSTable files. The previous format stored a separate copy of the clustering columns as part of the record for each cell. The newer format eliminates this duplication, which reduces the size of stored data and simplifies the formula for computing that size.</p>\n</div>\n<p>Keep in mind also that this estimate only counts a single replica of our data. We will need to multiply the value obtained here by the number of partitions and the number of replicas specified by the keyspace's replication strategy in order to determine the total required total capacity for each table. This will come in handy when we discuss how to plan our clusters in <a href=\"https://www.safaribooksonline.com/library/view/cassandra-the-definitive/9781491933657/ch14.html?utm_source=oreilly&amp;utm_medium=newsite&amp;utm_campaign=cassandra-data-modeling\">Chapter 14</a>.</p>\n</section><section data-type=\"sect2\" id=\"breaking-up-large-partitions-yDsYh7ib\"><h3>Breaking Up Large Partitions</h3>\n<p>As discussed previously, our goal is to design tables that can provide the data we need with queries that touch a single partition, or failing that, the minimum possible number of partitions. However, as we have seen in our examples, it is quite possible to design wide row-style tables that approach Cassandra's built-in limits. Performing sizing analysis on tables may reveal partitions that are potentially too large, either in number of values, size on disk, or both.</p>\n<p>The technique for splitting a large partition is straightforward: add an additional column to the partition key. In most cases, moving one of the existing columns into the partition key will be sufficient. Another option is to introduce an additional column to the table to act as a sharding key, but this requires additional application logic.</p>\n<p>Continuing to examine our available rooms example, if we add the <code>date</code> column to the partition key for the <code>available_rooms_by_hotel_date</code> table, each partition would then represent the availability of rooms at a specific hotel on a specific date. This will certainly yield partitions that are significantly smaller, perhaps too small, as the data for consecutive days will likely be on separate nodes.</p>\n<p>Another technique known as <em>bucketing </em>is often used to break the data into moderate-size partitions. For example, we could bucketize our <code>available_rooms_​by_hotel_date</code> table by adding a <code>month</code> column to the partition key. While this column is partially duplicative of the <code>date</code>, it provides a nice way of grouping related data in a partition that will not get too large.</p>\n<p>If we really felt strongly about preserving a wide row design, we could instead add the <code>room_id</code> to the partition key, so that each partition would represent the availability of the room across all dates. Because we haven't identified a query that involves searching availability of a specific room, the first or second design approach is most suitable to our application needs.</p>\n</section></section><section data-type=\"sect1\" id=\"defining-database-schema-9ps7uD\"><h2>Defining Database Schema</h2>\n<p>Once we have finished evaluating and refining our physical model, we're ready to implement the schema in CQL. Here is the schema for the <code>hotel</code> keyspace, using CQL's comment feature to document the query pattern supported by each table:</p>\n<pre data-type=\"programlisting\">\nCREATE KEYSPACE hotel\n    WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};\nCREATE TYPE hotel.address (\n    street text,\n    city text,\n    state_or_province text,\n    postal_code text,\n    country text\n);\nCREATE TABLE hotel.hotels_by_poi (\n    poi_name text,\n    hotel_id text,\n    name text,\n    phone text,\n    address frozen&lt;address&gt;,\n    PRIMARY KEY ((poi_name), hotel_id)\n) WITH comment = 'Q1. Find hotels near given poi'\nAND CLUSTERING ORDER BY (hotel_id ASC) ;\nCREATE TABLE hotel.hotels (\n    id text PRIMARY KEY,\n    name text,\n    phone text,\n    address frozen&lt;address&gt;,\n    pois set&lt;text&gt;\n) WITH comment = 'Q2. Find information about a hotel';\nCREATE TABLE hotel.pois_by_hotel (\n    poi_name text,\n    hotel_id text,\n    description text,\n    PRIMARY KEY ((hotel_id), poi_name)\n) WITH comment = 'Q3. Find pois near a hotel';\nCREATE TABLE hotel.available_rooms_by_hotel_date (\n    hotel_id text,\n    date date,\n    room_number smallint,\n    is_available boolean,\n    PRIMARY KEY ((hotel_id), date, room_number)\n) WITH comment = 'Q4. Find available rooms by hotel / date';\nCREATE TABLE hotel.amenities_by_room (\n    hotel_id text,\n    room_number smallint,\n    amenity_name text,\n    description text,\n    PRIMARY KEY ((hotel_id, room_number), amenity_name)\n) WITH comment = 'Q5. Find amenities for a room';\n</pre>\n<div data-type=\"note\" id=\"identify-partition-keys-explicitly-EkUmteu1\">\n<h6>Note</h6>\n<h2>Identify Partition Keys Explicitly</h2>\n<p>We chose to represent our tables by surrounding the elements of our partition key with parentheses, even though the partition key consists of the single column <code>poi_name</code>. This is a best practice that makes our selection of partition key more explicit to others reading our CQL.</p>\n</div>\n<p>Similarly, here is the schema for the <code>reservation</code> keyspace:</p>\n<pre data-type=\"programlisting\">\nCREATE KEYSPACE reservation\n    WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};\nCREATE TYPE reservation.address (\n    street text,\n    city text,\n    state_or_province text,\n    postal_code text,\n    country text\n);\nCREATE TABLE reservation.reservations_by_hotel_date (\n    hotel_id text,\n    start_date date,\n    end_date date,\n    room_number smallint,\n    confirm_number text,\n    guest_id uuid,\n    PRIMARY KEY ((hotel_id, start_date), room_number)\n) WITH comment = 'Q7. Find reservations by hotel and date';\nCREATE MATERIALIZED VIEW reservation.reservations_by_confirmation AS\n    SELECT * FROM reservation.reservations_by_hotel_date\n    WHERE confirm_number IS NOT NULL and hotel_id IS NOT NULL and\n        start_date IS NOT NULL and room_number IS NOT NULL\n    PRIMARY KEY (confirm_number, hotel_id, start_date, room_number);\nCREATE TABLE reservation.reservations_by_guest (\n    guest_last_name text,\n    hotel_id text,\n    start_date date,\n    end_date date,\n    room_number smallint,\n    confirm_number text,\n    guest_id uuid,\n    PRIMARY KEY ((guest_last_name), hotel_id)\n) WITH comment = 'Q8. Find reservations by guest name';\nCREATE TABLE reservation.guests (\n    guest_id uuid PRIMARY KEY,\n    first_name text,\n    last_name text,\n    title text,\n    emails set&lt;text&gt;,\n    phone_numbers list&lt;text&gt;,\n    addresses map&lt;text, frozen&lt;address&gt;&gt;,\n    confirm_number text\n) WITH comment = 'Q9. Find guest by ID';\n</pre>\n<section data-type=\"sect2\" id=\"datastax-devcenter-wPs1caue\"><h3>DataStax DevCenter</h3>\n<p>We've already had quite  a bit of practice creating schema using <code>cqlsh</code>, but now that we're starting to create an application data model with more tables, it starts to be more of a challenge to keep track of all of that CQL.</p>\n<p>Thankfully, there is a great development tool provided by DataStax called DevCenter. This tool is available as a <a href=\"https://academy.datastax.com/downloads\">free download from the DataStax Academy</a>. <a data-type=\"xref\" href=\"#fig-dm.dev-center\">Figure 1-10</a> shows the hotel schema being edited in DevCenter.</p>\n<figure id=\"fig-dm.dev-center\"><img class=\"width_80\" src=\"https://d3ansictanv2wj.cloudfront.net/ctdg_0510-096930df2faabf018936cbe0a647d976.png\" alt=\"image\" /><figcaption>Figure 1-10. Editing the Hotel schema in DataStax DevCenter</figcaption></figure><p>The middle pane shows the currently selected CQL file, featuring syntax highlighting for CQL commands, CQL types, and name literals. DevCenter provides command completion as you type out CQL commands and interprets the commands you type, highlighting any errors you make. The tool provides panes for managing multiple CQL scripts and connections to multiple clusters. The connections are used to run CQL commands against live clusters and view the results.  </p>\n</section></section><section data-type=\"sect1\" id=\"summary-ZKsaUD\"><h2>Summary</h2>\n<p>In this chapter, we saw how to create a complete, working Cassandra data model and compared it with an equivalent relational model. We represented our data model in both logical and physical forms and learned a new tool for realizing our data models in CQL. Now that we have a working data model, we'll continue building our hotel application in the coming chapters.</p>\n</section></section><div class=\"image-credit\">\n  Article image: \n          \n                  (source: <a class=\"secondary\" target=\"_blank\" href=\"https://unsplash.com/photos/hsg538WrP0Y\">By drmakete lab on Unsplash</a>).\n        \n        \n      \n    \n    \n</div>"}}]}},"pageContext":{"alternative_id":13130}}