{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cassandra Data Modeling Best Practices, Part 2","alternative_id":10867,"content":"<p>In the <a href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\">first part</a>, we covered a few fundamental practices and walked through a detailed example to help you get started with Cassandra data model design. You can follow Part 2 without reading Part 1, but I recommend glancing over the <a href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\">terms and conventions</a> I’m using. If you’re new to Cassandra, I urge you to read <a href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\">Part 1</a>.</p><p>September 2014 Update: Readers should note that this article describes data modeling techniques based on Cassandra’s Thrift API.  Please see <a href=\"https://wiki.apache.org/cassandra/DataModel\" target=\"_blank\" rel=\"noopener\">https://wiki.apache.org/cassandra/DataModel</a> for CQL API based techniques.</p><p>August 2015 Update:  Readers can also sign up a free online self-paced course on how to model their data in Apache Cassandra from <a href=\"https://academy.datastax.com/courses/ds220-data-modeling?dxt=blogposting\" target=\"_blank\" rel=\"noopener\">https://academy.datastax.com/courses/ds220-data-modeling?dxt=blogposting</a>.</p><p>Some of the practices listed below might evolve in the future. I’ve provided related JIRA ticket numbers so you can watch any evolution.</p><p>With that, let’s get started with some basic practices!</p><h3>Storing values in column names is perfectly OK</h3><p><em>Leaving column values empty (“valueless” columns) is also OK.</em></p><p>It’s a common practice with Cassandra to store a value (actual data) in the column name (a.k.a. column key), and even to leave the column value field empty if there is nothing else to store. One motivation for this practice is that column names are stored physically sorted, but column values are not.</p><p><strong>Notes:</strong></p><ul><li>The maximum column key (and row key) size is 64KB.  However, don’t store something like ‘item description’ as the column key!</li>\n<li>Don’t use timestamp alone as a column key. You might get colliding timestamps from two or more app servers writing to Cassandra. Prefer timeuuid (<a href=\"http://en.wikipedia.org/wiki/Universally_unique_identifier\" target=\"_blank\" rel=\"noopener\">type-1 uuid</a>) instead.</li>\n<li>The maximum column value size is 2 GB. But becuase there is no streaming and the whole value is fetched in heap memory when requested, limit the size to only a few MBs.  (Large objects are not likely to be supported in the near future – <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-265\" target=\"_blank\" rel=\"noopener\">Cassandra-265</a>. However, the <a href=\"https://github.com/Netflix/astyanax/wiki/Chunked-Object-Store\" target=\"_blank\" rel=\"noopener\">Astyanax</a> client library supports large objects by chunking them.)</li>\n</ul><h3>Leverage wide rows for ordering, grouping, and filtering</h3><p><em>But don’t go too wide.</em></p><p>This goes along with the above practice. When actual data is stored in column names, we end up with wide rows.</p><p><strong>Benefits of wide rows:</strong></p><ul><li>Since column names are stored physically sorted, wide rows enable ordering of data and hence efficient filtering (range scans). You’ll still be able to efficiently look up an individual column within a wide row, if needed.</li>\n<li>If data is queried together, you can group that data up in a single wide row that can be read back efficiently, as part of a single query. As an example, for tracking or monitoring some time series data, we can group data by hour/date/machines/event types (depending on the requirements)  in a single wide row, with each column containing granular data or roll-ups. We can also further group data within a row using super or composite columns as discussed later.</li>\n<li>Wide row column families are heavily used (with composite columns) to build custom indexes in Cassandra.</li>\n<li>As a side benefit, you can de-normalize a one-to-many relationship as a wide row without data duplication. However, I would do this only when data is queried together and you need to optimize read performance.</li>\n</ul><p><strong>Example:</strong></p><p>Let’s say we want to store some event log data and retrieve that data hourly. As shown in the model below, the row key is the hour of the day, the column name holds the time when the event occurred, and the column value contains payload. Note that the row is wide and the events are ordered by time because column names are stored sorted. Granularity of the wide row (for this example, per hour rather than every few minutes) depends on the use case, traffic, and data size, as discussed next.</p><p><a href=\"https://www.ebayinc.com/assets/Uploads/Blog/2012/08/widerow.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-2/assets/Uploads/Blog/2012/08/_resampled/ResizedImageWzM4OCwxMzFd/widerow.png\" alt=\"\" width=\"388\" height=\"131\" title=\"\" /></a></p><h3>But not too wide, as a row is never split across nodes:</h3><p>It’s hard to say exactly how wide a wide row should be, partly because it’s dependent upon the use case. But here’s some advice:</p><p><strong>Traffic</strong>: All of the traffic related to one row is handled by only one node/shard (by a single set of replicas, to be more precise). Rows that are too “fat” could cause hot spots in the cluster – usually when the number of rows is smaller than the size of the cluster (hope not!), or when wide rows are mixed with skinny ones, or some rows become hotter than others. However, cluster load balancing ultimately depends on the row key selection; conversely, the row key also defines how wide a row will be. So load balancing is something to keep in mind during design.</p><p><strong>Size</strong>: As a row is not split across nodes, data for a single row must fit on disk within a single node in the cluster. However, rows can be large enough that they don’t have to fit in memory entirely. Cassandra allows 2 billion columns per row. At eBay, we’ve not done any “wide row” benchmarking, but we model data such that we never hit more than a few million columns or a few megabytes in one row (we change the row key granularity, or we split into multiple rows). If you’re interested, <a href=\"http://thelastpickle.com/2011/07/04/Cassandra-Query-Plans/\" target=\"_blank\" rel=\"noopener\">Cassandra Query Plans</a> by Aaron Morton shows some performance concerns with wide rows (but note that the results can change in new releases).</p><p>However, these caveats don’t mean you should not use wide rows; just don’t go extra wide.</p><p><strong>Note:</strong> <a id=\"key-val\" href=\"https://issues.apache.org/jira/browse/CASSANDRA-4176\" target=\"_blank\" rel=\"noopener\">Cassandra-4176</a> might add composite types for row key in CQL as a way to split a wide row into multiple rows. However, a single (physical) row is never split <em>across nodes</em> (and won’t be split across nodes in the future), and is always handled by a single set of replicas. You might also want to track <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-3929\" target=\"_blank\" rel=\"noopener\">Cassandra-3929,</a> which would add row size limits for keeping the most recent <em>n</em> columns in a wide row.</p><h3><strong>Choose the proper row key – it’s your “shard key” </strong></h3><p><em>Otherwise, you’ll end up with hot spots, even with <a href=\"http://www.datastax.com/docs/0.8/cluster_architecture/partitioning#about-the-random-partitioner\" target=\"_blank\" rel=\"noopener\">RandomPartitioner</a>.</em></p><p>Let’s consider again the above example of storing time series event logs and retrieving them hourly. We picked the hour of the day as the row key to keep one hour of data together in a row. But there is an issue: All of the writes will go only to the node holding the row for the current hour, causing a hot spot in the cluster. Reducing granularity from hour to minutes won’t help much, because only one node will be responsible for handling writes for whatever duration you pick. As time moves, the hot spot might also move but it won’t go away!</p><p><strong>Bad row key:  </strong>“ddmmyyhh”</p><p>One way to alleviate this problem is to add something else to the row key – an event type, machine id, or similar value that’s appropriate to your use case.</p><p><strong>Better row key: </strong>“ddmmyyhh|eventtype”</p><p><a href=\"https://www.ebayinc.com/assets/Uploads/Blog/2012/08/shardkey.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-2/assets/Uploads/Blog/2012/08/_resampled/ResizedImageWzQ2NiwxMjhd/shardkey.png\" alt=\"\" width=\"466\" height=\"128\" title=\"\" /></a></p><p>Note that now we don’t have global time ordering of events, across all event types, in the column family. However, this may be OK if the data is viewed (grouped) by event type later. If the use case also demands retrieving all of the events (irrespective of type) in time sequence, we need to do a multi-get for all event types for a given time period, and honor the time order when merging the data in the application.</p><p>If you can’t add anything to the row key or if you absolutely need ‘time period’ as a row key, another option is to shard a row into multiple (physical) rows by manually splitting row keys: “ddmmyyhh | 1”, “ddmmyyhh | 2”,… “ddmmyyhh | n”, where <em>n</em> is the number of nodes in the cluster. For an hour window, each shard will now evenly handle the writes; you need to round-robin among them. But reading data for an hour will require multi-gets from all of the splits (from the multiple physical nodes) and merging them in the application. (An assumption here is that RandomPartitioner is used, and therefore that range scans on row keys can’t be done.)</p><h3><strong>Keep read-heavy data separate from write-heavy data<br /></strong></h3><p><em>This way, you can benefit from Cassandra’s off-heap row cache.</em></p><p>Irrespective of caching and even outside the NoSQL world, it’s always a good practice to keep read-heavy and write-heavy data separate because they scale differently.</p><p><strong>Notes:</strong></p><ul><li>A row cache is useful for skinny rows, but harmful for wide rows today because it pulls the entire row into memory. <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-1956\" target=\"_blank\" rel=\"noopener\">Cassandra-1956</a> and <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-2864\" target=\"_blank\" rel=\"noopener\">Cassandra-2864</a> might change this in future releases. However, the practice of keeping read-heavy data separate from write-heavy data will still stand.</li>\n<li>Even if you have lots of data (more than available memory) in a column family but you also have particularly “hot” rows, enabling a row cache might be useful.</li>\n</ul><h3>Make sure column key and row key are unique</h3><p><em>Otherwise, data could get accidentally overwritten.</em></p><ul><li>In Cassandra (a distributed database!), there is no unique constraint enforcement for row key or column key.</li>\n<li>Also, there is no separate update operation (no in-place updates!). It’s always an upsert (mutate) in Cassandra. If you accidentally insert data with an existing row key and column key, the previous column value will be silently overwritten without any error (the change won’t be versioned; the data will be gone).</li>\n</ul><h3>Use the proper comparator and validator</h3><p><em>Don’t just use the default BytesType comparator and validator unless you really need to.</em></p><p>In Cassandra, the data type for a column <em><strong>value </strong></em>(or row key)  is called a <em>Validator</em>. The data type for a column <em><strong>name</strong></em> is called a <em>Comparator</em>.  Although Cassandra does not require you to define both, you must at least specify the comparator unless your column family is static (that is, you’re not storing actual data as part of the column name), or unless you really don’t care about the sort order.</p><ul><li>An improper comparator will sort column names inappropriately on the disk. It will be difficult (or impossible) to do range scans on column names later.</li>\n<li>Once defined, you can’t change a comparator without rewriting all data. However, the validator can be changed later.</li>\n</ul><p>See <a href=\"http://www.datastax.com/docs/1.0/ddl/column_family#about-data-types-comparators-and-validators\" target=\"_blank\" rel=\"noopener\">comparators and validators</a> in the Cassandra documentation for the supported data types.</p><h3>Keep the column name short</h3><p><em>Because it’s stored <em>repeatedly.</em><br /></em></p><p>This practice doesn’t apply if you use the column name to store actual data. Otherwise, keep the column name short, since it’s repeatedly stored with each column value. Memory and storage overhead can be significant when the size of the column value is not much larger than the size of the column name – or worse, when it’s smaller.</p><p>For example, favor ‘fname’ over ‘firstname’, and ‘lname’ over ‘lastname’.</p><p><strong>Note:</strong> <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-4175\" target=\"_blank\" rel=\"noopener\">Cassandra-4175</a> might make this practice obsolete in the future.</p><h3>Design the data model such that operations are idempotent</h3><p><em>Or, make sure that your use case can live with inaccuracies or that inaccuracies can be corrected eventually.</em></p><p>In an eventually consistent and fully distributed system like Cassandra, idempotent operations can help – a lot. Idempotent operations allow partial failures in the system, as the operations can be retried safely without changing the final state of the system. In addition, idempotency can sometimes alleviate the need for strong consistency and allow you to work with eventual consistency without causing data duplication or other anomalies. Let’s see how these principles apply in Cassandra. I’ll discuss partial failures only, and leave out alleviating the need for strong consistency until an upcoming post, as it is very much dependent on the use case.</p><p>Because of  Cassandra’s fully distributed (and multi-master) nature, write failure does not guarantee that data is not written, unlike the behavior of relational databases. In other words, even if the client receives a failure for a write operation, data might be written to one of the replicas, which will eventually get propagated to all replicas. No rollback or cleanup is performed on partially written data. Thus, a perceived write failure can result in a successful write eventually. So, retries on write failure can yield unexpected results if your model isn’t update idempotent.</p><p><strong>Notes: </strong></p><ul><li>“Update idempotent” here means a model where operations are idempotent. An operation is called idempotent if it can be applied one time or multiple times with the same result.</li>\n<li>In most cases, idempotency won’t be a concern, as writes into regular column families are always update idempotent. The exception is with the Counter column family, as shown in the example below. However, sometimes your use case can model data such that write operations are not update idempotent from the use case perspective. For instance, in <a href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\">part 1</a>, User_by_Item and Item_by_User in the final model are not update idempotent if the use case operation ‘user likes item’ gets executed multiple times, as the timestamp might differ for each like. However, note that a specific instance of  the use case operation ‘user likes item’ is still idempotent, and so can be retried multiple times in case of failures. As this is more use-case specific, I might elaborate more in future posts.</li>\n<li>Even with a consistency level ONE, write failure does not guarantee data is not written; the data still could get propagated to all replicas eventually.</li>\n</ul><p><strong>Example</strong></p><p>Suppose that we want to count the number of users who like a particular item. One way is to use the <a href=\"http://www.datastax.com/dev/blog/whats-new-in-cassandra-0-8-part-2-counters\" target=\"_blank\" rel=\"noopener\">Counter</a> column family supported by Cassandra to keep count of users per item. Since the counter increment (or decrement) is not update idempotent, retry on failure could yield an over-count if the previous increment was successful on at least one node. One way to make the model update idempotent is to maintain a list of user ids instead of incrementing a count, as shown below. Whenever a user likes an item, we write that user’s id against the item; if the write fails, we can safely retry. To determine the count of all users who like an item, we read all user ids for the item and count manually.</p><p><a href=\"https://www.ebayinc.com/assets/Uploads/Blog/2012/08/idempotency2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-2/assets/Uploads/Blog/2012/08/_resampled/ResizedImageWzU4MiwxNTld/idempotency2.png\" alt=\"\" width=\"582\" height=\"159\" title=\"\" /></a></p><p>In the above update idempotent model, getting the counter value requires reading all user ids, which will not perform well (there could be millions). If reads are heavy on the counter and you can live with an approximate count, the counter column will be efficient for this use case. If needed, the counter value can be corrected periodically by counting the user ids from the update idempotent column family.</p><p><strong>Note:</strong> <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-2495\" target=\"_blank\" rel=\"noopener\">Cassandra-2495</a> might add a proper retry mechanism for counters in the case of a failed request. However, in general, this practice will continue to hold true. So make sure to always litmus-test your model for update idempotency.</p><h3><strong>Model data around transactions, if needed</strong></h3><p><em>But this might not always be possible, depending on the use case.</em></p><p>Cassandra has no multi-row, cluster-wide transaction or rollback mechanism; instead, it offers row-level atomicity. In other words, a single mutation operation of columns for a given row key is atomic. So if you need transactional behavior, try to model your data such that you would only ever need to update a single row at once. However, depending on the use case, this is not always doable. Also, if your system needs ACID transactions, you might re-think your database choice.</p><p><strong>Note:</strong> <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-4285\" target=\"_blank\" rel=\"noopener\">Cassandra-4285</a> might add an atomic, eventually consistent batch operation.</p><h3>Decide on the proper TTL up front, if you can<br /></h3><p><em>Because it’s hard to change TTL for existing data.</em></p><p>In Cassandra, TTL (time to live) is not defined or set at the column family level. It’s set per column value, and once set it’s hard to change; or, if not set, it’s hard to set for existing data. The only way to change the TTL for existing data is to read and re-insert all the data with a new TTL value. So think about your purging requirements, and if possible set the proper TTL for your data upfront.</p><p><strong>Note:</strong> <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-3974\" target=\"_blank\" rel=\"noopener\">Cassandra-3974</a> might introduce TTL for the column family, separate from column TTL.</p><h3>Don’t use the Counter column family to generate surrogate keys<br /></h3><p><em>Because it’s not intended for this purpose.<br /></em></p><p>The Counter column family holds distributed counters meant (of course) for distributed counting. Don’t try to use this CF to generate sequence numbers for surrogate keys, like Oracle sequences or MySQL auto-increment columns. You will receive duplicate sequence numbers! Most of the time you really don’t need globally sequential numbers. Prefer timeuuid (<a href=\"http://en.wikipedia.org/wiki/Universally_unique_identifier\" target=\"_blank\" rel=\"noopener\">type-1 uuid</a>) as surrogate keys. If you truly need a globally sequential number generator, there are a few possible mechanisms; but all will require centralized coordination, and thus can impact the overall system’s scalability and availability.</p><h3>Favor composite columns over super columns</h3><p><em>Otherwise, you might hit performance bottlenecks with super columns.</em></p><p>A super column in Cassandra can be used to group column keys, or to model a two-layer hierarchy. However, super columns have the following implementation issues and are therefore becoming less favorable.</p><p><strong>Issues:</strong></p><ul><li>Sub-columns of a super column are not indexed. Reading one sub-column de-serializes all sub-columns.</li>\n<li>Built-in secondary indexing does not work with sub-columns.</li>\n<li>Super columns cannot encode more than two layers of hierarchy.</li>\n</ul><p>Similar (even better) functionality can be achieved by the use of the Composite column. It’s a regular column with sub-columns encoded in it. Hence, all of the benefits of regular columns, such as sorting and range scans, are available; and you can encode more than two layers of hierarchy.</p><p><strong>Note:</strong> <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-3237\" target=\"_blank\" rel=\"noopener\">Cassandra-3237</a> might change the underlying super column implementation to use composite columns. However, composite columns will still remain preferred over super columns.</p><h3>The order of sub-columns in composite columns matters</h3><p><em>Because order defines grouping.</em></p><p>For example, a composite column key like &lt;state|city&gt; will be stored ordered first by state and then by city, rather than first by city and then by state. In other words, all the cities within a state are located (grouped) on disk together.</p><h3>Favor built-in composite types over manual construction</h3><p><em>Because manual construction doesn’t always work.</em></p><p>Avoid manually constructing the composite column keys using string concatenation (with separators like “:” or “|”). Instead, use the built-in composite types (and comparators) supported by Cassandra 0.8.1 and above.</p><p><strong>Why?</strong></p><ul><li>Manual construction won’t work if sub-columns are of different data types. For example, the composite key &lt;state|zip|timeuuid&gt; will not be sorted in a type-aware fashion (state as string, zip code as integer, and timeuuid as time).</li>\n<li>You can’t reverse the sort order on components in the type – for instance, with the state ascending and the zip code descending in the above key.</li>\n</ul><p><strong>Note:</strong> Cassandra built-in composite types come in two flavors:</p><ul><li><em>Static composite type: </em>Data types for each part of a composite column are predefined per column family.  All the column names/keys within a column family must be of that composite type.</li>\n<li><em>Dynamic composite type: </em>This type allows mixing column names with different composite types in a column family or even in one row.</li>\n</ul><p>Find more information about composite types at <a href=\"http://www.datastax.com/dev/blog/introduction-to-composite-columns-part-1\" target=\"_blank\" rel=\"noopener\">Introduction to composite columns</a>.</p><h3>Favor static composite types over dynamic, whenever possible</h3><p><em>Because dynamic composites are too dynamic.</em></p><p>If all column keys in a column family are of the same composite type, always use static composite types. Dynamic composite types were originally created to keep multiple custom indexes in one column family. If possible, don’t mix different composite types in one row using the dynamic composite type unless absolutely required. <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-3625\" target=\"_blank\" rel=\"noopener\">Cassandra-3625</a> has fixed some serious issues with dynamic composites.</p><p><strong>Note:</strong> CQL 3 supports static composite types for column names via clustered (wide) rows. Find more information about how CQL 3 handles wide rows at <a href=\"http://www.datastax.com/docs/1.1/ddl/column_family#composite-columns\" target=\"_blank\" rel=\"noopener\">DataStax docs</a>.</p><p>Enough for now. I would appreciate your inputs to further enhance these modeling best practices, which guide our Cassandra utilization today.</p><p>—  <a title=\"About me\" href=\"http://www.jaykumarpatel.com\" rel=\"noopener\" target=\"_blank\">Jay Patel</a>, architect@eBay.</p>"}}]}},"pageContext":{"alternative_id":10867}}