{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Apache Cassandra vs. Apache Ignite -- the winner is: Ignite!","alternative_id":12002,"content":"<p>In the <a href=\"https://www.gridgain.com/resources/blog/apache-cassandra-or-apache-ignite-thoughts-simplified-architecture\" target=\"_blank\">previous article</a>, we reviewed and summarized pitfalls of the query-driven data modeling methodology (a.k.a. denormalized data modeling) utilized in Apache Cassandra. Turns out that the methodology prevents us from developing efficient applications without insight into what our <strong>queries</strong> will be like. In reality, an application architecture under this scenario will get more complicated, less maintainable and prone to notable data duplication.</p><p>Furthermore, it was discovered that the pitfalls are usually shielded with statements like <em>\"if you really want to be scalable, fast and highly-available then be ready to store duplicated data and sacrifice SQL along with strong consistency.\"</em> That might have been true a decade ago but it's a total fable nowadays!</p><p>Not going too far, we picked another Apache Software Foundation citizen -- <a href=\"https://ignite.apache.org\">Apache Ignite</a> -- and in this article will figure out how our Ignite based application's architecture would look like and what would be its maintenance costs.</p><p>The application of our choice tracks all the cars produced by a vendor and gives insights on production power for every single vendor. If you recall, it has the following relational model:</p><img alt=\"Cars and Vendors\" data-entity-type=\"file\" data-entity-uuid=\"06c8fa2e-626c-4b3b-a63a-9c359a453754\" src=\"https://www.gridgain.com/sites/default/files/inline-images/cars_vendors.png\" class=\"align-center\" /><p>Can we just go ahead and create those 3 tables in Ignite with the <a href=\"https://apacheignite-sql.readme.io/docs/create-table\" target=\"_blank\">CREATE TABLE</a> command and run our SQL-driven application immediately? Depends... If we were not supposed to join the data stored in different tables then it would be enough. But in the previous article, we put a requirement that the application has to support 2 queries that require JOINs:</p><ul><li><strong>Q1: get car models produced by a vendor within a particular time frame (newest first).</strong></li>\n<li><strong>Q2: get a number of cars of a specific model produced by a vendor.</strong></li>\n</ul><p>In the Cassandra case, we got away with JOINs by creating 2 tables for each of the queries. Do we go through the same experience with Ignite? Totally not. In fact, Ignite's <a href=\"https://apacheignite-sql.readme.io/docs/distributed-joins#non-collocated-joins\" target=\"_blank\">non-collocated JOINs</a> are already at our service and doesn't require anything else from us once the 3 tables are created. However, they are not as efficient and fast as their <a href=\"https://apacheignite-sql.readme.io/docs/distributed-joins#section-collocated-joins\" target=\"_blank\">collocated</a> counter-part. Therefore, let's learn more about <a href=\"https://apacheignite.readme.io/docs/affinity-collocation\" target=\"_blank\">affinity collocation</a> first and see how this concept is used in modern databases such as Apache Ignite.</p><p>Affinity collocation is a powerful concept of Ignite (and other distributed databases such as Google Spanner or MemSQL) that allows storing <strong>related</strong> data on the same cluster nodes. How do we know which data is related? It's simple, especially with the background of relational databases --  just identify a parent-child relationship between your business objects, specify <a href=\"https://apacheignite-sql.readme.io/docs/create-table\" target=\"_blank\">affinity keys in CREATE TABLE statements</a> and your job is done because Ignite will take care of the rest!</p><p>Taking the Cars and Vendors application as an example, it's reasonable to use Vendor as a parent entity and Car with Production as its children. For instance, once this happens and the affinity keys are set, all the Cars produced by specific Vendor will be stored on the same node like it's shown in the picture below:</p><img alt=\"Affinity Collocation\" data-entity-type=\"file\" data-entity-uuid=\"1a2bfb95-f25e-4282-bdf5-44e6ea6c9d84\" src=\"https://www.gridgain.com/sites/default/files/inline-images/affinity_collocation.png\" class=\"align-center\" /><p>Specifically, the picture shows that all the Cars produced by Toyota are stored on Ignite node 1 while the Cars produced by Ford Motors are stored on Ignite node 2. This is the affinity collocation in action -- Cars are stored on a node where an entry of a respective Vendor is.</p><p>It's time to define SQL tables to achieve such data distribution. Let's start with Vendor table:</p><pre class=\"language-java\">\nCREATE TABLE Vendor (\n    id INT PRIMARY KEY,\n    name VARCHAR,\n    address VARCHAR\n);\n</pre><p>The Vendors will be distributed randomly across the cluster nodes. Ignite uses the primary key column to calculate a node that will own a Vendor's entry (refer to the recording of <a href=\"https://www.gridgain.com/resources/webinars/in-memory-computing-essentials-architects-and-developers-part-1\" target=\"_blank\">Ignite essentials Part 1</a> webinar for more details).</p><p>The Car table goes next:</p><pre class=\"language-java\">\nCREATE TABLE Car (\n    id INT,\n    vendor_id INT,\n    model VARCHAR,\n    year INT,\n    price float,\n    PRIMARY KEY(id, vendor_id)\n) WITH \"affinityKey=vendor_id\";\n</pre><p>The table for Cars has <code class=\"language-java\">affinityKey</code> parameter set to <code class=\"language-java\">vendor_id</code> column. This key instructs Ignite to store a Car on the cluster node of its <code class=\"language-java\">vendor_id</code> (refer to the recording of <a href=\"https://www.gridgain.com/resources/webinars/in-memory-computing-essentials-architects-and-developers-part-2\" target=\"_blank\">Ignite essentials Part 2</a> webinar for more info).</p><p>Repeating the same procedure for Production table which entries will be stored on the cluster nodes identified by <code class=\"language-java\">vendor_id</code> as well:</p><pre class=\"language-java\">\nCREATE TABLE Production (\n    id INT,\n    car_id INT,\n    vendor_id INT,\n    country VARCHAR,\n    total INT,\n    year INT,\n    PRIMARY KEY(id, car_id, vendor_id)\n) WITH \"affinityKey=vendor_id\";\n</pre><p>That's it with the data modeling done right in Apache Ignite. The next step is to get down to our application code and make out all the required queries.</p><p>Ignite cluster can be queried with our old-good-friend SQL that supports distributed JOINs and secondary indexes. </p><p>There are two types of JOINs in Ignite -- <a href=\"https://apacheignite-sql.readme.io/docs/distributed-joins#section-collocated-joins\" target=\"_blank\">collocated</a> and <a href=\"https://apacheignite-sql.readme.io/docs/distributed-joins#section-non-collocated-joins\" target=\"_blank\">non-collocated</a>. The collocated JOINs omit data (that is needed to complete a JOIN) movement between cluster nodes expecting that the tables, that are being joined, are already collocated and all the data is available locally. That's the most efficient and performant JOINs you can get in distributed databases such as Ignite. The non-collocated JOINs as the name suggests is our a backup plan if there was no way to achieve affinity collocation for some tables but they still need to be joined. This type of JOINs is slower because they might involve data movement between cluster nodes at a JOIN time.</p><p>Previously we could collocate Vendor, Car and Production tables and now can benefit from the collocated JOINs preparing an SQL query for <strong>Q1 </strong>(<em>get car models produced by a vendor within a particular time frame (newest first</em>)):</p><pre class=\"language-java\">\nSELECT c.model, p.country, p.total, p.year FROM Vendor as v\nJOIN Production as p ON v.id = p.vendor_id\nJOIN Car as c ON c.id = p.car_id\nWHERE v.name = 'Ford Motor' and p.year &gt;= 2017\nORDER BY p.year;\n</pre><p>Is there any way to make it even faster? Sure, let's define secondary indexes for <code class=\"language-java\">Vendor.name</code> and <code class=\"language-java\">Production.year</code> columns:</p><pre class=\"language-java\">\nCREATE INDEX vendor_name_id ON Vendor (name);\nCREATE INDEX prod_year_id ON Production (year);\n</pre><p>The SQL query for required <strong>Q2</strong> (<em>get a number of cars of a specific model produced by a vendor</em>) does not require extra efforts from us:</p><pre class=\"language-java\">\nSELECT p.country, p.total, p.year FROM Vendor as v\nJOIN Production as p ON v.id = p.vendor_id\nJOIN Car as c ON c.id = p.car_id\nWHERE v.name = 'Ford Motor' and c.model = 'Explorer';\n</pre><p>Now, whenever a boss stops by our cubicle requesting to add a new feature we can quickly come up with a set of new SQL queries needed for it, configure secondary indexes and go to the kitchen to chat with teammates. Job done! In comparison, recall what it took us to support new query <strong>Q2 </strong> for the <a href=\"https://www.gridgain.com/resources/blog/apache-cassandra-or-apache-ignite-thoughts-simplified-architecture\" target=\"_blank\">Cassandra based architecture</a>.</p><p>Affinity collocation based on data modeling in Ignite has the following advantages over the query-driven denormalized modeling in Cassandra:</p><ul><li>Applications data layer is modeled in a familiar relational way and easy to maintain.</li>\n<li>Data is accessed using standard SQL syntax.</li>\n<li>Affinity collocation provides more benefits from modern distributed databases:\n<ul><li>Efficient and highly performant distributed JOINs</li>\n<li><a href=\"https://ignite.apache.org/collocatedprocessing.html\" target=\"_blank\">Collocated computations</a></li>\n<li>Watch a recording of this <a href=\"https://www.gridgain.com/resources/webinars/scale-out-and-conquer-architectural-decisions-behind-distributed-in-memory\" target=\"_blank\">webinar</a> to reveal more benefits of this technique.</li>\n</ul></li>\n</ul><p>The simplified software architecture we get with Ignite is not the only benefit if we consider it instead of Cassandra. Give me a couple of weeks to put together my thoughts on strong consistency and in-memory performance.</p>"}}]}},"pageContext":{"alternative_id":12002}}