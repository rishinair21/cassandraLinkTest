{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cassandra Schemas for Beginners (like me)","alternative_id":11981,"content":"<div class=\"section-divider\"><hr class=\"section-divider\" /></div><div class=\"section-content\"><div class=\"section-inner sectionLayout--insetColumn\"><figure id=\"b12d\" class=\"graf graf--figure graf--leading\"><div class=\"aspectRatioPlaceholder is-locked\"><div class=\"aspectRatioPlaceholder-fill\"><img class=\"graf-image\" data-image-id=\"1*vGcN8EHmsZZlPafVq6Qkew.jpeg\" data-width=\"700\" data-height=\"390\" src=\"https://cdn-images-1.medium.com/max/1600/1*vGcN8EHmsZZlPafVq6Qkew.jpeg\" alt=\"image\" /></div><figcaption class=\"imageCaption\">Image from <a href=\"https://www.jisc.ac.uk/rd/projects/digging-into-data-challenge\" data-href=\"https://www.jisc.ac.uk/rd/projects/digging-into-data-challenge\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://www.jisc.ac.uk/rd/projects/digging-into-data-challenge</a></figcaption></div></figure><h1 id=\"0eb2\" class=\"graf graf--h3 graf-after--figure graf--title\">Cassandra Schemas for Beginners (like me)</h1><h2 id=\"e327\" class=\"graf graf--h4 graf-after--h3 graf--subtitle\">I was awe-struck when I first learned that Cassandra had tables. Then followed was another question along the line of how was it even a NoSQL database.</h2><p id=\"7ff4\" class=\"graf graf--p graf-after--h4\">Upon reading and playing around with it I began to realize that the rows and columns were just what’s on the surface. Cassandra is as NoSQL as any other databases.</p><p id=\"a05d\" class=\"graf graf--p graf-after--p\">I’ve been working on a project that utilizes greatly on using Cassandra as a JSON storage, and that required a great understanding than working with document-based solutions like MongoDB or CouchDB, which already provide ways to store JSON out of the box. The first idea was storing a JSON blob as a string value in a single column, but that was a pretty bad idea to start with and contradicts greatly to the very reason of using Cassandra, since it would require my application to parse that JSON string every time.</p><blockquote id=\"6caa\" class=\"graf graf--blockquote graf-after--p\"><div>Storing JSON in a Cassandra column as a text or []byte contradicts greatly to the very reason of using Cassandra.</div></blockquote><p id=\"e18b\" class=\"graf graf--p graf-after--blockquote\">Cassandra is more similar to key-value-based NoSQL databases like Redis or a hashtable. For someone coming from relational SQL world, the comfort will end at the CQL syntax and setting primary keys. Coming from NoSQL like MongoDB, however, one will have to get over the query language and schemas but once they pass the NoSQL mental model can be adapted to Cassandra very quickly.</p><p id=\"9e91\" class=\"graf graf--p graf-after--p\">This is my best attempt at relating Cassandra schema design to a more traditional key-value data format like JSON to better educate myself with the hope of somebody else getting something out of it too.</p><h4 id=\"4ccf\" class=\"graf graf--h4 graf-after--p\">NoSQL != Schemaless</h4><p id=\"0a72\" class=\"graf graf--p graf-after--h4\">NoSQL stands for <em class=\"markup--em markup--p-em\">Not Only SQL</em>. It does not mean no schemas. For many, using document- and key-value-based NoSQL databases can lead to this misconception. Even key-value data pairs like JSON has schema or structure. It’s just more flexible to changes than a relational table-based schema.</p><h4 id=\"59a3\" class=\"graf graf--h4 graf-after--p\">The Only Difference</h4><p id=\"8dc4\" class=\"graf graf--p graf-after--h4\">The only real distinction most, if not all, NoSQL databases have from SQL or relational databases is <strong class=\"markup--strong markup--p-strong\">the lack of relationship</strong> between two distinct data collections, tables, documents or whatever each database uses as the term to define a a set of related data. You kind of just query a table or a document, get the appropriate data, and then query another table to perform a cross-table query or namely the JOIN operation in the SQL world (This will lead to the argument number 2 below).</p><blockquote id=\"4f3c\" class=\"graf graf--blockquote graf-after--p\"><div>The only distinction NoSQL databases have from a relational SQL-based databases is the lack of inter-collection relationships.</div></blockquote><p id=\"3a88\" class=\"graf graf--p graf-after--blockquote\">The long-standing argument between the SQL and NoSQL camps sums up to:</p><ol class=\"postList\"><li id=\"9f60\" class=\"graf graf--li graf-after--p\">the fact that a relational database can never scale as easily as NoSQL.</li><li id=\"c3d5\" class=\"graf graf--li graf-after--li\">Relational databases provide more flexible and robust queries while for NoSQL, without knowing the structure or schema, one is forced to think hard about how an application will access the data. This is known as <strong class=\"markup--strong markup--li-strong\">query-driven design</strong>.</li></ol><p id=\"4886\" class=\"graf graf--p graf-after--li\">I will not talk about the topic of scalability since most NoSQL users should be well-aware of that, and it’s best discussed somewhere else. However, I will focus on the underlying structure of Cassandra for the hope of a better understanding that will lead to a better query-driven designed schemas.</p><h4 id=\"c639\" class=\"graf graf--h4 graf-after--p\">Cassandra as a Key-value Database</h4><p id=\"f453\" class=\"graf graf--p graf-after--h4\">Cassandra can be thought of as a key-value database. Under the hood and beyond its Cassandra Query Language (CQL) and schemas, it actually contains a lookup key for every data in the form of a <strong class=\"markup--strong markup--p-strong\">primary key</strong>.</p><p id=\"7a52\" class=\"graf graf--p graf-after--p\">Considering this <em class=\"markup--em markup--p-em\">user_tweets</em> table:</p></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"a94f\" class=\"graf graf--figure graf--startsWithDoubleQuote graf--layoutOutsetCenter graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><div class=\"aspectRatioPlaceholder-fill\"><img class=\"graf-image\" data-image-id=\"1*FQxcoFtHTLP469zlxtSIMA.png\" data-width=\"1230\" data-height=\"360\" data-action=\"zoom\" data-action-value=\"1*FQxcoFtHTLP469zlxtSIMA.png\" src=\"https://cdn-images-1.medium.com/max/2000/1*FQxcoFtHTLP469zlxtSIMA.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\">“user_tweets” table</figcaption></div></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"a6a3\" class=\"graf graf--p graf-after--figure\">The <em class=\"markup--em markup--p-em\">username</em> field acts as a first and only primary key, which in Cassandra’s speak is called the <strong class=\"markup--strong markup--p-strong\">partition key</strong>. A partition key is very important in Cassandra and it basically groups all the related rows together for efficient storage and lookup. This will become clearer once we have more than one tweet per username. The partition key hence can be seen as the “lookup” key similar to what you might have dealt with in any hash table, map, dictionary or other key-value structure.</p></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"2d54\" class=\"graf graf--figure graf--layoutOutsetCenter graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><div class=\"aspectRatioPlaceholder-fill\"><img class=\"graf-image\" data-image-id=\"1*9G4Vw6BaaeM77G2JXENtbQ.png\" data-width=\"1453\" data-height=\"670\" data-action=\"zoom\" data-action-value=\"1*9G4Vw6BaaeM77G2JXENtbQ.png\" src=\"https://cdn-images-1.medium.com/max/2000/1*9G4Vw6BaaeM77G2JXENtbQ.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\">key-value relationship of the “user_tweet” table</figcaption></div></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"4744\" class=\"graf graf--p graf-after--figure\">We can simplify it to a JSON structure (not entirely accurate, but useful as a mental model for someone coming from Redis or MongoDB).</p><figure id=\"c29e\" class=\"graf graf--figure graf--iframe graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><div class=\"aspectRatioPlaceholder-fill\"><div class=\"iframeContainer\"><iframe width=\"700\" height=\"250\" src=\"https://medium.com/media/8e16adb780c4d577634bc7b5966722cd?postId=9714cee9236a\" data-media-id=\"8e16adb780c4d577634bc7b5966722cd\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\">[embedded content]</iframe></div></div></div></figure><p id=\"cd31\" class=\"graf graf--p graf-after--figure\">One thing that should be noted very cautiously is that in Cassandra, unlike what the JSON array might portray, each partition of grouped rows under a partition key is stored non-contiguously, possibly on different nodes, making it very costly to access each of them together. In the previous table, if you look at the key-value relationship diagram, you’ll see that each row is not related to one another at all and is stored apart from one another.</p><p id=\"cbc8\" class=\"graf graf--p graf-after--p\">This can never be overstated. We can never access the second-level data (for instance, the email of a user) without accessing the primary username key first. Think of it as a JSON array as portrayed previously. To get to my <em class=\"markup--em markup--p-em\">email</em>, the <em class=\"markup--em markup--p-em\">username</em> must be provided as the key beforehand.</p><pre id=\"3e21\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">var</strong> tweets = JSON.parse(tweet_data)<br /><strong class=\"markup--strong markup--pre-strong\">var</strong> my_email = tweets[0]['jochasinga']['email'];</pre><p id=\"7828\" class=\"graf graf--p graf-after--pre\">The CQL rough equivalence of the above would have been</p><pre id=\"2305\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">SELECT</strong> \"email\" <strong class=\"markup--strong markup--pre-strong\">FROM</strong> \"user_tweets\" <strong class=\"markup--strong markup--pre-strong\">WHERE</strong> \"username\" = 'jochasinga';</pre><p id=\"ab4e\" class=\"graf graf--p graf-after--pre\">We supply the primary key, or the “lookup” key to the WHERE clause, hence it’s very cheap to retrieve the <em class=\"markup--em markup--p-em\">email </em>value<em class=\"markup--em markup--p-em\"> </em>of that <em class=\"markup--em markup--p-em\">username</em>.</p><p id=\"7a56\" class=\"graf graf--p graf-after--p\">If we try to query a row by supplying another non-key column to the WHERE clause, we would be getting an error warning us that it’d be very unwise to do so.</p><pre id=\"0941\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">SELECT</strong> * <strong class=\"markup--strong markup--pre-strong\">FROM</strong> \"user_tweets\" <strong class=\"markup--strong markup--pre-strong\">WHERE</strong> \"email\" = 'jo.chasinga@gmail.com';</pre><p id=\"52ce\" class=\"graf graf--p graf-after--pre\">The above CQL query, reads “select all columns from <em class=\"markup--em markup--p-em\">user_tweets</em> table where the <em class=\"markup--em markup--p-em\">email</em> is ‘jo.chasinga@gmail.com’.”, would return an erratic warning:</p><pre id=\"a834\" class=\"graf graf--pre graf-after--p\">InvalidRequest: code=2200 [Invalid query] message=”Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING</pre><p id=\"56af\" class=\"graf graf--p graf-after--pre\">It makes sense if you think about it. In a table with many more rows, querying by a non-key column like <em class=\"markup--em markup--p-em\">email </em>tells Cassandra to iterate through every primary key<em class=\"markup--em markup--p-em\"> username </em>before hitting the right <em class=\"markup--em markup--p-em\">email</em> value and retrieving the row. Here’s the rough approximation of the query in Javascript querying the previous JSON:</p><pre id=\"3a30\" class=\"graf graf--pre graf-after--p\">tweets.<strong class=\"markup--strong markup--pre-strong\">forEach</strong>(function(elm, i, arr) {</pre><pre id=\"88d4\" class=\"graf graf--pre graf-after--pre\">    // Retrieve an array of all the keys<br /><strong class=\"markup--strong markup--pre-strong\">var</strong> keys = Object.keys[elm]<br /><strong class=\"markup--strong markup--pre-strong\">if </strong>elm[keys[0]]['email'] == \"jo.chasinga@gmail.com\" {<br /><strong class=\"markup--strong markup--pre-strong\">return</strong> elm<br />    }<br />}</pre><p id=\"ed01\" class=\"graf graf--p graf-after--pre\">If you have a million rows of tweets, or in the JSON version, a million objects, you would end up traversing through every one blindly hopefully hitting your luck early. Also remember that each partition is possibly stored on a separate node from one another. You are of course given an option to execute this query anyway by using <em class=\"markup--em markup--p-em\">ALLOW FILTERING</em> flag, but you’ve been warned.</p><p id=\"48e2\" class=\"graf graf--p graf-after--p\">Things start to become clearer when we introduce another <em class=\"markup--em markup--p-em\">tweet_id</em> column as a <strong class=\"markup--strong markup--p-strong\">clustering column</strong> for the tweet table. Let’s say I retweeted to @banksy tweet, making two tweets for me.</p></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"f767\" class=\"graf graf--figure graf--startsWithDoubleQuote graf--layoutOutsetCenter graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><div class=\"aspectRatioPlaceholder-fill\"><img class=\"graf-image\" data-image-id=\"1*c9g_AHIOkGM-DDKC5mlAag.png\" data-width=\"1650\" data-height=\"436\" data-action=\"zoom\" data-action-value=\"1*c9g_AHIOkGM-DDKC5mlAag.png\" src=\"https://cdn-images-1.medium.com/max/2000/1*c9g_AHIOkGM-DDKC5mlAag.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\">“user_tweets” table after I have retweeted to @banksy</figcaption></div></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"af72\" class=\"graf graf--p graf-after--figure\">The <em class=\"markup--em markup--p-em\">tweet_id</em> is a clustering column with <em class=\"markup--em markup--p-em\">time_uuid </em>type, ordering rows under <em class=\"markup--em markup--p-em\">jochasinga</em> partition key in an time-ascending order. The <em class=\"markup--em markup--p-em\">email</em> field is being declared as STATIC meaning it is consistent for all the tweets for a user and there’s no need of duplicates. The mental model will be similar to this:</p></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"969d\" class=\"graf graf--figure graf--layoutOutsetCenter graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><div class=\"aspectRatioPlaceholder-fill\"><img class=\"graf-image\" data-image-id=\"1*SNNH3D7s2HeT8wKOM9Dysw.png\" data-width=\"1875\" data-height=\"777\" data-action=\"zoom\" data-action-value=\"1*SNNH3D7s2HeT8wKOM9Dysw.png\" src=\"https://cdn-images-1.medium.com/max/2000/1*SNNH3D7s2HeT8wKOM9Dysw.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\">Key-value relationship of the “user_tweets” table</figcaption></div></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"d8f5\" class=\"graf graf--p graf-after--figure\">And the approximate JSON-style representation would be something like</p><figure id=\"077e\" class=\"graf graf--figure graf--iframe graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><div class=\"aspectRatioPlaceholder-fill\"><div class=\"iframeContainer\"><iframe width=\"700\" height=\"250\" src=\"https://medium.com/media/70d873a7f58cf6ae30bc092c467052d8?postId=9714cee9236a\" data-media-id=\"70d873a7f58cf6ae30bc092c467052d8\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\">[embedded content]</iframe></div></div></div></figure><p id=\"4f8a\" class=\"graf graf--p graf-after--figure\">Note that <em class=\"markup--em markup--p-em\">tweet_id</em> value is simplified to string instead of <em class=\"markup--em markup--p-em\">time_uuid</em> type for just for brevity, and there was no such field as <em class=\"markup--em markup--p-em\">row_data</em> in the table<em class=\"markup--em markup--p-em\">. </em>It’s just how JSON needs a “key” for every value, and that how <em class=\"markup--em markup--p-em\">tweet_id </em>column<em class=\"markup--em markup--p-em\"> </em>orders the row data within a username’s partition is similar to how an array store data. However, in Cassandra, the <em class=\"markup--em markup--p-em\">tweet_id </em>encapsulates the time information used in the ordering of each row. With this JSON representation, the index of the array has nothing to do with the <em class=\"markup--em markup--p-em\">tweet_id</em> value.</p><p id=\"6f65\" class=\"graf graf--p graf-after--p\">Now with ‘jochasinga’ having more than one tweet, to query a specific one, you either have to do the following:</p><ol class=\"postList\"><li id=\"9fa2\" class=\"graf graf--li graf-after--p\">Query directly using a partition key and a unique primary key, in this case, the <em class=\"markup--em markup--li-em\">tweet_id</em>.</li></ol><pre id=\"b15d\" class=\"graf graf--pre graf-after--li\"><strong class=\"markup--strong markup--pre-strong\">SELECT</strong> * <strong class=\"markup--strong markup--pre-strong\">FROM</strong> \"user_tweets\" <strong class=\"markup--strong markup--pre-strong\">WHERE </strong>\"username\" = 'jochasinga'<strong class=\"markup--strong markup--pre-strong\"> AND</strong> \"id\" = bd48ac00-8310-11e5-985d-dd516b67e698;</pre><p id=\"c9b8\" class=\"graf graf--p graf-after--pre\">2. Query using a partition key and another unique primary key column OR non-key column, like the tweet body.</p><pre id=\"876d\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">SELECT</strong> * <strong class=\"markup--strong markup--pre-strong\">FROM</strong> \"user_tweets\" <strong class=\"markup--strong markup--pre-strong\">WHERE</strong> \"username\" = 'jochasinga' <strong class=\"markup--strong markup--pre-strong\">AND </strong>\"tweet\" = '@banksy thanks I'll try to check it out!'</pre><p id=\"ff9d\" class=\"graf graf--p graf-after--pre\">And in return, this is the row we get</p></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"e367\" class=\"graf graf--figure graf--layoutOutsetCenter graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><div class=\"aspectRatioPlaceholder-fill\"><img class=\"graf-image\" data-image-id=\"1*eCVfUJGoCxnmh5OGWV_fZw.png\" data-width=\"1650\" data-height=\"211\" data-action=\"zoom\" data-action-value=\"1*eCVfUJGoCxnmh5OGWV_fZw.png\" src=\"https://cdn-images-1.medium.com/max/2000/1*eCVfUJGoCxnmh5OGWV_fZw.png\" alt=\"image\" /></div></div></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><h4 id=\"46fe\" class=\"graf graf--h4 graf-after--figure\">Secondary Indexes</h4><p id=\"9e35\" class=\"graf graf--p graf-after--h4\">Secondary indexes are sort of a “hack” to promote a non-key column (that is, a column that is not a primary key) to a secondary “key” that you can query against just like a primary key. This is just like a reverse lookup. For instance, querying with a <em class=\"markup--em markup--p-em\">username</em> you<em class=\"markup--em markup--p-em\"> </em>can get the <em class=\"markup--em markup--p-em\">email</em> of the user.</p><pre id=\"97f7\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">SELECT</strong> \"email\" <strong class=\"markup--strong markup--pre-strong\">FROM </strong>\"user_tweets\" <strong class=\"markup--strong markup--pre-strong\">WHERE </strong>\"username\" = 'jochasinga';</pre><p id=\"5ed5\" class=\"graf graf--p graf-after--pre\">In some case, we may want to query a username based on the email. By creating an index on <em class=\"markup--em markup--p-em\">email</em>, you can perform that kind of reverse lookup.</p><blockquote id=\"f931\" class=\"graf graf--blockquote graf-after--p\"><div>Note: Right now it is not possible to create an index on a static column, though in theory that can be done. See <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-8103\" data-href=\"https://issues.apache.org/jira/browse/CASSANDRA-8103\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"nofollow noopener\" target=\"_blank\">this thread</a> on how Apache is planning to include this feature in the next versions.</div></blockquote><p id=\"9a75\" class=\"graf graf--p graf-after--blockquote\">We will add another column of type <em class=\"markup--em markup--p-em\">list&lt;text&gt; </em>to store hashtags in a tweet. It makes sense considering how Twitter displays tweets with the corresponding hashtag in the search results. For instance, when a user search for all the tweets with hashtag <em class=\"markup--em markup--p-em\">#funnycats,</em> Twitter could have queried it this way:</p><pre id=\"46f9\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">SELECT </strong>* <strong class=\"markup--strong markup--pre-strong\">FROM</strong> \"user_tweets\" <strong class=\"markup--strong markup--pre-strong\">WHERE</strong> \"hashtags\" <strong class=\"markup--strong markup--pre-strong\">CONTAINS</strong> \"funnycats\";</pre><p id=\"0525\" class=\"graf graf--p graf-after--pre\">Pretty self-descriptive.</p><p id=\"cca3\" class=\"graf graf--p graf-after--p\">But without “marking” the <em class=\"markup--em markup--p-em\">hashtags</em> column, it would return a complaint just like how we tried querying with a non-key column value.</p><p id=\"48e4\" class=\"graf graf--p graf-after--p\">Let’s add the hashtags column and see how that goes.</p><pre id=\"76aa\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">ALTER</strong> <strong class=\"markup--strong markup--pre-strong\">TABLE</strong> \"user_tweets\" <strong class=\"markup--strong markup--pre-strong\">ADD</strong> \"hashtags\" list&lt;text&gt;;</pre><p id=\"c6e1\" class=\"graf graf--p graf-after--pre\">At this point, we will have to alter the data of the previous tweets’ <em class=\"markup--em markup--p-em\">hashtags</em> column, since the column we have just added contains nothing on each row.</p><pre id=\"0979\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">UPDATE</strong> \"user_tweets\" SET \"hashtags\" = ['art', 'graffiti', 'nyc'] <strong class=\"markup--strong markup--pre-strong\">WHERE</strong> \"username\" = 'jochasinga' <strong class=\"markup--strong markup--pre-strong\">AND</strong> \"id\" = bd48ac00-8310-11e5-985d-dd516b67e698;</pre><pre id=\"fe8f\" class=\"graf graf--pre graf-after--pre\"><strong class=\"markup--strong markup--pre-strong\">UPDATE</strong> \"user_tweets\" SET \"hashtags\" = ['rad'] <strong class=\"markup--strong markup--pre-strong\">WHERE</strong> \"username\" = 'banksy' <strong class=\"markup--strong markup--pre-strong\">AND</strong> \"id\" = 76e7a4d0-e796-11e3-90ce-5f98e903bf02;</pre><pre id=\"6c62\" class=\"graf graf--pre graf-after--pre\"><strong class=\"markup--strong markup--pre-strong\">UPDATE</strong> \"user_tweets\" SET \"hashtags\" = ['sad', 'HopeForUkraine'] <strong class=\"markup--strong markup--pre-strong\">WHERE</strong> \"username\" = 'random_may' <strong class=\"markup--strong markup--pre-strong\">AND</strong> \"id\" = fa507380-8310-11e5-985d-dd516b67e698;</pre><p id=\"e8d6\" class=\"graf graf--p graf-after--pre\">Then create a secondary index on the <em class=\"markup--em markup--p-em\">hashtags</em> column</p><pre id=\"6c02\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">CREATE INDEX ON</strong> \"user_tweets\" (\"hashtags\")</pre><p id=\"e590\" class=\"graf graf--p graf-after--pre\">We will turn up with a new version of user_tweets that looks like this:</p></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"87d1\" class=\"graf graf--figure graf--layoutOutsetCenter graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><div class=\"aspectRatioPlaceholder-fill\"><img class=\"graf-image\" data-image-id=\"1*Fmu-Q_iiGJgrvJky2q7ViA.png\" data-width=\"2070\" data-height=\"436\" data-action=\"zoom\" data-action-value=\"1*Fmu-Q_iiGJgrvJky2q7ViA.png\" src=\"https://cdn-images-1.medium.com/max/2000/1*Fmu-Q_iiGJgrvJky2q7ViA.png\" alt=\"image\" /></div></div></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"9e5a\" class=\"graf graf--p graf-after--figure\">Now we will be able to query against the hashtags like Twitter search would have done it.</p><pre id=\"7417\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">SELECT</strong> * <strong class=\"markup--strong markup--pre-strong\">FROM</strong> \"user_tweets\" <strong class=\"markup--strong markup--pre-strong\">WHERE</strong> \"hashtags\" <strong class=\"markup--strong markup--pre-strong\">CONTAINS </strong>'art';</pre><p id=\"2d1a\" class=\"graf graf--p graf-after--pre\">Guess which row will be returned. (my first tweet, of course!)</p><p id=\"6234\" class=\"graf graf--p graf-after--p\">I said secondary indexes are “hacks” because they don’t scale well and should be used sparingly especially on columns with high-cardinality, meaning data are mostly distinct. It is more suitable for columns with low-cardinality like, say, static columns (scroll above to see why it isn’t possible yet to create an index on static columns). <a href=\"https://pantheon.io/blog/cassandra-scale-problem-secondary-indexes\" data-href=\"https://pantheon.io/blog/cassandra-scale-problem-secondary-indexes\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">This article </a>is great at elaborating the problem that comes with Cassandra’s secondary indexes.</p><h4 id=\"3463\" class=\"graf graf--h4 graf-after--p\">Conclusion</h4><p id=\"d780\" class=\"graf graf--p graf-after--h4\">It is best to think of Cassandra as a structure of sorted key-value pairs of documents than cells of data, and this was proved to be very useful for my process of designing the schema around what I needed. Partition keys and clustering columns are almost the only two most important friends of yours.</p><p id=\"bbbc\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">DON’T RESTRICT YOURSELF WITH SCHEMAS.</strong></p><p id=\"aaa0\" class=\"graf graf--p graf-after--p\">Here is a few rules you can remember</p><ul class=\"postList\"><li id=\"961c\" class=\"graf graf--li graf-after--p\">To partition is to separate two things from each other. So if you create your table like this</li></ul><pre id=\"081c\" class=\"graf graf--pre graf-after--li\"><strong class=\"markup--strong markup--pre-strong\">CREATE TABLE</strong> \"my_users\" (<br />    id uuid,<br />    email text,<br />    password blob,<br />    country text,<br /><strong class=\"markup--strong markup--pre-strong\">PRIMARY KEY</strong> (country, id)<br />);</pre><p id=\"1823\" class=\"graf graf--p graf-after--pre\">You are making users from two different countries will be stored separately. Rows in a partition will be ordered according to the unique id.</p><pre id=\"ccc1\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">CREATE TABLE</strong> \"my_users\" (<br />    id uuid,<br />    email text,<br />    password blob,<br />    city text,<br />    country text,<br /><strong class=\"markup--strong markup--pre-strong\">PRIMARY KEY</strong> ((country, city), id)<br />);</pre><p id=\"f271\" class=\"graf graf--p graf-after--pre\">Users from the same country, but in different cities will be stored separately. Rows in a partition will be ordered by id.</p><ul class=\"postList\"><li id=\"9730\" class=\"graf graf--li graf-after--p\">Clustering column, or the second primary key, decide how you want the database to be ordered. (Either ascending or descending)</li><li id=\"3cce\" class=\"graf graf--li graf-after--li\">Secondary indexes avoid <strong class=\"markup--strong markup--li-strong\">denormalization</strong>, or the process of creating redundant data to create effective single-partition reads, but they are quite costly and should be used on medium-traffic queries.</li><li id=\"5e6b\" class=\"graf graf--li graf-after--li graf--trailing\">Add columns at will. Cassandra is flexible and rows without data do not take memories (there’s no NULL pointer value for missing value).</li></ul></div></div>"}}]}},"pageContext":{"alternative_id":11981}}