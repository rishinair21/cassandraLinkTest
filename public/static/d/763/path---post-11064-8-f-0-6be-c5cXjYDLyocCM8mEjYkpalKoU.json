{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Apache Cassandra - Dzone Refcardz","alternative_id":11064,"content":"<div class=\"col-md-12 content-html\"><p>Apache Cassandra is a high-performance, extremely scalable, fault tolerant (i.e., no single point of failure), distributed non-relational database solution. Cassandra combines all the benefits of Google Bigtable and Amazon Dynamo to handle the types of database management needs that traditional RDBMS vendors cannot support. DataStax is the leading worldwide commercial provider of Cassandra products, services, support, and training.</p></div><div class=\"col-md-12 content-html\"><p>Cassandra is in use at <a href=\"http://www.slideshare.net/adrianco/migrating-netflix-from-oracle-to-global-cassandra\">Netflix</a>, <a href=\"http://www.slideshare.net/kevinweil/rainbird-realtime-analytics-at-twitter-strata-2011\">Twitter</a>, <a href=\"http://www.slideshare.net/eonnen/from-100s-to-100s-of-millions/\">Urban Airship</a>, <a href=\"http://www.slideshare.net/daveconnors/cassandra-puppet-scaling-data-at-15-per-month\">Constant Contact</a>, <a href=\"http://blog.reddit.com/2010/03/she-who-entangles-men.html\">Reddit</a>, Cisco, OpenX, Rackspace, Ooyala, and <a href=\"http://www.datastax.com/cassandrausers\">more companies</a> that have large active data sets. The largest known Cassandra cluster has over 300 TB of data in over 400 machines.</p><p>(From: <a href=\"http://cassandra.apache.org/\">http://cassandra.apache.org/</a>)</p></div><div class=\"col-md-12 content-html\"><table border=\"1\" style=\"width: 697px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 117px;\"> </td>\n   <td class=\"right_th_colored\" style=\"width: 261px;\"><h3>Cassandra</h3></td>\n   <td class=\"right_th_colored\" style=\"width: 297px;\"><h3>RDBMS</h3></td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">Atomicity</td>\n   <td class=\"right_td_colored\">Success or failure on a row-by-row basis.</td>\n   <td class=\"right_td_colored\">Enforced at every scope, at the cost of performance and scalability.</td>\n  </tr><tr><td class=\"left_td_colored\">Sharding</td>\n   <td class=\"right_td_colored\">Native share-nothing architecture, inherently partitioned by a configurable strategy.</td>\n   <td class=\"right_td_colored\">Often forced when scaling, partitioned by key or function</td>\n  </tr><tr><td class=\"left_td_colored\">Consistency</td>\n   <td class=\"right_td_colored\">No consistency in the ACID sense. Can be tuned to provide consistency in the CAP sense--data is consistent across all the nodes in a distributed database cluster ,guaranteeing read-after-write or eventual readability.</td>\n   <td class=\"right_td_colored\">Favors consistency over availability tunable via isolation levels.</td>\n  </tr><tr><td class=\"left_td_colored\">Durability</td>\n   <td class=\"right_td_colored\">Writes are durable to a replica node, being recorded in memory and the commit log before acknowledged. In the event of a crash, the commit log replays on restart to recover any lost writes before data is flushed to disk.</td>\n   <td class=\"right_td_colored\">Typically, data is written to a single master node, sometimes configured with synchronous replication at the cost of performance and cumbersome data restoration.</td>\n  </tr><tr><td class=\"left_td_colored\">Multi-Datacenter Replication</td>\n   <td class=\"right_td_colored\">Native capabilities for data replication over lower bandwidth, higher latency, less reliable connections.</td>\n   <td class=\"right_td_colored\">Typically only limited long-distance replication to read-only slaves receiving asynchronous updates.</td>\n  </tr><tr><td class=\"left_td_colored\">Security</td>\n   <td class=\"right_td_colored\">Coarse-grained and primitive.</td>\n   <td class=\"right_td_colored\">Fine-grained access control to objects.</td>\n  </tr></tbody></table></div><div class=\"col-md-12 content-html\"><p>Cassandra has a simple schema comprising keyspaces, column families, rows, and columns.</p><table border=\"1\" style=\"width: 662px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 114px;\"> </td>\n   <td class=\"right_th_colored\" style=\"width: 122px;\">Definition</td>\n   <td class=\"right_th_colored\" style=\"width: 124px;\">RDBMS Analogy</td>\n   <td class=\"right_th_colored\" style=\"width: 274px;\">Object Equivalent</td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">Schema/ Keyspace</td>\n   <td class=\"right_td_colored\">A collection of column families. </td>\n   <td class=\"right_td_colored\">Schema/Database</td>\n   <td class=\"right_td_colored\">Set </td>\n  </tr><tr><td class=\"left_td_colored\">Table/ Column Family</td>\n   <td class=\"right_td_colored\">A set of rows.</td>\n   <td class=\"right_td_colored\">Table</td>\n   <td class=\"right_td_colored\">Map </td>\n  </tr><tr><td class=\"left_td_colored\">Row</td>\n   <td class=\"right_td_colored\">An ordered set of columns.</td>\n   <td class=\"right_td_colored\">Row</td>\n   <td class=\"right_td_colored\">OrderedMap </td>\n  </tr><tr><td class=\"left_td_colored\">Column</td>\n   <td class=\"right_td_colored\">A key/value pair and timestamp.</td>\n   <td class=\"right_td_colored\">Column (Name, Value)</td>\n   <td class=\"right_td_colored\">(key, value, timestamp)</td>\n  </tr></tbody></table></div><div class=\"col-md-12 content-html\"><p>Also known as a keyspace, the schema is akin to a database or schema in RDBMS and contains a set of tables. A schema is also the unit for Cassandra's access control mechanism. When enabled, users must authenticate to access and manipulate data in a schema or table.</p></div><div class=\"col-md-12 content-html\"><p>A table, also known as a column family, is a map of rows. A table defines the column names and data types. The client application provides rows that conform to the schema. Each row has the same fixed set of columns.</p><p>As Values for these properties, Cassandra provides the following CQL data types for columns.</p><table border=\"1\" style=\"width: 673px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 149px;\"><strong>Type</strong></td>\n   <td class=\"right_th_colored\" style=\"width: 260px;\"><strong>Purpose</strong></td>\n   <td class=\"right_th_colored\" style=\"width: 242px;\"><strong>Storage </strong></td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">ascii</td>\n   <td class=\"right_td_colored\">Efficient storage for simple ASCII strings.</td>\n   <td class=\"right_td_colored\">Arbitrary number of ASCII bytes (i.e., values are 0-127).</td>\n  </tr><tr><td class=\"left_td_colored\">boolean</td>\n   <td class=\"right_td_colored\">True or False.</td>\n   <td class=\"right_td_colored\">Single byte.</td>\n  </tr><tr><td class=\"left_td_colored\">blob</td>\n   <td class=\"right_td_colored\">Arbitrary byte content.</td>\n   <td class=\"right_td_colored\">Arbitrary number of byes.</td>\n  </tr><tr><td class=\"left_td_colored\">CompositeType</td>\n   <td class=\"right_td_colored\">A single type comprising sub-components each with their own types.</td>\n   <td class=\"right_td_colored\">An arbitrary number of bytes comprising concatenated values of the subtypes..</td>\n  </tr><tr><td class=\"left_td_colored\">counter</td>\n   <td class=\"right_td_colored\">Used for counters, which are cluster-wide incrementing values.</td>\n   <td class=\"right_td_colored\">8 bytes.</td>\n  </tr><tr><td class=\"left_td_colored\">timestamp</td>\n   <td class=\"right_td_colored\">Stores time in milliseconds.</td>\n   <td class=\"right_td_colored\">8 bytes.</td>\n  </tr><tr><td class=\"left_td_colored\">decimal</td>\n   <td class=\"right_td_colored\">Stores BigDecimals.</td>\n   <td class=\"right_td_colored\">4 bytes to store the scale, plus an arbitrary number of bytes to store the value.</td>\n  </tr><tr><td class=\"left_td_colored\">double</td>\n   <td class=\"right_td_colored\">Stores Doubles.</td>\n   <td class=\"right_td_colored\">8 bytes.</td>\n  </tr><tr><td class=\"left_td_colored\">float</td>\n   <td class=\"right_td_colored\">Stores Floats.</td>\n   <td class=\"right_td_colored\">4 bytes.</td>\n  </tr><tr><td class=\"left_td_colored\">int</td>\n   <td class=\"right_td_colored\">Stores 4-byte integer.</td>\n   <td class=\"right_td_colored\">4 bytes.</td>\n  </tr><tr><td class=\"left_td_colored\">varint</td>\n   <td class=\"right_td_colored\">Stores variable precision integer.</td>\n   <td class=\"right_td_colored\">An arbitraty number of bytes used to store the value.</td>\n  </tr><tr><td class=\"left_td_colored\">bigint</td>\n   <td class=\"right_td_colored\">Stores Longs.</td>\n   <td class=\"right_td_colored\">8 bytes.</td>\n  </tr><tr><td class=\"left_td_colored\">text, varchar</td>\n   <td class=\"right_td_colored\">Stores text as UTF8.</td>\n   <td class=\"right_td_colored\">UTF8.</td>\n  </tr><tr><td class=\"left_td_colored\">uuid</td>\n   <td class=\"right_td_colored\">Suitable for UUID storage.</td>\n   <td class=\"right_td_colored\">16 bytes.</td>\n  </tr></tbody></table></div><div class=\"col-md-12 content-html\"><p>Cassandra 1.1 supports tables defined with composite primary keys. The first column in a composite key definition is used as the partition key. Remaining columns are automatically clustered. Rows that share a partition key are sorted by the remaining components of the primary key.</p></div><div class=\"col-md-12 content-html\"><p>A column is a triplet: key, value, and timestamp. The validation and comparator on the column family define how Cassandra sorts and stores the bytes in column keys.<br />The timestamp portion of the column is used to sequence mutations. The timestamp is defined and specified by the client and can be anything the client wishes to use.  By convention, the timestamp is typically microseconds since epoch.  If time-based, clients must be careful to synchronize clocks.</p><p>Columns may optionally have a time-to-live (TTL), after which Cassandra asynchronously deletes them. </p><div class=\"../images/hot_tip.gif\">\n <p><img alt=\"Hot Tip\" class=\"../images/hot_tip.gif_icon fr-dii fr-fil\" src=\"https://dzone.com/storage/rc-covers/14343-thumb.png\" /></p> Originally SuperColumns were one of Cassandra’s data model primitives.  Although they are still supported in the API, we recommend you use CompositeTypes instead. \n</div></div><div class=\"col-md-12 content-html\"><p>Cassandra uses a ring architecture. The ring represents a cyclic range of token values (i.e., the token space).  Each node is assigned a position on the ring based on its token.   A node is responsible for all tokens between its initial token and the initial token of the closest previous node along the ring.</p></div><div class=\"col-md-12 content-html\"><p>Keys are mapped into the token space by a partitioner. The important distinction between the partitioners is order preservation (OP). Users can define their own partitioners by implementing IPartitioner, or they can use one of the native partitioners:</p><table border=\"1\" style=\"width: 467px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 196px;\"> </td>\n   <td class=\"right_th_colored\" style=\"width: 73px;\">Map Function</td>\n   <td class=\"right_th_colored\" style=\"width: 80px;\">Token Space</td>\n   <td class=\"right_th_colored\" style=\"width: 90px;\">OP</td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">RandomPartitioner</td>\n   <td class=\"right_td_colored\">MD5</td>\n   <td class=\"right_td_colored\">BigInteger</td>\n   <td class=\"right_td_colored\">No</td>\n  </tr><tr><td class=\"left_td_colored\">BytesOrderPartitioner</td>\n   <td class=\"right_td_colored\">Identity</td>\n   <td class=\"right_td_colored\">Bytes</td>\n   <td class=\"right_td_colored\">Yes</td>\n  </tr></tbody></table><p>The following examples illustrate this point.</p><h3>Random Partitioner</h3><p>Since the Random Partitioner uses an MD5 hash function to map keys into tokens, on average those keys will evenly distribute across the cluster. For this reason, RandomPartitioner is the default partitioner.</p><p>The row key determines the node placement:</p><table border=\"1\" style=\"width: 537px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 84px;\">Row Key</td>\n   <td class=\"right_th_colored\" style=\"width: 116px;\"> </td>\n   <td class=\"right_th_colored\" style=\"width: 172px;\"> </td>\n   <td class=\"right_th_colored\" style=\"width: 137px;\"> </td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">Lisa</td>\n   <td class=\"right_td_colored\">state: CA</td>\n   <td class=\"right_td_colored\">graduated: 2008</td>\n   <td class=\"right_td_colored\">gender: F</td>\n  </tr><tr><td class=\"left_td_colored\">Owen</td>\n   <td class=\"right_td_colored\">state: TX</td>\n   <td class=\"right_td_colored\">gender: M</td>\n   <td class=\"right_td_colored\"> </td>\n  </tr><tr><td class=\"left_td_colored\">Collin</td>\n   <td class=\"right_td_colored\">state: UT</td>\n   <td class=\"right_td_colored\">gender: M</td>\n   <td class=\"right_td_colored\"> </td>\n  </tr></tbody></table><p>This may result in following ring formation, where \"collin\", \"owen\", and \"lisa\" are rowkeys.</p><p><img alt=\"“Random\" class=\"fr-dii fr-fil\" src=\"https://dzone.com/storage/rc-covers/14344-thumb.png\" /></p><p>With Cassandra’s storage model, where each node owns the preceding token space, this results in the following storage allocation based on the tokens.</p><table border=\"1\" style=\"width: 258px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 41px;\">Row Key</td>\n   <td class=\"right_th_colored\" style=\"width: 142px;\">MD5 Hash</td>\n   <td class=\"right_th_colored\" style=\"width: 53px;\">Node</td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">collin</td>\n   <td class=\"right_td_colored\">CC982736AD62AB</td>\n   <td class=\"right_td_colored\">3</td>\n  </tr><tr><td class=\"left_td_colored\">owen</td>\n   <td class=\"right_td_colored\">9567238FF72635</td>\n   <td class=\"right_td_colored\">2</td>\n  </tr><tr><td>lisa</td>\n   <td>001AB62DE123FF</td>\n   <td>1</td>\n  </tr></tbody></table><p>Notice that the keys are not in order. With RandomPartitioner, the keys are evenly distributed across the ring using hashes, but you sacrifice order, which means any range query needs to query all nodes in the ring.</p><h3>Order Preserving Partitioners (OPP)</h3><p>The Order Preserving Partitioners preserve the order of the row keys as they are mapped into the token space.  </p><p>In our example, since:</p><p><em> \"collin\" &lt; \"lisa\" &lt; \"owen\"</em></p><p>then,</p><p><em>token(\"collin\") &lt; token(\"lisa\") &lt; token(\"owen\")</em></p><p>With OPP, range queries are simplified and a query may not need to consult each node in the ring.  This seems like an advantage, but it comes at a price.  Since the partitioner is preserving order, the ring may become unbalance unless the rowkeys are naturally distributed across the token space.  </p><p>This is illustrated below. </p><p><img alt=\"“OPP”\" class=\"fr-dii fr-fil\" src=\"https://dzone.com/storage/rc-covers/14345-thumb.png\" /></p><p>To manually balance the cluster, you can set the initial token for each node in the Cassandra configuration.</p><div class=\"../images/hot_tip.gif\">\n <p><img alt=\"Hot Tip\" class=\"../images/hot_tip.gif_icon fr-dii fr-fil\" src=\"https://dzone.com/storage/rc-covers/14346-thumb.png\" /></p> If possible, it is best to design your data model to use RandomPartitioner to take advantage of the automatic load balancing and decreased administrative overhead of manually managing token assignment. \n</div></div><div class=\"col-md-12 content-html\"><p>Cassandra provides high availability and fault tolerance through data replication.  The replication uses the ring to determine nodes used for replication.   Each keyspace has an independent replication factor, <em>n</em>.  When writing information, the data is written to the target node as determined by the partitioner and <em>n-1 </em>subsequent nodes along the ring.</p><p>There are two replication strategies: SimpleStrategy and NetworkTopologyStrategy.</p><h3>SimpleStrategy</h3><p>The SimpleStrategy is the default strategy and blindly writes the data to subsequent nodes along the ring.  In the previous example with a replication factor of <em>2</em>, this would result in the following storage allocation.</p><table border=\"1\" style=\"width: 469px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 59px;\">Row Key</td>\n   <td class=\"right_th_colored\" style=\"width: 179px;\">Replica 1 <br />(as determined by partitioner)</td>\n   <td class=\"right_th_colored\" style=\"width: 209px;\">Replica 2<br />(found by traversing the ring)</td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">collin</td>\n   <td class=\"right_td_colored\">3</td>\n   <td class=\"right_td_colored\">1</td>\n  </tr><tr><td class=\"left_td_colored\">owen</td>\n   <td class=\"right_td_colored\">2</td>\n   <td class=\"right_td_colored\">3</td>\n  </tr><tr><td class=\"left_td_colored\">lisa</td>\n   <td class=\"right_td_colored\">1</td>\n   <td class=\"right_td_colored\">2</td>\n  </tr></tbody></table><h3>NetworkTopologyStrategy</h3><p>The NetworkTopologyStrategy is useful when deploying to multiple data centers. It ensures data is replicated across data centers.</p><p>Effectively, the NetworkTopologyStrategy executes the SimpleStrategy independently for each data center, spreading replicas across distant racks. Cassandra writes a copy in each data center as determined by the partitioner. Data is written simultaneously along the ring to subsequent nodes within that data center with preference for nodes in different racks to offer resilience to hardware failure. All nodes are peers and data files can be loaded through any node in the cluster, eliminating the single point of failure inherent in master-slave architecture and making Cassandra fully fault-tolerant and highly available.</p><p>Given the following ring and deployment topology:</p><p><img alt=\"“Topology&amp;quot;\" class=\"fr-dii fr-fil\" src=\"https://dzone.com/storage/rc-covers/14347-thumb.png\" /></p><p>With blue nodes (N1-N3) deployed to one data center (DC1), red nodes (N4-N6) deployed to another data center (DC2), and a replication factor of 4, Cassandra would write a row with key “lisa” as follows.</p><p>NOTE: Cassandra attempts to write data simultaneously to all target nodes then waits for confirmation from the relevant number of nodes needed to satisfy the specified consistency level. </p><h3>Consistency Levels</h3><p>One of the unique characteristics of Cassandra that sets it apart from other databases is its approach to consistency.  Clients can specify the consistency level on both read and write operations trading off between high availability, consistency, and performance.</p><h3>Write</h3><table border=\"1\" style=\"width: 545px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 130px;\"><strong>Level</strong></td>\n   <th class=\"right_th_colored\" style=\"width: 399px;\"><strong>Expectation</strong></th>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">ANY</td>\n   <td class=\"right_td_colored\">The write was logged, but the data may not be available for reads immediately. This is useful where you need high availability for writes but only eventual consistency on reads.</td>\n  </tr><tr><td class=\"left_td_colored\">ONE</td>\n   <td class=\"right_td_colored\">Data is committed to at least one replica and is available for reads.</td>\n  </tr><tr><td class=\"left_td_colored\">TWO</td>\n   <td class=\"right_td_colored\">Data is committed to at least two replicas and is available for reads.</td>\n  </tr><tr><td class=\"left_td_colored\">THREE</td>\n   <td class=\"right_td_colored\">Data is committed to at least three replicas and is available for reads.</td>\n  </tr><tr><td class=\"left_td_colored\">QUORUM</td>\n   <td class=\"right_td_colored\">Data is committed to at least n/2+1 replicas and is available for reads, where n is the replication factor.</td>\n  </tr><tr><td class=\"left_td_colored\">LOCAL_QUORUM</td>\n   <td class=\"right_td_colored\">Data is committed to at least n/2+1 replicas within the local data center.</td>\n  </tr><tr><td class=\"left_td_colored\">EACH_QUORUM</td>\n   <td class=\"right_td_colored\">Data is committed to at least n/2+1 replicas within each data center.</td>\n  </tr><tr><td class=\"left_td_colored\">ALL</td>\n   <td class=\"right_td_colored\">Data is committed to and available from all n replicas. This is useful when absolute read consistency and/or fault tolerance are necessary (e.g., online disaster recovery).</td>\n  </tr></tbody></table><h3>Read</h3><table border=\"1\" style=\"width: 548px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 130px;\"><strong>Level</strong></td>\n   <td class=\"right_th_colored\" style=\"width: 380px;\"><strong>Expectation</strong></td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">ONE</td>\n   <td class=\"right_td_colored\">The client receives data from the first replica to respond.</td>\n  </tr><tr><td class=\"left_td_colored\">TWO</td>\n   <td class=\"right_td_colored\">The client receives the most current data between two replicas based on the timestamps.</td>\n  </tr><tr><td class=\"left_td_colored\">THREE</td>\n   <td class=\"right_td_colored\">The client receives the most current data between three replicas based on the timestamps.</td>\n  </tr><tr><td class=\"left_td_colored\">QUORUM</td>\n   <td class=\"right_td_colored\">The client receives the most current data once n/2+1 replicas have responded.</td>\n  </tr><tr><td class=\"left_td_colored\">LOCAL_QUORUM</td>\n   <td class=\"right_td_colored\">The client receives the most current data once n/2+1 replicas have responded within the local data center.</td>\n  </tr><tr><td class=\"left_td_colored\">EACH_QUORUM</td>\n   <td class=\"right_td_colored\">The client receives the most current data once n/2+1 replicas have responded within each data center.</td>\n  </tr><tr><td class=\"left_td_colored\">ALL</td>\n   <td class=\"right_td_colored\">The client receives the most current data once all replicas have responded</td>\n  </tr></tbody></table></div><div class=\"col-md-12 content-html\"><p>As input into the replication strategy and to efficiently route communication, Cassandra uses a <em>snitch</em> to determine the data center and rack of the nodes in the cluster.  A snitch is a component that detects and informs Cassandra about the network topology of the deployment.  </p><p>The snitch dictates what is used in the strategy options to identify replication groups when configuring replication for a keyspace.</p><table border=\"1\" style=\"width: 395px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 41px;\">Nodes</td>\n   <td class=\"right_th_colored\" style=\"width: 32px;\">Rack</td>\n   <td class=\"right_th_colored\" style=\"width: 22px;\">DC</td>\n   <td class=\"right_th_colored\" style=\"width: 272px;\">Reason</td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">N4</td>\n   <td class=\"right_td_colored\">3</td>\n   <td class=\"right_td_colored\">2</td>\n   <td class=\"right_td_colored\">As determined by partitioner in DC1.</td>\n  </tr><tr><td class=\"left_td_colored\">N2</td>\n   <td class=\"right_td_colored\">1</td>\n   <td class=\"right_td_colored\">1</td>\n   <td class=\"right_td_colored\">As determined by partitioner in DC2.</td>\n  </tr><tr><td class=\"left_td_colored\">N6</td>\n   <td class=\"right_td_colored\">4</td>\n   <td class=\"right_td_colored\">2</td>\n   <td class=\"right_td_colored\">Preference shown for Rack 4 (over Rack 3).</td>\n  </tr><tr><td class=\"left_td_colored\">N3</td>\n   <td class=\"right_td_colored\">1</td>\n   <td class=\"right_td_colored\">1</td>\n   <td>Written to same rack hosting N2 since no other rack was available.</td>\n  </tr></tbody></table><p>. </p><p>The following table shows the four snitches provided by Cassandra and what you should use in your keyspace configuration for each snitch.</p><table border=\"1\" style=\"width: 443px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 119px;\">Snitch</td>\n   <td class=\"right_th_colored\" style=\"width: 324px;\">Specify</td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">SimpleSnitch</td>\n   <td class=\"right_td_colored\">Specify only the replication factor in your strategy options.</td>\n  </tr><tr><td class=\"left_td_colored\">PropertyFileSnitch</td>\n   <td class=\"right_td_colored\">Specify the data center names from your properties file in the keyspace strategy options.</td>\n  </tr><tr><td class=\"left_td_colored\">RackInferringSnitch</td>\n   <td class=\"right_td_colored\">Specify the second octet of the IPv4 address in your keyspace strategy options.</td>\n  </tr><tr><td class=\"left_td_colored\">EC2Snitch</td>\n   <td class=\"right_td_colored\">Specify the region name in the keyspace strategy options.</td>\n  </tr></tbody></table><h3>SimpleSnitch</h3><p>The SimpleSnitch provides Cassandra no information regarding racks or data centers.  It is the default setting and is useful for simple deployments where all servers are collocated.</p><h3>PropertyFileSnitch</h3><p>The PropertyFileSnitch allows users to be explicit about their network topology.  The user specifies the topology in a properties file, <em>cassandra-topology.properties. </em> The file specifies which nodes belong to which racks and data centers.  Below is an example property file for our sample cluster.</p><p><em># DC1<br />192.168.0.1=DC1:RAC1<br />192.168.0.2=DC1:RAC1<br />192.168.0.3=DC1:RAC2</em></p><p># DC2<br />192.168.1.4=DC2:RAC3<br />192.168.1.5=DC2:RAC3<br />192.168.1.6=DC2:RAC4</p><p># Default for nodes<br />default=DC3:RAC5 </p><h3>RackInferringSnitch</h3><p>The RackInferringSnitch infers network topology by convention.  From the IPv4 address (e.g., 9.100.47.75), the snitch uses the following convention to identify the data center and rack:</p><table border=\"1\" style=\"width: 221px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 46px;\">Octet</td>\n   <td class=\"right_th_colored\" style=\"width: 62px;\">Example</td>\n   <td class=\"right_th_colored\" style=\"width: 91px;\">Indicates</td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">1</td>\n   <td class=\"right_td_colored\">9</td>\n   <td class=\"right_td_colored\">Nothing</td>\n  </tr><tr><td class=\"left_td_colored\">2</td>\n   <td class=\"right_td_colored\">100</td>\n   <td class=\"right_td_colored\">Data Center</td>\n  </tr><tr><td class=\"left_td_colored\">3</td>\n   <td class=\"right_td_colored\">47</td>\n   <td class=\"right_td_colored\">Rack</td>\n  </tr><tr><td class=\"left_td_colored\">4</td>\n   <td class=\"right_td_colored\">75</td>\n   <td class=\"right_td_colored\">Node</td>\n  </tr></tbody></table><h3>EC2Snitch</h3><p>The EC2Snitch is useful for deployments to Amazon's EC2. It uses Amazon's API to examine the regions to which nodes are deployed. It then treats each region as a separate data center.</p><p>EC2MultiRegionSnitch</p><p>Use this snitch for deployments on Amazon EC2 where the cluster spans multiple regions. This snitch treats data centers and availability zones as racks within a data center and uses public IPs as broadcast_address to allow cross-region connectivity. Cassandra nodes in one EC2 region can bind to nodes in another region, thus enabling multi-data center support.</p></div><div class=\"col-md-12 content-html\"><p>Cassandra provides simple primitives. Its simplicity allows it to scale linearly with high availability and very little performance degradation.   That simplicity allows for extremely fast read and write operations for specific keys, but servicing more sophisticated queries that span keys requires pre-planning.</p><p>Using the primitives that Cassandra provides, you can construct indexes that support exactly the query patterns of your application.  Note, however, that queries may not perform well without properly designing your schema. </p><h3>Secondary Indexes</h3><p>To satisfy simple query patterns, Cassandra provides a native indexing capability called Secondary Indexes. A column family may have multiple secondary indexes. A secondary index is hash-based and uses specific columns to provide a reverse lookup mechanism from a specific column value to the relevant row keys. Under the hood, Cassandra maintains hidden column families that store the index. The strength of Secondary Indexes is allowing queries by value. Secondary indexes are built in the background automatically without blocking reads or writes. To create a Secondary Index using CQL is straight-forward. For example, define a table of data about movie fans, and then create a secondary index of states where they live:</p><p>CREATE TABLE fans ( watcherID uuid, favorite_actor text, address text, zip int, state text PRIMARY KEY (watcherID) );</p><p>CREATE INDEX watcher_state ON fans (state);</p><h3>Range Queries</h3><p>It is important to consider partitioning when designing your schema to support range queries.</p><h4>Range Queries with Order Preservation</h4><p>Since order is preserved, order preserving partitioners better supports range queries across a range of rows.  Cassandra only needs to retrieve data from the subset of nodes responsible for that range.  For example, if we are querying against a column family keyed by phone number and we want to find all phone numbers between that begin with <em>215-555</em>, we could create a range query with start key <em>215-555-0000 </em>and end key <em>215-555-9999.</em></p><p>To service this request with OrderPreservingPartitioning, it’s possible for Cassandra to compute the two relevant tokens: <em>token(215-555-0000) </em>and<em> token(215-555-9999)</em>.</p><p>Then satisfying that querying simply means consulting nodes responsible for that token range and retrieving the rows/tokens in that range.</p><h4>Range Queries with Random Partitioning</h4><p>The RandomPartitioner provides no guarantees of any kind between keys and tokens.  In fact, ideally row keys are distributed around the token ring evenly.  Thus, the corresponding tokens for a start key and end key are not useful when trying to retrieve the relevant rows from tokens in the ring with the RandomPartitioner.  Consequently, Cassandra must consult all nodes to retrieve the result.  Fortunately, there are well known design patterns to accommodate range queries.  These are described below.</p><h3>Index Patterns</h3><p>There are a few design patterns to implement indexes.  Each services different query patterns.  The patterns leverage the fact that Cassandra columns are always stored in sorted order and all columns for a single row reside on a single host.</p><h3>Inverted Indexes</h3><p>First, let’s consider the <em>inverted index</em> pattern.  In an inverted index, columns in one row become row keys in another.  Consider the following data set, where users IDs are row keys.</p><table border=\"1\" cellpadding=\"0\" style=\"border-spacing: 0px; width: 458px;\"><thead><tr><td class=\"left_th_colored\" colspan=\"4\" valign=\"top\"><p><strong>Column Family: Users</strong></p></td>\n  </tr></thead><thead><tr><td class=\"left_th_colored\" valign=\"top\" style=\"width: 76px;\"><p><strong>RowKey</strong></p></td>\n   <th class=\"right_th_colored\" colspan=\"3\" valign=\"top\"><p><strong>Columns</strong></p></th>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 76px;\"><p>BONE42</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 128px;\"><p>{ name : “Brian”}</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 105px;\"><p>{ zip: 15283}</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 139px;\"><p>{dob : 09/19/1982}</p></td>\n  </tr><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 76px;\"><p>LKEL76</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 128px;\"><p>{ name : “Lisa”}</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 105px;\"><p>{ zip: 98612}</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 139px;\"><p>{dob : 07/23/1993}</p></td>\n  </tr><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 76px;\"><p>COW89</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 128px;\"><p>{ name : “Dennis”}</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 105px;\"><p>{ zip: 98612}</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 139px;\"><p>{dob : 12/25/2004}</p></td>\n  </tr></tbody></table><p>Without indexes, searching for users in a specific Zip Code would mean scanning our Users column family row-by-row to find the users in the relevant Zip Code.  Obviously, this does not perform well. <br />To remedy the situation, we can create a column family that represents the query we want to perform, inverting rows and columns.  This would result in the following column family.</p><table border=\"1\" cellpadding=\"0\" style=\"border-spacing: 0px; width: 458px;\"><thead><tr><td class=\"left_th_colored\" colspan=\"4\" valign=\"top\"><p><strong>Column Family: Users_by_ZipCode</strong></p></td>\n  </tr></thead><thead><tr><td class=\"left_th_colored\" valign=\"top\" style=\"width: 77px;\"><p><strong>RowKey</strong></p></td>\n   <td class=\"right_th_colored\" colspan=\"3\" valign=\"top\"><p><strong>Columns</strong></p></td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 77px;\"><p>98612</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 137px;\"><p>{ user_id : LKEL76 }</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 139px;\"><p>{ user_id : COW89 }</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 95px;\"></td>\n  </tr><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 77px;\"><p>15283</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 137px;\"><p>{ user_id : BONE42 }</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 139px;\"></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 95px;\"></td>\n  </tr></tbody></table><p>Since each row is stored on a single machine, Cassandra can quickly return all user IDs within a single Zip Code by returning all columns within a single row.  Cassandra simply goes to a single host based on <em>token(zipcode)</em> and returns the contents of that single row.</p><h3>Wide-Row Indexes</h3><p>When working with time series data, consider storing the complete set of data for each event in the timeline itself by serializing the entire event into a single column value or by using composite column names of the form &lt; timestamp &gt; : &lt; event_field &gt;. Unless the data for each event is very large, this approach scales well with large data sets and provides efficient reads. Fetch a time slice of events by reading a contiguous portion of a row on one set of replicas. When you track the same event in multiple timelines, denormalizing and storing all of the event data in each of the timelines works well.</p><table border=\"1\" style=\"width: 455px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 445px;\"><strong>Materialized View Table</strong></td>\n  </tr></thead></table><table border=\"1\" style=\"width: 456px;\"><tbody><tr><td class=\"left_td_colored\" style=\"width: 97px;\">lsmith: 1332960000</td>\n   <td class=\"right_td_colored\" style=\"width: 220px;\">C4e1ee6f-e053-41f5-9890-<br />674636d51095:<br />{\"user\": \"lsmith\", \"body\": \"There<br />are . . . \"}</td>\n   <td class=\"left_td_colored\" style=\"width: 117px;\">39f71a85-7af0 . . .<br />{\"user\": \"lsmith\",<br />\"body\": \"Yes, . . .</td>\n  </tr><tr><td class=\"left_td_colored\">cbrown:<br />1332960000</td>\n   <td class=\"right_td_colored\">e572bad1-f98d-4346-80a0-<br />13e7d37d38d0:<br />{\"user\":\"cbrown\", \"body\": \"My dog<br />is . . .\"}</td>\n   <td class=\"right_td_colored\">aa33bgbfd-8f16 . . .<br />{\"user\":\"cbrown\",<br />\"body\":\"No, . . .</td>\n  </tr></tbody></table><p>When you use composite keys in CQL, Cassandra supports wide Cassandra rows using composite column names. In CQL 3, a primary key can have any number (1 or more) of component columns, but there must be at least one column in the column family that is not part of the primary key. The new wide row technique consumes more storage because for every piece of data stored, the column name is stored along with it.</p><p><em>CREATE TABLE History.events (<br />event uuid PRIMARY KEY,<br />author varchar,<br />body varchar);</em></p><p>CREATE TABLE timeline (<br />user varchar,<br />event uuid,<br />author varchar,<br />body varchar,</p><div class=\"../images/hot_tip.gif\">\n <p><img alt=\"Hot Tip\" class=\"../images/hot_tip.gif_icon fr-dii fr-fil\" src=\"https://dzone.com/storage/rc-covers/14348-thumb.png\" /></p> Wide-Row indexes can cause hotspots in the cluster.  Since the index is a single row, it is stored on a single node (plus replicas).  If that is a heavily used index, those nodes may be overwhelmed. \n</div><h3>Composite-Types in Indexes</h3><p>The previous examples were one-dimensional and used a simple concatenation to illustrate the point.  Instead, you may prefer to use composite keys and/or values in your data model.  </p><p>Using composite keys in indexes, we can create queries along multiple dimensions.  If we combine the previous examples, we could create a <br />single wide-row capable of serving a compound query such as, “How many users within the 18964 Zip Code are older than 21?”</p><p>Simply create a composite type containing the Zip Code and the date of birth and use that as the column name in the index.</p><h3>Denormalization</h3><p>Finally, it is worth noting that each of the indexing strategies as presented would require two steps to service a query if the request requires the actual column data (e.g., user name). The first step would retrieve the keys out of the index. The second step would fetch each relevant column by row key.</p><p>We can skip the second step if we denormalize the data. In Cassandra, denormalization is the norm. If we duplicate the data, the index becomes a true materialized view that is custom tailored to the exact query we need to support.</p></div><div class=\"col-md-12 content-html\"><p>Everything in Cassandra is a write, typically referred to as a mutation. Since Cassandra is effectively a key-value store, operations are simply mutations of a key/value pairs. The column is atomic, but the fundamental unit is a row in the ACID sense. If you have multiple updates to the same key, group the changes into a single update.</p><div class=\"../images/hot_tip.gif\">\n <p><img alt=\"Hot Tip\" class=\"../images/hot_tip.gif_icon fr-dii fr-fil\" src=\"https://dzone.com/storage/rc-covers/14349-thumb.png\" /></p> When performing multiple operations on the same key in sequence, be sure to increment the timestamp! Do not simply specify System.currentTimeMillis().  If the code executes too quickly, the mutations will have the same timestamp and Cassandra will not be able to determine the proper sequencing of events. \n</div><h3>Hinted Handoff</h3><p>Similar to ReadRepair, Hinted Handoff is a background process that ensures data integrity and eventual consistency.  If a replica is down in the cluster and the client requests a consistency level of ANY, a write may still succeed by writing a “hint” to a coordinator node, which will disseminate that data to replicas when they become available.</p></div><div class=\"col-md-12 content-html\"><p>Cassandra provides tools for operations and maintenance.  Some of the maintenance is mandatory because of Cassandra’s eventually consistent architecture.  Other facilities are useful to support alerting and statistics gathering.  Use <em>nodetool</em> to manage Cassandra.  Datastax provides a reference card on nodetool available here:</p><p><a href=\"http://www.datastax.com/wp-content/uploads/2012/01/DS_nodetool_web.pdf\">http://www.datastax.com/wp-content/uploads/2012/01/DS_nodetool_web.pdf</a></p><h3>Nodetool Repair</h3><p>Cassandra keeps record of deleted values for some time to support the eventual consistency of distributed deletes.  These values are called tombstones.  Tombstones are purged after some time (GCGraceSeconds, which defaults to 10 days).  Since tombstones prevent improper data propagation in the cluster, you will want to ensure that you have consistency before they get purged.</p><p>To ensure consistency, run:</p><p><em>&gt;$CASSANDRA_HOME/bin/nodetool repair</em></p><p>The repair command replicates any updates missed due to downtime or loss of connectivity. This command ensures consistency across the cluster and obviates the tombstones. You will want to do this periodically on each node in the cluster (within the window before tombstone purge).</p><h3>Monitoring</h3><p>Cassandra has support for monitoring via JMX, but the simplest way to monitor the Cassandra node is by using OpsCenter, which is designed to manage and monitor Cassandra database clusters. There is a free community edition as well as an enterprise edition that provides management of Apache SOLR and Hadoop.</p><p>Simply download mx4j and execute the following:</p><p><em>cp $MX4J_HOME/lib/mx4j-tools.jar $CASSANDRA_HOME/lib</em></p><p>The following are key attributes to track per column family.</p><table border=\"1\" cellpadding=\"0\" style=\"border-spacing: 0px; width: 422px;\"><thead><tr><td class=\"left_th_colored\" valign=\"top\" style=\"width: 97px;\"><p><strong>Attribute</strong></p></td>\n   <td class=\"right_th_colored\" valign=\"top\" style=\"width: 319px;\"><p><strong>Provides</strong></p></td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 97px;\"><p>Read Count</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 319px;\"><p>Frequency of reads against the column family.</p></td>\n  </tr><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 97px;\"><p>Read Latency</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 319px;\"><p>Latency of reads against the column family.</p></td>\n  </tr><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 97px;\"><p>Write Count</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 319px;\"><p>Frequency of writes against the column family.</p></td>\n  </tr><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 97px;\"><p>Write Latency</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 319px;\"><p>Latency of writes against the column family.</p></td>\n  </tr><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 97px;\"><p>Pending Tasks</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 319px;\"><p>Queue of pending tasks, informative to know if tasks are queuing.</p></td>\n  </tr></tbody></table><h3>Backup</h3><p>OpsCenter facilitates backing up data by providing snapshots of the data. A snapshot creates a new hardlink to every live SSTable. Cassandra also provides online backup facilities using nodetool. To take a snapshot of the data on the cluster, invoke:</p><p><em>$CASSANDRA_HOME/bin/nodetool snapshot</em></p><p>This will create a snapshot directory in each keyspace data directory.  Restoring the snapshot is then a matter of shutting down the node, deleting the commitlogs and the data files in the keyspace, and copying the snapshot files back into the keyspace directory.</p></div><div class=\"col-md-12 content-html\"><p>Cassandra has a very active community developing libraries in different languages.  </p><h3>Java</h3><table border=\"1\" cellpadding=\"0\" style=\"border-spacing: 0px;\"><thead><tr><td class=\"left_th_colored\" valign=\"top\" style=\"width: 76px;\"><p><strong>Client</strong></p></td>\n   <td class=\"right_th_colored\" valign=\"top\" style=\"width: 520px;\"><p><strong>Description</strong></p></td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 76px;\"><p>Astyanax</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 520px;\"><p>Inspired by Hector, Astyanax is a client library developed by the folks at Netflix.   <br /><a href=\"https://github.com/Netflix/astyanax\">https://github.com/Netflix/astyanax</a></p></td>\n  </tr><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 76px;\"><p>Hector</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 520px;\"><p>Hector is one of the first APIs to wrap the underlying Thrift API. Hector is one of the most commonly used client libraries.<br /><a href=\"https://github.com/rantav/hector\">https://github.com/rantav/hector</a></p></td>\n  </tr></tbody></table><h3>CQL</h3><table border=\"1\" cellpadding=\"0\" style=\"border-spacing: 0px; width: 629px;\"><thead><tr><td class=\"left_th_colored\" valign=\"top\" style=\"width: 82px;\"><p><strong>Client</strong></p></td>\n   <th class=\"right_th_colored\" valign=\"top\" style=\"width: 541px;\"><p><strong>Description</strong></p></th>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 82px;\"><p>CQL</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 541px;\"><p>Cassandra provides an SQL-like query language called the Cassandra Query Language (CQL).  The CQL shell allows you to interact with Cassandra as if it were a SQL database.  Start the shell with:<br />&gt;$CASSANDRA_HOME/bin/cqlsh<br />Datastax provides a reference card for CQL available here:<br /><a href=\"http://www.datastax.com/wp-content/uploads/2012/01/DS_CQL_web.pdf\">http://www.datastax.com/wp-content/uploads/2012/01/DS_CQL_web.pdf</a></p></td>\n  </tr></tbody></table><h3>Python</h3><table border=\"1\" cellpadding=\"0\" style=\"border-spacing: 0px; width: 472px;\"><thead><tr><td class=\"left_th_colored\" valign=\"top\" style=\"width: 49px;\"><p><strong>Client</strong></p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 417px;\"><p><strong>Description</strong></p></td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 49px;\"><p>Pycassa</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 417px;\"><p>Pycassa is the most well known Python library for Cassandra.<br /><a href=\"https://github.com/pycassa/pycassa\">https://github.com/pycassa/pycassa</a></p></td>\n  </tr></tbody></table><h3>PHP CQL</h3><table border=\"1\" style=\"width: 473px;\"><thead><tr><td class=\"left_th_colored\" style=\"width: 70px;\">Client</td>\n   <td class=\"right_th_colored\" style=\"width: 387px;\">Description</td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\">Cassandra-<br />PDO</td>\n   <td class=\"right_td_colored\">A CQL (Cassandra Query Language) driver for PHP.<br /><a href=\"http://code.google.com/a/apache-extras.org/p/cassandra-pdo/\">http://code.google.com/a/apache-extras.org/p/cassandra-pdo/</a></td>\n  </tr></tbody></table><h3>Ruby</h3><table border=\"1\" cellpadding=\"0\" style=\"border-spacing: 0px; width: 473px;\"><thead><tr><td class=\"left_th_colored\" valign=\"top\" style=\"width: 56px;\"><p><strong>Client</strong></p></td>\n   <td class=\"right_th_colored\" valign=\"top\" style=\"width: 411px;\"><p><strong>Description</strong></p></td>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 56px;\"><p>Ruby Gem</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 411px;\"><p>Ruby has support for Cassandra via a gem.<br /><a href=\"http://rubygems.org/gems/cassandra\">http://rubygems.org/gems/cassandra</a></p></td>\n  </tr></tbody></table><h3>REST</h3><table border=\"1\" cellpadding=\"0\" style=\"border-spacing: 0px; width: 468px;\"><thead><tr><td class=\"left_th_colored\" valign=\"top\" style=\"width: 49px;\"><p><strong>Client</strong></p></td>\n   <th class=\"right_th_colored\" valign=\"top\" style=\"width: 413px;\"><p><strong>Description</strong></p></th>\n  </tr></thead><tbody><tr><td class=\"left_td_colored\" valign=\"top\" style=\"width: 49px;\"><p>Virgil</p></td>\n   <td class=\"right_td_colored\" valign=\"top\" style=\"width: 413px;\"><p>Virgil is a java-based REST client for Cassandra.<br /><a href=\"https://github.com/hmsonline/virgil\">https://github.com/hmsonline/virgil</a></p></td>\n  </tr></tbody></table><h3>Command Line Interface (CLI)</h3><p>Cassandra also provides a Command Line Interface (CLI) through which you can perform all schema related changes. It also allows you to manipulate data. Datastax provides a reference card on the CLI available here:</p><p><a href=\"http://www.datastax.com/wp-content/uploads/2012/01/DS_CLI_web.pdf\">http://www.datastax.com/wp-content/uploads/2012/01/DS_CLI_web.pdf</a></p><h3>Hadoop Support</h3><p>DataStax Enterprise provides Cassandra with an enhanced Hadoop distribution that is compatible with existing HDFS, Hadoop, and Hive tools and utilities. Cassandra also provides out-of-the-box support for Hadoop. To see the canonical word count example, take a look at:</p><p><a href=\"https://github.com/apache/cassandra/tree/trunk/examples/hadoop_word_count\">https://github.com/apache/cassandra/tree/trunk/examples/hadoop_word_count</a></p><h3>DataStax Community Edition</h3><p>DataStax Community Edition provides the latest release from the Apache Cassandra community.</p><ul><li>Binary tarballs for Linux and Mac installation</li>\n <li>Packaged installations for Red Hat Enterprise Linux, CentOS, Debian, and Ubuntu</li>\n <li>A GUI installer for Windows</li>\n</ul><p>RHEL and Debian packages are supported through yum and apt package management tools.he DataStax Community Edition also includes the DataStax OpsCenter.</p></div>"}}]}},"pageContext":{"alternative_id":11064}}