{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Storing Nested Objects in Cassandra with Composite Columns","alternative_id":12073,"content":"<div class=\"pd-rating\" id=\"pd_rating_holder_3023117_post_1013\"><br /><p>One of the popular features of <em>MongoDB</em> is the ability to store arbitrarily nested objects and be able to index on any nested field. In this post I will show how to store nested objects in Cassandra using composite columns. I have recently added this feature to my open source Cassandra project <a href=\"https://github.com/pranab/agiato\" target=\"_blank\"><em>agiato</em></a>. Since in Cassandra, like many other NOSQL databases, stored data is highly denormalized. The denormalized data  often manifests itself in the form of a nested object e.g., denormalizing one to many relations.</p>\n<p>In the  solution presented here, the object data is stored in column families with composite columns. An object will typically have some statically defined fields. Rest of the fields will be dynamic. It is possible to define the table or column family behind the object in CQL3, based on the statically known fields of the object.</p>\n<h2>Composite Column</h2>\n<p>Super columns are frowned upon in Cassandra. Composite columns are the preferred approach. <a href=\"http://www.datastax.com/dev/blog/schema-in-cassandra-1-1\" target=\"_blank\">Composite columns</a> can do what super columns could do and more. The underlying data model in a super column is a 3 level nested map(including row key, super column name or key and column name or key). Composite columns are more flexible, allowing you to create a data model with multi level nested map.</p>\n<p>Here is an example of data model based on composite columns. Consider a building HVAC system with the sensor data  stored in a column family with composite columns. Here are the fields.</p>\n<table><tbody><tr><td>day</td>\n<td>day as integer</td>\n<td>20130421</td>\n</tr><tr><td>city</td>\n<td>city name</td>\n<td>Los Angeles</td>\n</tr><tr><td>buildingID</td>\n<td>An integer ID for a building</td>\n<td>2658</td>\n</tr><tr><td>sensorID</td>\n<td>An integer ID for a sensor in a building</td>\n<td>295016</td>\n</tr><tr><td>time</td>\n<td>timestamp as long</td>\n<td>1361237156</td>\n</tr><tr><td>temp</td>\n<td>temarature as double</td>\n<td>71.2</td>\n</tr><tr><td>humidity</td>\n<td>relative humidity as double</td>\n<td>30.7</td>\n</tr></tbody></table><p>A record is uniquely identified with the tuple <em>(day, city, buildingID, sensorID, time)</em>. The corresponding column family definition with composite key will be as below</p>\n<pre>create column family buildingControl \nwith key_validation_class = 'IntegerType'\nand comparator = 'CompositeType(UTF8Type, IntegerType, IntegerType, LongType, UTF8Type)'\nand default_validation_class='DoubleType';</pre>\n<p>The composite column along with row key provide a 6 level nested map. The composite column has 5 components. The first 4 correspond to the value of the  tuple <em>(city, buildingID, sensorID, time)</em>.  The last element is the name of a non primary column. The storage layout of a record will look as below</p>\n<table><tbody><tr><td rowspan=\"2\">20130421</td>\n<td>Los Angeles:2658:295016:1361237156:temp</td>\n<td>Los Angeles:2658:295016:1361237156:humidity</td>\n</tr><tr><td>71.2</td>\n<td>30.7</td>\n</tr></tbody></table><p>The first 4 fields of the composite column name are the values of <em>(city, buildingID, sensorID, time) </em>values respectively, which are the clustering keys. The last component is the column name for a non primary key column. The value of the composite column is the corresponding non primary key column value.</p>\n<p>The composite column name is shown in a human readable form. Internally, the composite column name is stored with some byte encoding logic. As a nested Map,  a record, in this example can be represented as <em>Map&lt;Integer,Map&lt;String, Map&lt;Integer, Map&lt;Integer, Map&lt;Long, Map&gt;&gt;&gt;&gt;&gt; . </em>Strictly speaking all the inner maps are sorted maps. As we will see later, in terms of CQL, the outer map corresponds to the row key and all the inner maps except for the last one correspond to the clustering key.</p>\n<p>A record comprises of a set of columns. The set of columns is repeated in the row for different unique values of <em>(city, buildingID, sensorID, time)</em>. Essentially, a row will contain multiple records. Before composite key was introduced in Cassandra, people had resorted to using this pattern for multi level map by doing string concatenation for column values and names.</p>\n<h2>Primary Key Syntactic Sugar</h2>\n<p>In thrift, the interface to Cassandra is tightly coupled to the internal storage structure.  CQL introduces a layer of abstraction between the underlying storage structure and the logical model and makes the the data model  look like a familiar RDBMS table. The entity in our example has 7 attributes and as shown below, all 7 of them appear as columns in the CQL  table definition.</p>\n<pre>CREATE TABLE buildingControl (\n\tday int,\n\tcity text,\n\tbuildingID int,\n\tsensorID int,\n\ttime timestamp,\n\ttemp double,\n\thumidity double\n\tPRIMARY KEY (day, city, buildingID, sensorID, time)\n);</pre>\n<p>The primary key definition maps to the storage structure as follows. The first element <em>day</em> is the row key or the partitioning key. The remaining 4 elements constitute the clustering key. Internally, a record is stored with  2 physical columns, as we saw in the thrift data model definition. The 7 logical columns map to one row key and two composite columns.</p>\n<h2>Into the Object Land</h2>\n<p>So far in out example, data model had a flat record structure and we were able to define everything nicely with CQL.  What if we have multiple related entities in our use case and we wanted to denormalize the data model. Here is an example of an order object in an eCommerce application, represented with JSON.</p>\n<pre>{\n\t\"custID\" : '12736467',\n\t\"date\" : '2013-06-10',\n\t\"orderID\" : 19482065,\n\t\"amount\" : 216.28,\n\t\"status\" : 'picked',\n\t\"notes\" : 'on time',\n\t\"items\" : [\n\t\t{\n\t\t\t\"sku\" : 87482734,\n\t\t\t\"quantity\" : 4\n\t\t},\n\t\t{\n\t\t\t\"sku\" : 32851042,\n\t\t\t\"quantity\" : 2\n\t\t}\n\t],\n\t\"customer\" : {\n\t\t\"name\" : 'Joe Smith',\n\t\t\"tel\" : '231 456 7890',\n\t\t\"email\" : 'joe@yahoo.com'\n\t}\n}</pre>\n<p>As you can see the the order object contains a child customer object and a list of order line item objects. The embedded customer object is statically defined and we could include it’s attributes  as columns in CQL table definition. However, the embedded list of order line item objects can not be represented in CQL. Because, CQL can handle only list and map of primitives.</p>\n<p>Cassandra is a <em>schema optional</em> data base and you can have any of the following with respect to schema</p>\n<div>\n<ol><li><em>Completely static</em></li>\n<li><em>Completely dynamic</em></li>\n<li><em>Semi static</em></li>\n</ol></div>\n<p>The schema for our example falls into the third category, because we can not define all the fields in the schema.</p>\n<h2>Linearizing Object Hieararchy</h2>\n<p>If we a traverse an arbitrarily nested object, the leaf nodes will contain field name, primitive value pair.  To linearize an object, after the traversing the object hierarchy, a list of leaf node objects is generated. Each such node is saved as a composite column. For nested fields, the column name is generated by concatenating all fields names in the path from the leaf node to the root, separated by period.</p>\n<p>A CQL table along with primary key could be defined comprising of only the statically defined primitive fields of an object.  Here is the partial definition for the order object</p>\n<pre>CREATE TABLE orders (\n    custID text,\n    date text,\n    orderID int,\n    amount double,\n    status text,\n    notes text,\n    PRIMARY KEY (custID,date,orderID)\n);</pre>\n<p>The only advantage of creating the CQL schema, is that you could run CQL select query. However the query will only return the columns defined in the CQL schema, but not the dynamic attributes of the object.</p>\n<h2>Saving the Object</h2>\n<p>The object to be saved in passed to the agiato API as a <em>SimpleDynaBean</em> which is simplified implementation  of apache common <a href=\"http://commons.apache.org/proper/commons-beanutils/javadocs/v1.8.3/apidocs/org/apache/commons/beanutils/DynaBean.html\" target=\"_blank\"> <em>DynaBean</em></a> interface. With <em>SimpleDynaBean</em> you could define an arbitrarily nested object. The API also gets passed the  primary key definition.   The different options for object representation are as follows.</p>\n<div>\n<ol><li><em>SimpleDynaBean object</em></li>\n<li><em>JSON string</em></li>\n<li><em>Java bean object</em></li>\n</ol></div>\n<p>The following code snippet uses <em>SimpleDynaBean</em>  and saves the order object in the column family <em>orders</em>.</p>\n<p><em>SimpleDynaBean obj = new  <em>SimpleDynaBean</em>();</em><br /><em> //populate hierarchical object</em><br /><em> ……</em><br /><em> AgiatoContext.initialize(“/home/pranab/Projects/bin/agiato/test.json”);</em><br /><em> ColumnFamilyWriter writer = AgiatoContext.createWriter(“orders”);</em><br /><em>PrimaryKey primKey = new PrimaryKey(“custID”, “date”, “orderID”);<br /><em> writer.writeObject(obj, primKey, ConsistencyLevel.ONE);</em></em></p>\n<p>The object  is traversed in a depth first way and a list leaf nodes is generated. The leaf nodes will include the columns defined in CQL as well as all the dynamic fields.</p>\n<p>The  arguments  in the <em>PrimaryKey</em>  constructor are the primary key column names. Here only the first element constitutes the row key. If that was not the case  you had to call <em>setRowKeyElementCount()</em> to specify how many fields out of the primary key elements constitute  the row key.</p>\n<p>If after the depth first traversal, the primary key fields  appear in the beginning of the list,  you could call another<em> PrimaryKey</em> constructor and pass the number of primary key elements.</p>\n<p>The class <em><a href=\"https://github.com/pranab/agiato/blob/master/src/main/java/agiato/cassandra/data/ObjectSerDes.java\" target=\"_blank\">ObjectSerDes</a></em> hadles object traversal and mapping object fields to composite key columns. Here is the <em><a href=\"https://github.com/pranab/agiato/blob/master/src/main/java/agiato/cassandra/data/DataAccess.java\" target=\"_blank\">DataAccess</a></em> class for Cassandra data access through thrift. From the list of leaf nodes, the row key and the clustering key are identified.  After traversing an object, the flattened list of <i>NamedObject </i> is created as shown below</p>\n<table><tbody><tr><td>row key ObjectNode</td>\n<td colspan=\"2\">clustering key ObjectNodes</td>\n<td colspan=\"3\">other ObjectNodes</td>\n</tr></tbody></table><p>The first <em>NamedObject</em> value is converted to a row key. The clustering key <em>NamedObject</em> values makeup the prefix part of the composite key column name.  Then the columns are saved in a way that has the same effect as running a CQL insert query, except that it will store all the dynamic fields of the object, which were not part of the CQL definition.</p>\n<p>Field values are serialized based on introspection of the field data. There is no check made against table meta data. For the fields defined in CQL schema, if data with wrong type is passed in the object,  be prepared to get surprising results from CQL query.</p>\n<h2>Update and Delete</h2>\n<p>For update and delete, it’s necessary to pass a partially formed object, whether a dynamic object or JSON string, to the API, containing the primary key fields and other fields that are going to be updated or deleted. For example, to update the status of an order, it’s necessary for the order object to have the primary key fields and the <em>status</em> field.</p>\n<p>With  statically compiled java bean object,  it’s a difficult to define a  partially formed object. One way of doing it is to have all the fields as primitive wrapper objects, where null will imply absence of a field value.</p>\n<h2>Querying the Object</h2>\n<p>I don’t have the query method to return fully populated object implemented yet. I will be adding it soon. In the mean time we can use CQL and CLI. If we run a CQl query this is what we get. As expected it return only the columns it knows about from the table definition. It does not return any of the dynamic columns.</p>\n<pre> custid   | date       | orderid  | amount | notes   | status\n----------+------------+----------+--------+---------+--------\n 12736467 | 2013-06-10 | 19482065 | 216.28 | in time | picked</pre>\n<p>However, when we run a CLI query it returns every field that is physically stored in Cassandra as below. All the values are in bytes in the output</p>\n<pre>RowKey: 3132373336343637\n=&gt; (name=2013-06-10:19482065:amount, value=406b08f5c28f5c29, timestamp=13..)\n=&gt; (name=2013-06-10:19482065:customer.email, value=6a6f65407961686f6f2e636f6d, timestamp=13..)\n=&gt; (name=2013-06-10:19482065:customer.name, value=4a6f6520536d697468, timestamp=13..)\n=&gt; (name=2013-06-10:19482065:customer.tel, value=323331203435362037383930, timestamp=13..)\n=&gt; (name=2013-06-10:19482065:items.[0].quantity, value=00000004, timestamp=13..)\n=&gt; (name=2013-06-10:19482065:items.[0].sku, value=000000000536e16e, timestamp=13..)\n=&gt; (name=2013-06-10:19482065:items.[1].quantity, value=00000002, timestamp=13..)\n=&gt; (name=2013-06-10:19482065:items.[1].sku, value=0000000001f54462, timestamp=13..)\n=&gt; (name=2013-06-10:19482065:notes, value=696e2074696d65, timestamp=13..)\n=&gt; (name=2013-06-10:19482065:status, value=7069636b6564, timestamp=13..)</pre>\n<h2>Why not Just Serialize</h2>\n<p>You might ask why bother with mapping all the nested fields of an object to columns. Why not serialize all the dynamic fields of the object and store it as a JSON string and include that column as a text filed in CQL create table.  Granted, the column will be visible as a JSON string when you run CQl select query. If you are leaning in that direction, consider the following scenario</p>\n<div>\n<ul><li><em>You want to create secondary index on some nested field e.g., customer.zipCode. The field needs an independent existence as a column </em></li>\n<li><em>You want to treat such nested field  it as dimension in for aggregation and analytic queries involving nested objects</em></li>\n</ul></div>\n<p>The other advantage of having separate column for each nested field, is that CLI query results are more readable.</p>\n<h2>Next Steps</h2>\n<p>My first goal is to support object based query. A prototype object will be passed to agiato. The fields defining the query criteria will need to have the values defined in this object. These fields will be a subset of the primary key fields.</p>\n<p>The API after running the query will return one or more fully populated object. Other fields need not be passed as part of the query object. However, if some prototype value for other fields is passed, then the API will return typed value for the fields, otherwise it will return byte arrays for values.</p>\n<p>My next goal is to support aggregate and analytic queries. The user will define cube schema consisting dimensions and measures pointing to object attributes, including nested attributes. While storing an object aggregate values will be computed and stored in separate column families. Storm will be part of the aggregation engine ecosystem.</p>\n<p>For commercial support for this solution or other solutions in my <a href=\"https://github.com/pranab\" target=\"_blank\" rel=\"noopener\">github repositories</a>, please talk to <a href=\"https://thirdeyedata.io/data-science-services-pkghosh/\" target=\"_blank\" rel=\"noopener\">ThirdEye Data Science Services</a>. Support is available for <em>Hadoop</em> or Spark deployment on cloud including installation, configuration and testing,</p>\n<div id=\"atatags-370373-5b9144ebb5924\">\n        \n    </div>\t\t<div class=\"wpcnt\">\n\t\t\t<div class=\"wpa wpmrec\">\n\t\t\t\tAdvertisements\n\t\t\t\t<div class=\"u\">\t\t<div>\n\t\t<div id=\"atatags-26942-5b9144ebb594e\">\n\t\t\t\n\t\t</div></div>\t\t<div>\n\t\t<div id=\"atatags-114160-5b9144ebb5950\">\n\t\t\t\n\t\t</div></div></div>\n\t\t\t\t\n\t\t\t</div>\n\t\t</div>\t\t\t\t\t\t\t\t\t\t\t</div>"}}]}},"pageContext":{"alternative_id":12073}}