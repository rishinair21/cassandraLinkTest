{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Designing a Cassandra Data Model","alternative_id":11066,"content":"<p>Cassandra is an open source, distributed database. It’s useful for managing large quantities of data across multiple data centers as well as the cloud.</p><h3 id=\"cassandra-data-model\">Cassandra data model</h3><p>Cassandra’s data model consists of keyspaces, column families, keys, and columns. The table below compares each part of the Cassandra data model to its analogue in a relational data model.</p><table><thead><tr><th><strong>Cassandra Data Model</strong></th>\n<th><strong>Relational Data Model</strong></th>\n</tr></thead><tbody><tr><td>Keyspace</td>\n<td>Database</td>\n</tr><tr><td>Column Family</td>\n<td>Table</td>\n</tr><tr><td>Partition Key</td>\n<td>Primary Key</td>\n</tr><tr><td>Column Name/Key</td>\n<td>Column Name</td>\n</tr><tr><td>Column Value</td>\n<td>Column Value</td>\n</tr></tbody></table><h3 id=\"how-cassandra-organizes-data\">How Cassandra organizes data</h3><p>Cassandra organizes data into partitions. Each partition consists of multiple columns. Partitions are stored on a node. Nodes are generally part of a cluster where each node is responsible for a fraction of the partitions.</p><p>When inserting records, Cassandra will hash the value of the inserted data’s partition key; Cassandra uses this hash value to determine which node is responsible for storing the data.</p><h3 id=\"where-are-the-rows\">Where are the rows?</h3><p>Cassandra is a column data store, meaning that each partition key has a set of one or more columns. Let’s say we have a list of fruits:</p><ul><li>[Apple, Banana, Orange, Pear]</li>\n</ul><p>We create a column family of fruits, which is essentially the same as a table in the relational model. Inside our column family, Cassandra will hash the name of each fruit to give us the partition key, which is essentially the primary key of the fruit in the relational model.</p><p>Now things start to diverge from the relational model. Cassandra will store each fruit on its own partition, since the hash of each fruit’s name will be different. Because each fruit has its own partition, it doesn’t map well to the concept of a row, as Cassandra has to issue commands to potentially four separate nodes to retrieve all data from the fruit column family.</p><p>We’ll get into more details later, but for now it’s enough to know that for Cassandra to look up a set of data (or a set of rows in the relational model), we have to store all of the data under the same partition key. To summarize, rows in Cassandra are essentially data embedded within a partition due to the fact that the data share the same partition key.</p><h3 id=\"data-model-goals\">Data model goals</h3><ol><li>Spread data evenly around the cluster. Paritions are distributed around the cluster based on a hash of the partition key. To distribute work across nodes, it’s desirable for every node in the cluster to have roughly the same amount of data.</li>\n<li>Minimize the number of partitions read. Partitions are groups of columns that share the same partition key. Since each partition may reside on a different node, the query coordinator will generally need to issue separate commands to separate nodes for each partition we query.</li>\n<li>Satisfy a query by reading a single partition. This means we will use roughly one table per query. Supporting multiple query patterns usually means we need more than one table. Data duplication is encouraged.</li>\n</ol><h3 id=\"components-of-the-cassandra-data-model\">Components of the Cassandra data model</h3><p><strong>Column family</strong></p><p>Column families are established with the CREATE TABLE command. Column families are represented in Cassandra as a map of sorted maps. The partition key acts as the lookup value; the sorted map consists of column keys and their associated values.</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">Map&lt;ParitionKey, SortedMap&lt;ColumnKey, ColumnValue&gt;&gt;</pre></div><p><strong>Partition key</strong></p><p>The partition key is responsible for distributing data among nodes. A partition key is the same as the primary key when the primary key consists of a single column.</p><p><img src=\"https://shermandigital.com/img/blog/cassandra-partition.png\" alt=\"Cassandra partition\" /></p><p>Partition keys belong to a node. Cassandra is organized into a cluster of nodes, with each node having an equal part of the partition key hashes.</p><p>Imagine we have a four node Cassandra cluster. In the example cluster below, Node 1 is responsible for partition key hash values 0-24; Node 2 is responsible for partition key hash values 25-49; and so on.</p><p><img src=\"https://shermandigital.com/img/blog/cassandra-cluster.png\" alt=\"Cassandra cluster\" /></p><p><strong>Replication factor</strong></p><p>Depending on the replication factor configured, data written to Node 1 will be replicated in a clockwise fashion to its sibling nodes. So in our example above, assume we have a four-node cluster with a replication factor of three. When we insert data with a partition key of 23, the data will get written to Node 1 and replicated to Node 2 and Node 3. When we insert data with a partition key of 88, the data will get written to Node 4 and replicated to Node 1 and Node 2.</p><p><strong>Compound key</strong></p><p>Compound keys include multiple columns in the primary key, but these additional columns do not necessarily affect the partition key. A partition key with multiple columns is known as a composite key and will be discussed later.</p><p>Let’s borrow an example from <a href=\"https://twitter.com/AdamHutson\">Adam Hutson’s</a> excellent <a href=\"http://datascale.io/cassandra-data-model-basics/\">blog on Cassandra data modeling</a>. Consider a Cassandra database that stores information on CrossFit gyms. One property of CrossFit gyms is that each gym must have a unique name i.e. no two gyms are allowed to share the same name.</p><p>The table below is useful for looking up a gym when we know the name of the gym we’re looking for.</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">CREATE TABLE crossfit_gyms (  \n   gym_name text,  \n   city text,  \n   state_province text,  \n   country_code text,  \n   PRIMARY KEY (gym_name)  \n);</pre></div><p>Now suppose we want to look up gyms by location. If we use the crossfit_gyms table, we’ll need to iterate over the entire result set. Instead, we’ll create a new table that will allow us to query gyms by country.</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">CREATE TABLE crossfit_gyms_by_location (  \n   country_code text,  \n   state_province text,  \n   city text,  \n   gym_name text,  \n   PRIMARY KEY (country_code, state_province, city, gym_name)  \n);</pre></div><p>Note that only the first column of the primary key above is considered the partition key; the rest of columns are clustering keys. This means that while the primary key represents a unique gym record/row, all gyms within a country reside on the same partition. So when we query the crossfit_gyms_by_location table, we receive a result set consisting of every gym sharing a given country_code. While useful for searching gyms by country, using this table to identify gyms within a particular state or city requires iterating over all gyms within the country in which the state or city is located.</p><p><strong>Clustering key</strong></p><p>Clustering keys are responsible for sorting data within a partition. Each primary key column after the partition key is considered a clustering key. In the crossfit_gyms_by_location example, country_code is the partition key; state_province, city, and gym_name are the clustering keys. Clustering keys are sorted in ascending order by default. So when we query for all gyms in the United States, the result set will be ordered first by state_province in ascending order, followed by city in ascending order, and finally gym_name in ascending order.</p><p><strong>Order by</strong></p><p>To sort in descending order, add a WITH clause to the end of the CREATE TABLE statement.</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">CREATE TABLE crossfit_gyms_by_location (  \n   country_code text,  \n   state_province text,  \n   city text,  \n   gym_name text,  \n   PRIMARY KEY (country_code, state_province, city, gym_name)  \n) WITH CLUSTERING ORDER BY (state_province DESC, city ASC, gym_name ASC);</pre></div><p> The result set will now contain gyms ordered first by state_province in descending order, followed by city in ascending order, and finally gym_name in ascending order. You must specify the sort order for each of the clustering keys in the ORDER BY statement. The partition key is not part of the ORDER BY statement because its values are hashed and therefore won’t be close to each other in the cluster.</p><p><strong>Composite key</strong></p><p>Composite keys are partition keys that consist of multiple columns. The crossfit_gyms_by_location example only used country_code for partitioning. The result is that all gyms in the same country reside within a single partition. This can lead to wide rows. In the case of our example, there are over 7,000 CrossFit gyms in the United States, so using the single column partition key results in a row with over 7,000 combinations.</p><p>To avoid wide rows, we can move to a composite key consisting of additional columns. If we change the partition key to include the state_province and city columns, the partition hash value will no longer be calculated off only country_code. Now, each combination of country_code, state_province, and city will have its own hash value and be stored in a separate partition within the cluster. We accomplish this by nesting parenthesis around the columns we want included in the composite key. </p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">CREATE TABLE crossfit_gyms_by_city (  \n country_code text,  \n state_province text,  \n city text,  \n gym_name text,  \n opening_date timestamp,  \n PRIMARY KEY ((country_code, state_province, city), opening_date, gym_name)  \n) WITH CLUSTERING ORDER BY ( opening_data ASC, gym_name ASC );</pre></div><p>Notice that we are no longer sorting on the partition key columns. Each combination of the partition keys is stored in a separate partition within the cluster.</p><p>When issuing a CQL query, you must include all partition key columns, at a minimum. You can then apply an additional filter by adding each clustering key in the order in which the clustering keys appear. Below you can see valid queries and invalid queries from our crossfit_gyms_by_city example.</p><p><strong>Valid queries:</strong></p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">SELECT * FROM crossfit_gyms_by_city WHERE country_code = 'USA' and state_province = 'VA' and city = 'Arlington'</pre></div><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">SELECT * FROM crossfit_gyms_by_city WHERE country_code = 'USA' and state_province = 'VA' and city = 'Arlington' and opening_date &lt;  '2015-01-01 00:00:00+0200'</pre></div><p><strong>Invalid queries:</strong></p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">SELECT * FROM crossfit_gyms_by_city WHERE country_code = 'USA' and state_province = 'VA'</pre></div><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">SELECT * FROM crossfit_gyms_by_city WHERE country_code = 'USA' and state_province = 'VA' and city = 'Arlington' and gym_name = 'CrossFit Route 7'</pre></div><p>The first invalid query is missing the city partition key column. The second invalid query uses the clustering key gym_name without including the preceding clustering key opening_date.</p><p>The reason the order of clustering keys matters is because the clustering keys provide the sort order of the result set. Because of the clustering key’s responsibility for sorting, we know all data matching the first clustering key will be adjacent to all other data matching that clustering key.</p><p>In our example, this means all gyms with the same opening date will be grouped together in alphabetical order. Gyms with different opening dates will appear in temporal order.</p><p>Because we know the order, CQL can easily truncate sections of the partition that don’t match our query to satisfy the WHERE conditions pertaining to columns that are not part of the partition key. However, because the clustering key gym_name is secondary to clustering key opening_date, gyms will appear in alphabetical order only for gyms opened on the same day (within a particular city, in this case). Therefore, we can’t specify the gym name in our CQL query without first specifying an opening date.</p><h3 id=\"internal-data-structure\">Internal data structure</h3><p>If we create a column family (table) with CQL:</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">CREATE TABLE crossfit_gyms (  \n gym_name text PRIMARY KEY,  \n country_code text,  \n state_province text,  \n city text  \n);</pre></div><p> And insert a row:</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">INSERT INTO crossfit_gyms (country_code, state_province, city, gym_name) VALUES ('USA', 'CA', 'San Francisco', 'San Francisco CrossFit');</pre></div><p>Assuming we don’t encode the data, it is stored internally as:</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">Partition Key: San Francisco CrossFit  \n=&gt;(column=, value=, timestamp=1374683971220000)  \n=&gt;(column=city, value='San Francisco', timestamp=1374683971220000)  \n=&gt;(column=country_code, value='USA', timestamp=1374683971220000)  \n=&gt;(column=state_province, value='CA', timestamp=1374683971220000)</pre></div><p>You can see that the partition key is used for lookup. In this case the first column is also the partition key, so Cassandra does not repeat the value. The next three columns hold the associated column values.</p><p>If we use a composite key, the internal structure changes a bit. Let’s start with a general example borrowed from <a href=\"https://www.gitbook.com/@teddyma\">Teddy Ma’s</a> <a href=\"https://teddyma.gitbooks.io/learncassandra/content/index.html\">step-by-step guide to learning Cassandra</a>.</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">CREATE TABLE example (\n    partitionKey1 text,\n    partitionKey2 text,\n    clusterKey1 text,\n    clusterKey2 text,\n    normalField1 text,\n    normalField2 text,\n    PRIMARY KEY (\n        (partitionKey1, partitionKey2),\n        clusterKey1, clusterKey2\n        )\n    );</pre></div><p>And insert a row:</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">INSERT INTO example (\n    partitionKey1,\n    partitionKey2,\n    clusterKey1,\n    clusterKey2,\n    normalField1,\n    normalField2\n    )  VALUES (\n    'partitionVal1',\n    'partitionVal2',\n    clusterVal1',\n    'clusterVal2',\n    'normalVal1',\n    'normalVal2');</pre></div><p>This data is stored internally as:</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">RowKey: partitionVal1:partitionVal2\n=&gt; (column=clusterVal1:clusterVal2:, value=, timestamp=1374630892473000)\n=&gt; (column=clusterVal1:clusterVal2:normalfield1, value=6e6f726d616c56616c31, timestamp=1374630892473000)\n=&gt; (column=clusterVal1:clusterVal2:normalfield2, value=6e6f726d616c56616c32, timestamp=1374630892473000)</pre></div><p>The composite key columns are concatenated to form the partition key (RowKey). The clustering keys are concatenated to form the first column and then used in the names of each of the following columns that are not part of the primary key. The actual values we inserted into normalField1 and normalField2 have been encoded, but decoding them results in normalValue1 and normalValue2, respectively.</p><p>Now we can adapt this to our CrossFit example.</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">CREATE TABLE crossfit_gyms_by_state (  \n   country_code text,  \n   state_province text,  \n   city text,  \n   gym_name text,  \n   opening_date timestamp,  \n   street text,  \n   PRIMARY KEY (  \n      (country_code, state_province),  \n      city, gym_name  \n   )  \n);</pre></div><p>And insert a row:</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">INSERT INTO crossfit_gyms_by_state (  \n   country_code,   \n   state_province,   \n   city,   \n   gym_name,   \n   opening_date,  \n   street  \n)   \nVALUES (  \n   'USA',   \n   'CA',  \n   'San Francisco',   \n   'San Francisco CrossFit',  \n   '2015-01-01 00:00:00+0200',  \n   '1162A Gorgas Ave');\n   </pre></div><p>For the sake of readability, I won’t encode the values of the columns. The internal structure is approximately:</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">Partition Key: USA:CA  \n=&gt;(column='San Francisco':'San Francisco CrossFit', value=, timestamp=1374683971220000)  \n=&gt;(column='San Francisco':'San Francisco CrossFit':'​opening_date', value='2015-01-01 00:00:00+0200', timestamp=1374683971220000)  \n=&gt;(column='San Francisco':'San Francisco CrossFit':'​street', value='1162A Gorgas Ave', timestamp=1374683971220000)</pre></div><p>Finally, we’ll show how Cassandra represents sets, lists, and maps internally. Once again, we’ll use an example from <a href=\"https://www.gitbook.com/@teddyma\">Teddy Ma’s</a> <a href=\"https://teddyma.gitbooks.io/learncassandra/content/index.html\">step-by-step guide to learning Cassandra</a>.</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">CREATE TABLE example (  \n   key1 text PRIMARY KEY,  \n   map1 map&lt;text,text&gt;,  \n   list1 list&lt;text&gt;,  \n   set1 set&lt;text&gt;  \n);</pre></div><p>Insert a row:</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">INSERT INTO example (  \n   key1,  \n   map1,  \n   list1,  \n   set1  \n) VALUES (  \n   'john',  \n   {'patricia':'555-4326','doug':'555-1579'},  \n   ['doug','scott'],  \n   {'patricia','scott'}  \n);</pre></div><p>Internally:</p><div class=\"highlight\"><pre class=\"language-bash\" data-lang=\"bash\">RowKey: john  \n=&gt; (column=, value=, timestamp=1374683971220000)  \n=&gt; (column=map1:doug, value='555-1579', timestamp=1374683971220000)  \n=&gt; (column=map1:patricia, value='555-4326', timestamp=1374683971220000)  \n=&gt; (column=list1:26017c10f48711e2801fdf9895e5d0f8, value='doug', timestamp=1374683971220000)  \n=&gt; (column=list1:26017c12f48711e2801fdf9895e5d0f8, value='scott', timestamp=1374683971220000)  \n=&gt; (column=set1:'patricia', value=, timestamp=1374683971220000)  \n=&gt; (column=set1:'scott', value=, timestamp=1374683971220000)</pre></div><p>To store maps, Cassandra adds a column for each item in the map. The column name is a concatenation of the the column name and the map key. The value is the key’s value.</p><p>To store lists, Cassandra adds a column for each entry in the list. The column name is a concatenation of the the column name and a UUID generated by Cassandra. The value is the value of the list item.</p><p>To store sets, Cassandra adds a column for each entry. The column name is a concatenation of the the column name and the entry value. Cassandra does not repeat the entry value in the value, leaving it empty.</p><h3 id=\"conclusion\">Conclusion</h3><p>You now have enough information to begin designing a Cassandra data model. Remember to work with the unstructured data features of Cassandra rather than against them. Designing a data model for Cassandra can be an adjustment coming from a relational database background, but the ability to store and query large quantities of data at scale make Cassandra a valuable tool.</p><h3 id=\"appendix\">Appendix</h3><p><strong>Cassandra Features</strong></p><ul><li>Continuous availability. The peer-to-peer replication of data to nodes within a cluster results in no single point of failure. This is true even across data centers.</li>\n<li>Linear performance when scaling nodes in a cluster. If three nodes are achieving 3,000 writes per second, adding three more nodes will result in a cluster of six nodes achieving 6,000 writes per second.</li>\n<li>Tunable consistency. If we want to replicate data across three nodes, we can have a replication factor of three, yet not necessarily wait for all three nodes to acknowledge the write. Data will eventually be written to all three nodes, but we can acknowledge the write after writing the data to one or more nodes without waiting for the full replication to finish.</li>\n<li>Flexible data model. Every row can have a different number of columns with support for many types of data.</li>\n<li>Query language (CQL) with a SQL-like syntax.</li>\n<li>Support for Java Monitoring Extensions (JMX). Metrics about performance, latency, system usage, etc. are available for consumption by other applications.</li>\n</ul><p><strong>Cassandra Limitations</strong></p><ul><li>No join or subquery support for aggregation. According to Cassandra’s documentation, this is by design, encouraging denormalization of data into partitions that can be queried efficiently from a single node, rather than gathering data from across the entire cluster.</li>\n<li>Ordering is set at table creation time on a per-partition basis. This avoids clients attempting to sort billions of rows at run time.</li>\n<li>All data for a single partition must fit on disk in a single node in the cluster.</li>\n<li>It’s recommended to keep the number of rows within a partition below 100,000 items and the disk size under 100 MB.</li>\n<li>A single column value is limited to 2 GB (1 MB is recommended).</li>\n</ul><p>A less obvious limitation of Cassandra is its lack of row-level consistency. Modifications to a column family (table) that affect the same row and are processed with the same timestamp will result in a tie.</p><p>In the event of a tie Cassandra follows two rules:</p><ol><li>Deletes take precedence over inserts/updates.</li>\n<li>If there are two updates, the one with the lexically larger value wins.</li>\n</ol><p>This means for inserts/updates, Cassandra resolves row-level ties by comparing values at the column (cell) level, writing the greater value. This can result in one update modifying one column while another update modifies another column, resulting in rows with combinations of values that never existed.</p><p class=\"margin-top-25\">\n<i class=\"fa fa-tag color-medium-gray\">\n<a href=\"https://shermandigital.com/tags/cassandra\" class=\"margin-right-10\">\nCassandra\n</a>\n</i></p><noscript><p>Please enable JavaScript to view the <a href=\"https://disqus.com/?ref_noscript\">comments powered by Disqus.</a></p></noscript>"}}]}},"pageContext":{"alternative_id":11066}}