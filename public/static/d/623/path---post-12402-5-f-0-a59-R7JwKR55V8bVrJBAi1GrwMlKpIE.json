{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Hardening Cassandra Step by Step - Part 1 Inter-Node Encryption (And a Gentle Intro to Certificates)","alternative_id":12402,"content":"<h2 id=\"tldr\">TL;DR:</h2><p>This is a tutorial extracted from part of a presentation I gave at Cassandra Summit 2015 titled <a href=\"http://cassandrasummit-datastax.com/agenda/hardening-apache-cassandra-for-compliance-or-paranoia/\">Hardening Cassandra for Compliance (or Paranoia)</a>. The <a href=\"http://www.slideshare.net/zznate/hardening-cassandra-for-compliance-or-paranoia\">slides</a> are available and the “SSL Certificates: a brief interlude” section is probably the most expedient route if you are impatient. We build on that process here by actually installing everything on a local three node cluster. I’ll provide a link to the video of the presentation as soon as it is posted.</p>\n<h2 id=\"overview\">Overview</h2>\n<p>This is the first of a five part tutorial covering the following aspects of securing Apache Cassandra (including some handy features of DataStax Enterprise where relevant). As with the presentation mentioned above, we will break this down into the following:</p>\n<ul><li><strong>Inter-node Communication</strong></li>\n  <li>Encryption at Rest</li>\n  <li>Client-Server Communication</li>\n  <li>Authentication and Authorization</li>\n  <li>Management and Tooling</li>\n</ul><p>Being further down the stack, most developers are not exposed to encryption in their day to day work. Therefor this first post will focus on Inter-node encryption. It is going to be a bit longer than the others as this post walks through the steps to <em>correctly</em> create SSL certificates. We’ll put that knowledge to immediate use by configuring inter-node encryption on a local CCM cluster. Hopefully this tutorial will give you enough information to make the correct choices.</p>\n<p>The <a href=\"http://docs.datastax.com/en/cassandra/2.1/cassandra/security/secureSSLCertificates_t.html\">current documentation</a> describes a  basic approach that is useful for development and experimentation. However, were these steps used in building a production deployment, they would create a substantial maintenance burden and be quite difficult to automate. These concerns would be amplified by the need to scale out.  Most importantly, if followed directly, you will have secured traffic, but have done nothing to thwart a bad actor with network access from attacking your cluster directly.</p>\n<p>Why is this? Because like most examples of generating certificates and configuring SSL, the documentation still holds to the model of a client, like a web browser, talking to a server. In this model, the main concern is that the client is validating the identity of the web server and that the data is secured in transit. The client simply sends a public key to the server identifying itself so they can negotiate a secured connection. The server has no trust relationship with that client, it’s just using the certificate to encrypt the communication.</p>\n<p>Grafting this onto our cluster model, it means that a Cassandra node will open secure sockets with other nodes, but not attempt to identify the actor requesting the connection. Think about that for a second. Without authenticating that we are indeed talking to another Cassandra node, we can write a program to attach to a cluster and execute arbitrary commands, listen to writes on arbitrary token ranges, even inject an administrator account into the <code class=\"highlighter-rouge\">system_auth</code> table with specially crafted message packets. In short, we can do pretty much anything. The best part: the communication between our program and the cluster will be via SSL, so no one will know it’s happening.</p>\n<p>Instead, the model we want to follow is called Client Certificate Authentication. Using this approach, the server takes the extra step of verifying the client against a local trust store (see <a href=\"http://javarevisited.blogspot.com/2012/09/difference-between-truststore-vs-keyStore-Java-SSL.html\">this page</a> for an excellent description of both trust stores and key stores in the context of the JDK). If it does not recognize the client’s certificate either directly or through a chain of trust, it will not accept the connection. The extra verification can be enabled with a single flag in Cassandra’s configuration : <code class=\"highlighter-rouge\">require_client_auth: true</code>.</p>\n<p>Setting this option (as we’ll see in the steps below) enables Client Certificate Authentication as previously discussed. For encrypting inter-node traffic for our cluster, it means that each node has a trust relationship with the rest of the cluster which can be verified against a local Trust Store.</p>\n<p>To demonstrate how to create and install all the components for this, we are going to walk through all the steps necessary to set up inter node encryption in a way that will make it both easy to manage and production deployable.</p>\n<h2 id=\"creating-a-three-node-test-cluster\">Creating a Three Node Test Cluster</h2>\n<p>We’ll start by using <code class=\"highlighter-rouge\">ccm</code> to create a three node cluster which we’ll use to walk through SSL setup. If you are not familiar with <code class=\"highlighter-rouge\">ccm</code>, you can find information and installation instructions <a href=\"https://github.com/pcmanus/ccm\">here</a>.</p>\n<p>Provided you have <code class=\"highlighter-rouge\">ccm</code> setup and configured correctly, the following commands will create and start an Apache Cassandra cluster named <code class=\"highlighter-rouge\">sslverify</code> using Apache Cassandra version <code class=\"highlighter-rouge\">2.1.9</code>:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>ccm create -n 3 -v 2.1.9 sslverify\nccm start\n</pre></div></div>\n<p>Configuration and data for each of the three nodes in the cluster will be placed in sub directories under <code class=\"highlighter-rouge\">~/.ccm/sslverify/</code> following the convention of a normal Cassandra distribution from there on.</p>\n<p>You can verify the cluster’s status from both the <code class=\"highlighter-rouge\">ccm</code> and Cassandra perspectives with:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>ccm status\nccm node1 nodetool status\n</pre></div></div>\n<p>Note: to use a Cassandra command directly, move into the directory for a node and execute the command as you would on any local installation. For example, the following commands would have the same effect as the <code class=\"highlighter-rouge\">ccm</code> wrapped version above:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>cd ~/.ccm/sslverify/node1\n./bin/nodetool status\n</pre></div></div>\n<p>With our cluster in place, it’s time to move on to certificate management.</p>\n<p>When dealing with even a small cluster, creating our own Certificate Authority (CA) becomes essential to minimizing trust chain complexity. This allows us to create a Root Certificate that can be used to sign all of our server-specific certificates. Once signed, this creates a trust chain that will make managing the certificates significantly easier. We’ll go into further detail on this below.</p>\n<p>We will be using OpenSSL for create the Certificate Authority (CA) and sign certificate requests with such. The <code class=\"highlighter-rouge\">openssl</code> tool should be available on most UNIX-derived systems. For this tutorial, I was using <code class=\"highlighter-rouge\">OpenSSL 1.0.1j 15 Oct 2014</code> on OS X <code class=\"highlighter-rouge\">10.10.5</code>.</p>\n<p>For the first step, create the CA using the following configuration file titled <code class=\"highlighter-rouge\">gen_ca_cert.conf</code> in the current directory:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>[ req ]\ndistinguished_name     = req_distinguished_name\nprompt                 = no\noutput_password        = mypass\ndefault_bits           = 2048\n[ req_distinguished_name ]\nC                      = US\nST                     = TX\nL                      = Austin\nO                      = TLP\nOU                     = TestCluster\nCN                     = TestClusterMasterCA\nemailAddress           = info@thelastpickle.com\n</pre></div></div>\n<p>Obviously, you’ll want to put your specific information in there. When I create a CA for Cassandra, I like to use the the name of the cluster for the Organizational Unit (OU) and specify that it is our cluster CA via the Common Name (CN) attribute. This is of course a matter of personal preference. The take away is to pick something that will make managing these easy.</p>\n<p>Now, run the following OpenSSL command to create the CA:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>openssl req -config gen_ca_cert.conf -new -x509 -keyout ca-key -out ca-cert -days 365\n</pre></div></div>\n<p>There is a lot going on here, so let’s break that one down:</p>\n<ul><li><code class=\"highlighter-rouge\">req</code>: An OpenSSL sub-command saying that we are (in this case) creating a <a href=\"https://www.openssl.org/docs/manmaster/apps/req.html\">PKCS#10 X.509 Certificate</a>. Note: the following parameters are all options of the <code class=\"highlighter-rouge\">req</code> command</li>\n  <li><code class=\"highlighter-rouge\">-config</code>: The path to the config file above to avoid having to provide information on STDIN</li>\n  <li><code class=\"highlighter-rouge\">-new</code>: This is a new signing request we are making</li>\n  <li><code class=\"highlighter-rouge\">-x509</code>: The output will be an <a href=\"https://en.wikipedia.org/wiki/X.509\">X.509</a> compatible self-signed certificate we can use as a root CA</li>\n  <li><code class=\"highlighter-rouge\">-keyout</code>: The filename to which we will write our key</li>\n  <li><code class=\"highlighter-rouge\">-out</code>: The filename to which we will write our certificate</li>\n  <li><code class=\"highlighter-rouge\">-days</code>: The number of days for which the generated certificate will be valid</li>\n</ul><p>You can verify the contents of the certificate you just created with the following command:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>openssl x509 -in ca-cert -text -noout\n</pre></div></div>\n<h3 id=\"per-server-certificate-creation\">Per-Server Certificate Creation</h3>\n<p>Now we will create a public/private key pair for each server using the built-in <a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html\">keytool utility</a> (<em>note</em>: I used JDK 8 for this tutorial, in which <code class=\"highlighter-rouge\">keytool</code> has had a bit of a revamp - see the previous link for details).</p>\n<p>In the process of doing this step, we are creating the node-specific key stores which will be distributed directly to those nodes in a later step. We’ve used the node names from the <code class=\"highlighter-rouge\">ccm</code> cluster we created previously as part of our naming scheme:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>keytool -genkeypair -keyalg RSA -alias node1 -keystore node1-server-keystore.jks -storepass awesomekeypass -keypass awesomekeypass -validity 365 -keysize 2048 -dname \"CN=node1, OU=SSL-verification-cluster, O=TheLastPickle, C=US\"\nkeytool -genkeypair -keyalg RSA -alias node2 -keystore node2-server-keystore.jks -storepass awesomekeypass -keypass awesomekeypass -validity 365 -keysize 2048 -dname \"CN=node2, OU=SSL-verification-cluster, O=TheLastPickle, C=US\"\nkeytool -genkeypair -keyalg RSA -alias node3 -keystore node3-server-keystore.jks -storepass awesomekeypass -keypass awesomekeypass -validity 365 -keysize 2048 -dname \"CN=node3, OU=SSL-verification-cluster, O=TheLastPickle, C=US\"\n</pre></div></div>\n<p>As with the OpenSSL incantation above, let’s summarize what we are doing for each node:</p>\n<ul><li><code class=\"highlighter-rouge\">-genkeypair</code>: the keytool command to generate a public/private key pair combination</li>\n  <li><code class=\"highlighter-rouge\">-keyalg</code>: The algorithm to use, RSA in this case</li>\n  <li><code class=\"highlighter-rouge\">-alias</code>: An alias to use for this public/private key pair, <code class=\"highlighter-rouge\">alias</code> is used to identify the public key when imported into a key store. I usually use some form of $hostname-cassandra</li>\n  <li><code class=\"highlighter-rouge\">-keystore</code>: The location of our key store (created if it does not already exist)</li>\n  <li><code class=\"highlighter-rouge\">-storepass</code>: The password for the key store</li>\n  <li><code class=\"highlighter-rouge\">-keypass</code>: The password for the key</li>\n  <li><code class=\"highlighter-rouge\">-validity</code>: The number of days for which this key pair will be valid</li>\n  <li><code class=\"highlighter-rouge\">-keysize</code>: The size of the key to generate</li>\n  <li><code class=\"highlighter-rouge\">-dname</code>: See below</li>\n</ul><p>The arguments to <code class=\"highlighter-rouge\">-dname</code> can be summarized as follows: the subject’s common name (CN), organizational unit (OU), organization (O), and country (C). In this context, it’s a good idea to make the CN the hostname. For OU, I like to use the same string as the <code class=\"highlighter-rouge\">cluster_name</code> attribute in <code class=\"highlighter-rouge\">cassandra.yaml</code> as a personal preference. The other attributes are straight forward, but can be whatever given this is all self-signed. Just be consistent with them.</p>\n<p>As with the CA we created earlier on, we should verify that the key store is accessible and contains the key pair with the correct information:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>keytool -list -v -keystore node1-server-keystore.jks -storepass awesomekeypass\n</pre></div></div>\n<h3 id=\"some-things-to-note\">Some Things to Note</h3>\n<p>The <code class=\"highlighter-rouge\">-genkeypair</code> sub-command can also take a <code class=\"highlighter-rouge\">-startdate</code> option which is handy when you know you are making a configuration change at some point in the future. If used, the <code class=\"highlighter-rouge\">-validity</code> is then calculated as being from that point in time onwards.</p>\n<p>There is currently a limitation in Cassandra which forces us to use the same password for the key store as for the key. In all fairness, <code class=\"highlighter-rouge\">javax.security</code> is a very obtuse API with which to work. Specifically, loading individual certificates with different passwords from a key store is shockingly cumbersome, particularly if one or more of those entries is based on a trust chain.</p>\n<p>Using the <code class=\"highlighter-rouge\">CN</code> attribute for the hostname is considered deprecated in the context of <a href=\"https://en.wikipedia.org/wiki/Public_key_infrastructure\">PKI</a>. You can enable DNS hostname verification (referred to as “Subject Alternative Name” in PKI parlance), but since we building our own CA for private consumption, I consider it overkill for this case. Nevertheless, if you want to do this, simply append <code class=\"highlighter-rouge\">-ext SAN=DNS:thelastpickle.com</code> to the <code class=\"highlighter-rouge\">keytool</code> invocation above. You’ll have to do the same when generating the CA as well (see the <a href=\"http://thelastpickle.com/blog/2015/09/30/hardening-cassandra-step-by-step-part-1-server-to-server.html\">OpenSSL documentation</a> for details).</p>\n<h3 id=\"export-certificates-as-signing-requests\">Export Certificates as Signing Requests</h3>\n<p>With our key stores created and populated, we now need to export a certificates from each node’s key store as a “Signing Request” for our CA:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>keytool -keystore node1-server-keystore.jks -alias node1 -certreq -file node1_cert_sr -keypass awesomekeypass -storepass awesomekeypass\nkeytool -keystore node2-server-keystore.jks -alias node2 -certreq -file node2_cert_sr -keypass awesomekeypass -storepass awesomekeypass\nkeytool -keystore node3-server-keystore.jks -alias node3 -certreq -file node3_cert_sr -keypass awesomekeypass -storepass awesomekeypass\n</pre></div></div>\n<p>We’ve seen two new <code class=\"highlighter-rouge\">keytool</code> options here which we’ll briefly describe:</p>\n<ul><li><code class=\"highlighter-rouge\">-certreq</code> another <code class=\"highlighter-rouge\">keytool</code> sub-command, this says to export the certificate specifically for signing by a CA</li>\n  <li><code class=\"highlighter-rouge\">-file</code> specifies the file to which the signing request will be written</li>\n</ul><h3 id=\"sign-each-certificate-with-the-cas-public-key\">Sign Each Certificate with the CA’s Public Key</h3>\n<p>With the certificate signing requests ready to go, it’s now time to sign each with our CA’s public key via OpenSSL:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>openssl x509 -req -CA ca-cert -CAkey ca-key -in node1_cert_sr -out node1_cert_signed -days 365 -CAcreateserial -passin pass:mypass\nopenssl x509 -req -CA ca-cert -CAkey ca-key -in node2_cert_sr -out node2_cert_signed -days 365 -CAcreateserial -passin pass:mypass\nopenssl x509 -req -CA ca-cert -CAkey ca-key -in node3_cert_sr -out node3_cert_signed -days 365 -CAcreateserial -passin pass:mypass\n</pre></div></div>\n<p>This OpenSSL incantation is quite a bit different than our the one for creating a CA above, so we’ll again summarize:</p>\n<ul><li><code class=\"highlighter-rouge\">x509</code> Use the display and <a href=\"https://www.openssl.org/docs/manmaster/apps/x509.html\">signing subcommand</a></li>\n  <li><code class=\"highlighter-rouge\">-req</code> We are signing a certificate request as opposed to a certificate</li>\n  <li><code class=\"highlighter-rouge\">-CA</code> The certificate file we specified via the <code class=\"highlighter-rouge\">-out</code> parameter used when creating our CA</li>\n  <li><code class=\"highlighter-rouge\">-CAKey</code> The key file we specified via the <code class=\"highlighter-rouge\">-keyout</code> parameter used when creating our CA</li>\n  <li><code class=\"highlighter-rouge\">-in</code> The per-node certificate request we are signing; this was the <code class=\"highlighter-rouge\">-file</code> parameter from the Signing Request step above</li>\n  <li><code class=\"highlighter-rouge\">-out</code> The newly-signed certificate file to create (use a clear naming scheme to keep track of files)</li>\n  <li><code class=\"highlighter-rouge\">-days</code> The number of days for which the signed certificate will be valid</li>\n  <li><code class=\"highlighter-rouge\">-CAcreateserial</code> Create a serialnumber for this CSR (see the doc <code class=\"highlighter-rouge\">openssl x509</code> documentation above, it’s complicated)</li>\n  <li><code class=\"highlighter-rouge\">-passin</code> The keypassword source. The arguments to <code class=\"highlighter-rouge\">passin</code> have their own <a href=\"https://www.openssl.org/docs/manmaster/apps/openssl.html\">formatting instructions</a> with which you should become familiar</li>\n</ul><h3 id=\"add-the-ca-to-the-key-store\">Add the CA to the Key Store</h3>\n<p>With the certificates now signed, we will need to re-import them back into each node’s key store via the <code class=\"highlighter-rouge\">-import</code> sub-command of <code class=\"highlighter-rouge\">keytool</code>. However, before we can do that, we have to add the certificate from our CA to each key store. This step is required for the trust chain to function correctly.</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>keytool -keystore node1-server-keystore.jks -alias CARoot -import -file ca-cert -noprompt -keypass awesomekeypass -storepass awesomekeypass\nkeytool -keystore node2-server-keystore.jks -alias CARoot -import -file ca-cert -noprompt -keypass awesomekeypass -storepass awesomekeypass\nkeytool -keystore node3-server-keystore.jks -alias CARoot -import -file ca-cert -noprompt -keypass awesomekeypass -storepass awesomekeypass\n</pre></div></div>\n<p>With each key store now containing our CA, we can import the signed certificate with the same alias back into the key store:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>keytool -keystore node1-server-keystore.jks -alias node1 -import -file node1_cert_signed -keypass awesomekeypass -storepass awesomekeypass\nkeytool -keystore node2-server-keystore.jks -alias node2 -import -file node2_cert_signed -keypass awesomekeypass -storepass awesomekeypass\nkeytool -keystore node3-server-keystore.jks -alias node3 -import -file node3_cert_signed -keypass awesomekeypass -storepass awesomekeypass\n</pre></div></div>\n<h3 id=\"building-the-trust-store\">Building the Trust Store</h3>\n<p>Our key store is now all set. But since we are using Client Certificate Authentication, we need to add a trust store to each node. This is how each node will verify incoming connections from the rest of the cluster.</p>\n<p>All we need to do is create trust store by importing CA root certificate’s public key:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>keytool -keystore generic-server-truststore.jks -alias CARoot -importcert -file ca-cert -keypass mypass -storepass truststorepass -noprompt\n</pre></div></div>\n<p>Now this is where it all comes together. Since all of our instance-specific keys have now been signed by the CA, we can share this trust store instance across the cluster as it effectively just says “I’m going to trust all connections whose client certificates were signed by this CA.” This is the same way that an authority like Verisign works when you get a commercial certificate for your web server. We are in this case just acting as our own authority (which is the safest approach when creating public key infrastructure for your internal services).</p>\n<h3 id=\"configuring-the-cluster\">Configuring the Cluster</h3>\n<p>So now that we have all of our files created, let’s place them where they go so CCM can find them. First, we’ll move the key stores:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>cp node1-server-keystore.jks ~/.ccm/sslverify/node1/conf/server-keystore.jks\ncp node2-server-keystore.jks ~/.ccm/sslverify/node2/conf/server-keystore.jks\ncp node3-server-keystore.jks ~/.ccm/sslverify/node3/conf/server-keystore.jks\n</pre></div></div>\n<p>Note: we make the target name here generic for the sake of convention as this is what you would do with a CM system anyway.</p>\n<p>And the same with generic trust store:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>cp generic-server-truststore.jks ~/.ccm/sslverify/node1/conf/server-truststore.jks\ncp generic-server-truststore.jks ~/.ccm/sslverify/node2/conf/server-truststore.jks\ncp generic-server-truststore.jks ~/.ccm/sslverify/node3/conf/server-truststore.jks\n</pre></div></div>\n<h3 id=\"add-encryption-options-to-the-configuration\">Add Encryption Options to the Configuration:</h3>\n<p>With the files in place, let’s modify the configuration to enable server to server encryption. Replace the <code class=\"highlighter-rouge\">server_encryption_options</code> in each server’s <code class=\"highlighter-rouge\">cassandra.yaml</code> located in <code class=\"highlighter-rouge\">~/.ccm/sslverify/[server]/conf/</code> with the following (adjusting the path to fit your environment and the $NODE variable below for each of our three nodes):</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>server_encryption_options:\n  internode_encryption: all\n  keystore: /Users/zznate/.ccm/sslverify/$NODE/conf/server-keystore.jks\n  keystore_password: awesomekeypass\n  truststore: /Users/zznate/.ccm/sslverify/$NODE/conf/server-truststore.jks\n  truststore_password: truststorepass\n  protocol: TLS\n  algorithm: SunX509\n  store_type: JKS\n  cipher_suites: [TLS_RSA_WITH_AES_256_CBC_SHA]\n  require_client_auth: true\n</pre></div></div>\n<p>In the above snippet, we have specified <a href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\">256bit AES</a>. This is a fairly strong cypher and is therefore subject to US export control (I’m not providing a link here because this whole idea of cryptographic export controls is outmoded at best - look it up if you want &lt;/rant&gt;). To use this, we need to install the strong encryption policy files into our JDK. Follow the download titled “Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files for JDK/JRE 8” from Oracle’s <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\">Java download page</a>.</p>\n<p>Those files usually get installed into <code class=\"highlighter-rouge\">${java.home}/jre/lib/security/</code>. The internet has copious amounts of information for specific systems if that is not were your installation has placed them.</p>\n<p>Some additional info on why you need to do this can be found <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html#importlimits\">here</a></p>\n<p>Alternatively, you can skip the policy file installation by choosing a weaker strength cipher:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>cipher_suites: [TLS_RSA_WITH_AES_128_CBC_SHA]\n</pre></div></div>\n<p>Depending on your requirements, your network segmentation, or any industry guidelines to which you may be beholden, using 128-bit keys might be fine. If you are going over any sort of public connection, you should do 256-bit keys.</p>\n<p>With the policy jars in place (or with the 128-bit AES cipher specified), let’s restart <code class=\"highlighter-rouge\">node1</code> via ccm:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>ccm node1 stop\nccm node1 start\n</pre></div></div>\n<p>If everything is working correctly, you should see log output (available in <code class=\"highlighter-rouge\">~/.ccm/sslverify/node1/logs/system.log</code>) containing:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>Starting Encrypted Messaging Service on SSL port 7001\n</pre></div></div>\n<p>The output of <code class=\"highlighter-rouge\">ccm node1 nodetool status</code> should look like:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>Datacenter: datacenter1\n=======================\nStatus=Up/Down\n|/ State=Normal/Leaving/Joining/Moving\n--  Address    Load       Tokens  Owns   Host ID                               Rack\nUN  127.0.0.1  15.78 MB   1       33.3%  7ac70e8c-507b-4dfc-bed8-ddbd736ae9dc  rack1\nDN  127.0.0.2  ?          1       33.3%  e12e1ac3-12b8-48e8-8f5e-897573026896  rack1\nDN  127.0.0.3  ?          1       33.3%  0e867789-ec7d-4704-b0ed-e0437a28f83d  rack1\n</pre></div></div>\n<p>What we are seeing here is that <code class=\"highlighter-rouge\">node1</code> has toggled over to using SSL and can no longer communicate with the other two cluster members. It therefore assumes they are down. Executing <code class=\"highlighter-rouge\">nodetool status</code> against one of the other nodes will indeed show the opposite picture.</p>\n<p>Let’s move on with the rest of the cluster. Repeating the process above with <code class=\"highlighter-rouge\">node2</code>, the output from <code class=\"highlighter-rouge\">ccm node1 nodetool status</code> should now show:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>Datacenter: datacenter1\n=======================\nStatus=Up/Down\n|/ State=Normal/Leaving/Joining/Moving\n--  Address    Load       Tokens  Owns   Host ID                               Rack\nUN  127.0.0.1  15.79 MB   1       33.3%  7ac70e8c-507b-4dfc-bed8-ddbd736ae9dc  rack1\nUN  127.0.0.2  37.87 MB   1       33.3%  e12e1ac3-12b8-48e8-8f5e-897573026896  rack1\nDN  127.0.0.3  ?          1       33.3%  0e867789-ec7d-4704-b0ed-e0437a28f83d  rack1\n</pre></div></div>\n<p>And the same again with <code class=\"highlighter-rouge\">node3</code> should show all nodes as up.</p>\n<h3 id=\"debugging\">Debugging</h3>\n<p>There are a few things that can go wrong when setting up SSL. If you have exceptions, or it’s just not working as intended (there are several cases when setting up SSL where Cassandra will happily start even though no connections could be negotiated) you can enable debug logging on the SSL handshake via adding the following option to <code class=\"highlighter-rouge\">~/.ccm/sslverify/$NODE/conf/cassandra-env.sh</code>:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre>-Djavax.net.debug=ssl\n</pre></div></div>\n<p>This will print <strong>everything</strong> about the connection setup to STDOUT including how and why an SSL handshake failed. See <a href=\"http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/ReadDebug.html\">this page</a> for details on how to interpret what you are seeing.</p>\n<h2 id=\"one-last-thing\">One Last Thing</h2>\n<p>Whatever you have used for various expiration date parameters throughout this tutorial, make sure they sync it up with each other sensibly. Most importantly, put those dates on a calendar <strong>now</strong> with a healthy number of reminders leading up to expiration, inviting everyone even remotely involved with your team. I once saw an expired certificates cause havoc across an otherwise robust architecture because the expiration dates were set and promptly forgotten about.</p>\n<p>And just as with any failure scenario, make sure you test your certificate updating process. This is not something with which you want to experiment at the 11th hour.</p>\n<h2 id=\"up-next\">Up Next</h2>\n<p>We’ll continue this series soon with a post on options available for setting up Encryption at Rest. It will be higher-level than this post, as we will focus more on the options available for and known to work with Cassandra. Keep checking back for updates!</p>\n<p>As always, please let us know if there are any errors factual or command-wise in the steps above.</p>"}}]}},"pageContext":{"alternative_id":12402}}