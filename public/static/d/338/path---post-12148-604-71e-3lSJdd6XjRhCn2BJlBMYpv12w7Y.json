{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Third Contact With a Monolith - Beam Me Down Scotty - Instaclustr","alternative_id":12148,"content":"<p><a href=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr.jpg\"><br /><img class=\"aligncenter wp-image-6851 size-full\" src=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr.jpg\" alt=\"Third Contact with a monolith Part B instaclustr\" width=\"596\" height=\"1340\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr.jpg 596w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr-133x300.jpg 133w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr-455x1024.jpg 455w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr-534x1200.jpg 534w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr-274x616.jpg 274w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr-285x640.jpg 285w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr-21x48.jpg 21w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Space-Odyssey-image-Instaclustr-48x108.jpg 48w\" /></a></p><h2>Regression Analysis is (relatively) easy</h2><p>Hypothesis: <em>Using only a subset of GC metrics we can compute linear regression functions using only heap space used to predict when the next GC occurs. To do this we don’t need access to all the metrics per host, just a subset. And we can extend it in the future to use multiple variables and/or regression classification to predict which GCs are likely to be “long”.</em></p><p>Let’s look at some sample heap space data and GC time information. Here’s a graph showing heap space used increasing over time (x-axis, seconds) and then a GC kicking in (orange line), resulting in a reduction in the heap space used. The GC value is the duration of the last GC so changes from approximately 7s to 9s.</p><p><a href=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/15-min-sample-heap-and-lastGC-duration.png\"><img class=\"aligncenter wp-image-6852 size-large\" src=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/15-min-sample-heap-and-lastGC-duration-1024x529.png\" alt=\"15 min sample heap and lastGC duration\" width=\"1024\" height=\"529\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/15-min-sample-heap-and-lastGC-duration-1024x529.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/15-min-sample-heap-and-lastGC-duration-300x155.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/15-min-sample-heap-and-lastGC-duration-768x397.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/15-min-sample-heap-and-lastGC-duration-966x499.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/15-min-sample-heap-and-lastGC-duration-640x331.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/15-min-sample-heap-and-lastGC-duration-93x48.png 93w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/15-min-sample-heap-and-lastGC-duration-209x108.png 209w\" /></a></p><p>The following graph shows a linear regression function fitted to the portion of the heap space used graph in the interval between GCs. It shows a significant linear correlation with R- squared 0.71.  </p><p><a href=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Trend-line-for-heap-instaclustr-graph.png\"><img class=\"aligncenter wp-image-6853 size-large\" src=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Trend-line-for-heap-instaclustr-graph-1024x566.png\" alt=\"Trend line for heap Instaclustr graph\" width=\"1024\" height=\"566\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Trend-line-for-heap-instaclustr-graph-1024x566.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Trend-line-for-heap-instaclustr-graph-300x166.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Trend-line-for-heap-instaclustr-graph-768x424.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Trend-line-for-heap-instaclustr-graph-966x534.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Trend-line-for-heap-instaclustr-graph-640x354.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Trend-line-for-heap-instaclustr-graph-87x48.png 87w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Trend-line-for-heap-instaclustr-graph-195x108.png 195w\" /></a></p><p>Is this useful? Assuming we know (or can compute) the amount of heap used that triggers a GC then yes. This may be node-specific (depending on how much heap is available), may change (as more memory is allocated), and may be a percentage (which we have to compute, for this example it was 70%). Obviously, the slope of the function will vary across and even within nodes depending on the frequency of GC (which may depend on many other variables which we’ll look at next time), so the function needs to be computed for each node for each interval between GCs. This requires us to do a few things: Find when each GC occurs so we can determine the time period from the end of the last GC to the start of the next GC to use as the sample period to compute the regression function over; for each interval normalise the actual timestamps to relative time (in seconds) from the start of the interval; keep track of the amount of heap used that triggers the GC (or compute the percentage used); and find sufficient samples for a node to make predictions and check the accuracy and usefulness of the results.</p><p>Some preliminary inspection of sample data showed a few problems. Using GC startTime and endTime seemed to be the obvious way of finding when GCs occurred. However, there was something odd about the times as they were in the distant past, in fact, they were about 300 times less than expected. Oh, that five minutes isn’t it. Turns out that they had been truncated to bucket_time making them useless for my purpose. Another thing to watch for with Cassandra timestamps is that they are in UTC. If you convert them to a Java Date type they will be in local time. The <a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html\">Java Instant class</a> is a better representation once you read the timestamps on the client side (Instant is UTC, and has lots of useful time comparison methods).</p><p>Is there a way of using either GC duration and/or collectionCount to compute the GC start/end times? Yes, in theory. Both approaches worked ok, but I noticed large gaps in the timestamps for most nodes which made using duration tricky. The final version used collectionCount and discarded GC events that were more than 1 count different.   But why were there gaps in the data?</p><h2>Materialization accidents – “beam me down Scotty!”</h2><p>My suspicion turned to the materialized views (MVs) I had to created to make the queries easier. Obviously, MVs take time to populate from an existing table, but how do you know if they are complete? There are two system tables to check, one shows build in progress, and one shows built views completed  (system.built_views): </p><h6>keyspace_name | view_name              | generation_number | last_token<br />———————-+————————-+—————————-+—————————–<br />instametrics       | host_service_time  |             16563                 | -9178511905308517795<br />instametrics       | host_service_value |             16563                | -9178511746231999096</h6><p>So this probably explained the data gaps – a few days after creation the MVs were still being built. In fact I suspect they have got “stuck” (anyone know how to unstick them? I tried dropping a MV and trying to create another but this resulted in other nasty things). Given its sci-fi origins, I should have been wary of <a href=\"https://www.instaclustr.com/apache-cassandra/\">Cassandra</a> Materialization! The Star Trek Transporter was notoriously accident prone often resulting in duplicates, combined life forms, being turned inside out, or just plain non-existence, whoops. <a href=\"https://www.thoughtco.com/worst-transporter-accidents-on-star-trek-4046426\">Worst Star Trek Transporter accidents!</a></p><p><a href=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Mad-Star-Blecch.jpg\"><img class=\"aligncenter wp-image-6855 size-full\" src=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Mad-Star-Blecch.jpg\" alt=\"\" width=\"610\" height=\"554\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Mad-Star-Blecch.jpg 610w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Mad-Star-Blecch-300x272.jpg 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Mad-Star-Blecch-53x48.jpg 53w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Mad-Star-Blecch-119x108.jpg 119w\" /></a></p><p>I finally got the code working and ran it on a subset of 100 nodes. However, it was only finding a relatively small number of GCs per node due to the data gaps. I realized that the default read consistency level is only one, which means that only data from the first node it is found on is returned. I tried increasing the consistency level (to QUORUM) which resulted in more GCs found. See code on GIST:</p><p>Each regression analysis uses only the first half of the available data, and if the R-squared value is over 0.5 then the computed function is used to predict the next GC time, and the percentage error is computed and averaged over all results founds and reported as follows:</p><p><strong>Total time = 428,469ms</strong></p><p><strong>avgPerErr = 21.59 gcAvgInterval = 13,447.88s used 42.0 out of 218.0</strong></p><p>The analysis took 428 seconds, for the regressions that had a sufficiently high correlation (about 20%), the average percentage prediction error for the time of the next GC was 22%. The average time between GCs was 13,447 seconds, so the average error is about 3,000 seconds. So this approach would work well, but for only 20% of cases. There’s obviously something more complicated going on for the majority of cases requiring us to get even closer to the monolith, we need to install the analysis code closer to the data. </p><aside class=\"content-cta\"><div class=\"primary\"><h4>Related Articles:</h4></div></aside>"}}]}},"pageContext":{"alternative_id":12148}}