{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Static columns in Cassandra and their benefits - Info Support Blog","alternative_id":9436,"content":"<p>In my previous blogpost “<a href=\"http://blogs.infosupport.com/analysis-of-the-impact-of-new-use-cases-on-a-cassandra-data-model-and-operations-in-code/\" target=\"_blank\">Analysis of the impact of new use cases on a Cassandra data model and operations in code</a>” I looked at the risks of deploying Cassandra. In Cassandra we face the challenges of data modelling and designing the CRUD operations (create, read, update, delete), because in Cassandra it is best practice to denormalize the data models. With static columns (available from Cassandra 2.0.6) we are able to restrain some of these challenges for one-to-many relationships.</p><p>To explain the approach of using static columns we first need to understand how the models for one-to-many relationships look like in Cassandra. With that explanation I also show the operations on the data models. Next, I will explain what the static columns are exactly. I will also elaborate on the operations on these models and mention some technical limitation of static columns. Next we will take a deeper dive into the read operations for the one side of the one-to-many relation. To conclude I will summarize my findings.</p><p>In Cassandra it is best practice to denormalize the data models. We denormalize because the goal in Cassandra is to execute the read operations of the use case with one query or, more preferably, one disk I/O. To illustrate the use case, the data model and the operations I will use an example about teams and team members of Formula 1 racing teams.</p><p>In the example we have two entities; teams and team members. A single team can have multiple members and a given team member is member of only a single team. The first use case is that we should be able to create, read, update and delete teams. The second use case is that we should be able to create, read, update, and delete team members of a given team. Obviously we should also be able to read all members for a given team and read the team that a team member is member of.</p><p>Assume that for a team we wish to register: the name, the manager and the location. For a team member we wish to register: the name, the nationality and the position within the team. In Cassandra we would store all these fields in one table. In that table the team name will be the partition key and the member name will be the clustering key. The table is created with the following CQL statement.</p><pre>CREATE TABLE teammember_by_team (\n  teamname text,\n  manager text,\n  location text,\n  membername text,\n  nationality text,\n  position text,\n  PRIMARY KEY ((teamname), membername)\n);</pre><h2>Insert operation</h2><p>We can insert a row with the following CQL statement:</p><pre>INSERT INTO teammember_by_team (teamname, manager, location, membername, nationality, position)\nVALUES (‘Toro Rosso’, ‘Franz Tost’, ‘Faenza’, ‘Verstappen’, ‘Dutch’, ‘test driver’);</pre><p>This statement results in a new row in the table. When we wish to add another team member to the team we need to add values for the team’s fields, again.</p><h2>Update operation</h2><p>Updating a team member is relatively easy. For example with the following CQL statement:</p><pre>UPDATE teammember_by_team SET position = ‘driver’\nWHERE teamname = ‘Toro Rosso’ AND membername = ‘Verstappen’;</pre><p>But when we wish to update a team we need to execute the update for all team members. This is one of the risks and challenges of this model. This update operation may cost many queries, for example the following queries which result in the following table with data.</p><pre>UPDATE teammember_by_team SET manager = ‘Christian Horner’\nWHERE teamname = ‘Red Bull’ AND membername = ‘Ricciardo’;\nUPDATE teammember_by_team SET manager = ‘Christian Horner’\nWHERE teamname = ‘Red Bull’ AND membername = ‘Kvyat’;\nteamname   | membername | location      | manager          | nationality | position\n-----------+------------+---------------+------------------+-------------+----------\n  Red Bull |  Ricciardo | Milton Keynes | Christian Horner |  Australian |   driver\n  Red Bull |      Kvyat | Milton Keynes | Christian Horner |     Russian |   driver\nToro Rosso | Verstappen |        Faenza |       Franz Tost |       Dutch |   driver</pre><p>A static column is defined upon creation of the table in CQL using the keyword “static”. A normal column is stored within the clustering key, within the partition. This column has a value for every combination of partitioning key and clustering key (in our example team name and team member name). A static column resides one level higher, directly within the partition key (in our example team name).</p><p>All fields belonging to the one side of the one-to-many relation may be static columns. In our example this means that the team manager and team location can be static columns. Review the following CQL statement:</p><pre>CREATE TABLE teammember_by_team (\n  teamname text,\n  manager text static,\n  location text static,\n  membername text,\n  nationality text,\n  position text,\n  PRIMARY KEY ((teamname), membername)\n);</pre><p>Because the static columns are not stored within the clustering key, but are still associated to the partitioning key, we are able to insert team data without inserting team member data. When we read this table, we get back the team with all other field having “null”.</p><pre>INSERT INTO teammember_by_team (teamname, manager, location)\nVALUES (‘Red Bull’, ‘Christian Horner’, ‘&lt;unknown&gt;’);\nteamname  | membername | location | manager          | nationality | position\n----------+------------+----------+------------------+-------------+----------\n Red Bull |       null | &lt;unkown&gt; | Christian Horner |        null |     null</pre><p>Inserting team members is much easier using static columns, because team data no longer has to be duplicated.</p><pre>INSERT INTO teammember_by_team (teamname, membername, nationality, position)\nVALUES (‘Red Bull’, ‘Ricciardo’, ‘Australian’, ‘driver’);\nINSERT INTO teammember_by_team (teamname, membername, nationality, position)\nVALUES (‘Red Bull’, ‘Kvyat’, ‘Russian’, ‘driver’);</pre><p>When we read the table after the preceding statements, the result is as expected.</p><pre>teamname  | membername | location  | manager          | nationality | position\n----------+------------+-----------+------------------+-------------+----------\n Red Bull |  Ricciardo | &lt;unknown&gt; | Christian Horner |  Australian |   driver\n Red Bull |      Kvyat | &lt;unknown&gt; | Christian Horner |     Russian |   driver</pre><p>When we now wish to update a team we are able to do so with just one query.</p><pre>UPDATE teammember_by_team SET location = ‘Milton Keynes’\nWHERE teamname = ‘Red Bull’;\nteamname  | membername | location      | manager          | nationality | position\n----------+------------+---------------+------------------+-------------+----------\n Red Bull |  Ricciardo | Milton Keynes | Christian Horner |  Australian |   driver\n Red Bull |      Kvyat | Milton Keynes | Christian Horner |     Russian |   driver</pre><h2>Technical limitations</h2><p>There are however a few limitations to using static columns. A table can only contain static columns when the table has at least one clustering key. This actually makes sense because if the table has no clustering key then all fields are stored within the partition. Next to this limitation, static columns cannot be used on tables using the COMPACT STORAGE option.</p><p>When we wish to read fields from only the one side of the one-to-many relation this requires a different approach compared to reading fields on a table without static columns. Review the following query:</p><pre>SELECT teamname, manager, location\nFROM teammember_by_team\nWHERE teamname = ‘Red Bull’;</pre><p>Without static columns these fields may be inconsistent and we will get back two rows. With static columns these values are always consistent but still we get back two rows. We get back two rows because there are two team members. If we wish to get back one row per team then all we have to do is add the DISTINCT keyword:</p><pre>SELECT DISTINCT teamname, manager, location\nFROM teammember_by_team\nWHERE teamname = ‘Red Bull’;</pre><p>Cassandra understands that the distinct keyword requires a special treatment because all fields queried are static (besides the partition key). The data can be returned faster compared to not using static columns because in the latter case the values actually have to be compared.</p><p>Static columns provide benefits for one-to-many relations. These benefits constrain a couple of great risks as described in the previous blogpost. The insert operations become easier and more flexible at the one side on the one-to-many relation. The update performed on the entity side of the one-to-many relation is reduced from many queries to just one query. Also select queries at the single entity side of the one-to-many relation are improved.</p><h2>References</h2><p>[1] <a href=\"http://blogs.infosupport.com/analysis-of-the-impact-of-new-use-cases-on-a-cassandra-data-model-and-operations-in-code/\" target=\"_blank\">Analysis of the impact of new use cases on a Cassandra data model and operations in code</a></p><p>[2] <a href=\"http://www.datastax.com/dev/blog/cql-in-2-0-6\" target=\"_blank\">http://www.datastax.com/dev/blog/cql-in-2-0-6</a></p><p>[3] <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-6561\" target=\"_blank\">https://issues.apache.org/jira/browse/CASSANDRA-6561</a></p><p>[4] <a href=\"http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/refStaticCol.html\" target=\"_blank\">http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/refStaticCol.html</a></p><p>[5] <a href=\"http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use-batch-static.html\" target=\"_blank\">http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use-batch-static.html</a></p><p>[6] <a href=\"http://cassandra.apache.org/doc/cql3/CQL.html#createTablepartitionClustering\" target=\"_blank\">http://cassandra.apache.org/doc/cql3/CQL.html#createTablepartitionClustering</a></p><p>[7] <a href=\"https://books.google.nl/books?id=n1nTBgAAQBAJ\" target=\"_blank\">https://books.google.nl/books?id=n1nTBgAAQBAJ</a></p>"}}]}},"pageContext":{"alternative_id":9436}}