{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"SnappyData, MemSQL-Spark & Cassandra-Spark: A Performance Benchmark","alternative_id":11826,"content":"<p>There is a repo associated with this blog post <a href=\"https://github.com/SnappyDataInc/snappy-poc\">here</a></p><p>There is a blog post that explains the Ad Analytics code example used below <a href=\"http://www.snappydata.io/blog/ad-analytics-using-spark-streaming-and-snappydata-code-example\">here</a></p><h2>Introduction</h2><p>We recently released a mixed workload example for Ad Analytics (<a href=\"https://github.com/SnappyDataInc/snappy-poc\">description and source code on github</a>) to illustrate the simplicity of development using SQL or the Spark Dataframe API in SnappyData. By mixed workload we mean a system that that is continuously ingesting a high velocity stream of ad impressions while concurrently serving ad-hoc interactive queries.  In addition to demonstrating SnappyData’s simplicity, we wanted to also benchmark it against alternatives. Here we try to understand SnappyData’s performance compared to alternate “lambda” stacks -  <a href=\"https://github.com/datastax/spark-cassandra-connector\">Cassandra + Spark</a> and <a href=\"https://github.com/memsql/memsql-spark-connector\">MemSQL + Spark</a> for both stream ingestion rate and interactive analytic query performance.</p><p>Our summarized findings:<br />- Snappydata can ingest data <strong>twice as fast</strong> as Cassandra and <strong>1.5 times faster</strong> than MemSQL.<br />- While ingesting data, SnappyData can concurrently execute analytics class queries <strong>45 times faster</strong> than Cassandra and <strong>3 times faster</strong> than MemSQL.</p><p>Note that these numbers represent queries over exact datasets; they do not include SnappyData’s <a href=\"https://github.com/SnappyDataInc/snappydata/blob/master/docs/aqp.md\">Approximate Query Processing techniques</a>. When these techniques are used (and the data volumes have grown), query latency becomes multiple orders of magnitude faster. The source code used for these tests is available on <a href=\"https://github.com/SnappyDataInc/snappy-poc\">Github</a>. Below, we will describe the benchmark:</p><h2>Machine Configuration</h2><p>Five ‘c4.2xlarge’ Compute optimized EC2 instances with<br />-       8 Cores<br />-       15GB RAM<br />-       Dedicated EBS bandwidth of 1000 Mbps</p><p>Product versions used:<br />MemSQL<br />-       MemSQL Ops-4.1.11 Community Edition<br />-       Spark-MemSQL Connector 2.10_1.3.2<br />-       Spark 1.5.2<br />Cassandra<br />-       Cassandra 3.5<br />-       Spark-Cassandra Connector 2.10_1.6.0-M2<br />-       Spark 1.6.0<br />-       SnappyData<br />-       SnappyData 0.3-PREVIEW; with Spark 1.6.1 is bundled<br />-       Apache Kafka 2.10_0.8.2.2.</p><h2>Architecture</h2><p>One machine was used for the Spark Master while the other four were used as Workers. A single Kafka producer process was executed producing ad impressions (asynchronously) over 16 threads. Four Kafka brokers were collocated on the Spark Worker nodes. We used 32 Kafka partitions to maximize concurrent processing. The kafka producer uses Avro Java objects to represent AdImpressions. Each AdImpression, when serialized, has a payload size of 63 bytes. To allow for concurrent analytical queries we configured spark so enough cores were available for query processing.</p><p>Finally, each tested system used the highest version of Spark it supported: 1.6.1 for SnappyData, 1.6.0 for Cassandra and 1.5.2 for MemSQL.</p><p>For each store that supported columnar storage, we used a column store to support fast scans and aggregations. Data is ingested using the Kafka direct receiver available with Spark Streaming and ingested in parallel on each partition.</p><p>The figures below depict the benchmark architecture for all 3 product configurations. The only difference with SnappyData is that its store is fully collocated with the spark executors as depicted in the figure <a href=\"https://github.com/SnappyDataInc/snappydata/blob/master/docs/GettingStarted.md#snappydata-cluster-explanation\">here</a>. SnappyData completely avoids the need to shuffle data as its column store defaults to the partitioning used by the upstream RDD (Spark DStream in this case) resulting in better speed of ingestion and query performance.</p><h4>SnappyData</h4><p>We ran the locator and the lead node (which runs the Spark Driver and is the cluster master) on one server and used the remaining four to parallel ingest from kafka and store into the column table (both in-memory and on disk). </p><p class=\"block-img\"><img alt=\"\" src=\"https://snappyblog.cdn.prismic.io/snappyblog/8d7eb75c15c29dbbc4a314a9a49f27d157068399_screen-shot-2016-06-20-at-9.32.23-am.png\" width=\"623\" height=\"251\" /></p><h4>Spark-Cassandra</h4><p>Similar to SnappyData we run the spark master/Driver on one node and so the ingestion process on the remaining 4 AWS nodes.</p><p class=\"block-img\"><img alt=\"\" src=\"https://snappyblog.cdn.prismic.io/snappyblog/7e6edd43fd86117512f23b7772a6b7d8d7802673_screen-shot-2016-06-20-at-9.33.50-am.png\" width=\"652\" height=\"259\" /></p><h4>Spark-MemSQL</h4><p>Matching what we did for SnappyData we start the spark master/Driver along with the MemSQL aggregator on one node and the remaining nodes parallely ingest and store into a local column table in MemSQL.</p><p class=\"block-img\"><img alt=\"\" src=\"https://snappyblog.cdn.prismic.io/snappyblog/1349f4125003c60731d1bf1fc3177571449619de_screen-shot-2016-06-20-at-9.36.21-am.png\" width=\"637\" height=\"277\" /></p><h4>Cassandra Tuning</h4><p>To tune writes, the cassandra connector batches incoming writes and exposes several <a href=\"https://github.com/datastax/spark-cassandra-connector/blob/master/doc/reference.md#write-tuning-parameters\">tuning parameters</a>. The ones we adjusted are listed above. Given the number of cores in use, adjusting the concurrent writer count gave us the maximum throughput. By default, the connector retains up to 1000 batches per single Spark task in memory before writing to Cassandra. This configuration is inappropriate in a production scenario unless checkpointing is enabled in Spark Streaming. While we didn’t tune any memory setting in the Cassandra servers we ensured that enough memory was available on each node to ensure all the data will be cached in the OS page cache.</p><h4>MemSQL Tuning</h4><p>We used defaults for the MemSQL configuration.</p><h4>SnappyData Tuning</h4><p>We used defaults for  SnappyData configuration.</p><h2>Ingestion Performance</h2><p>To ingest data we used the Spark streaming Kafka direct receiver. This is the most optimal way to fetch from kafka – batches from the topic are directly processed by the stream without any additional buffering in the Spark layer.</p><p>For all three products, each incoming Avro message is first decoded and then turned into a Spark Row object before it is stored into their respective Column table (in-memory + disk persistent). Below is the code snippet used to store streaming data into a column table in SnappyData.</p><p>In the Cassandra case, we ingest into a table with no replication (i.e. replication factor 1) so it is equivalent to Snappydata.</p><p>In the MemSQL case, we created the equivalent column table: </p><p>And stored the incoming streaming data into the coulmn table:</p><p>The chart below shows the ingestion per second throughput after some warm up period.</p><p class=\"block-img\"><img alt=\"\" src=\"https://snappyblog.cdn.prismic.io/snappyblog/ebb7f21a126788e0cec4567624f3f56a57677008_screen-shot-2016-06-20-at-10.34.20-am.png\" width=\"615\" height=\"422\" /></p><p>In short, on 4 nodes with 8 cores and a capped CPU (to leave space for concurrent OLAP queries), <strong>SnappyData outperformed Spark-Cassandra by roughly 2x</strong> with 670,000 events per second versus 322,000 <strong>and outperformed MemSQL by roughly 1.5x</strong> with 670,000 vs 480,000.</p><h2>Concurrent Query workload</h2><p>We concurrently execute simple aggregation queries using the Spark SQL Driver program when the ingested data reaches 30, 60 and 90 million records. We logged the query execution time to a file. For example, you can see the driver program for Cassandra <a href=\"https://github.com/SnappyDataInc/snappy-poc/blob/master/spark-cassandra/src/main/scala/io/snappydata/benchmark/CassandraQueryPerf.scala\">here</a>. We used following three aggregation queries to measure OLAP performance.</p><p><strong>Q1 </strong>: Show top 20 Geos with the highest ad impressions<br /><em>select count(*) AS adCount, geo from adImpressions group by geo order by adCount desc limit 20;</em></p><p><strong>Q2</strong>: Geos with the highest total bid<br /><em>select sum (bid) as max_bid, geo from adImpressions group by geo order by max_bid desc limit 20;</em></p><p><strong>Q3</strong>: Top 20 publishers with the highest bid total<br /><em>select sum (bid) as max_bid, publisher from adImpressions group by publisher order by max_bid desc limit 20;  \t</em></p><p>The following chart shows the latency numbers for each query by product and row count.</p><p class=\"block-img\"><img alt=\"\" src=\"https://snappyblog.cdn.prismic.io/snappyblog/599e09a972a440ddd78296f4f3e9ecc89992d308_screen-shot-2016-06-20-at-10.48.42-am.png\" width=\"674\" height=\"482\" /></p><p>As you can see SnappyData outperforms Spark-Cassandra by roughly <strong>45 times</strong> when executing queries while also ingesting data and outperforms MemSQL by roughly <strong>3 times</strong> on the same setup.</p><h2>Analysis</h2><p>The Cassandra connector suffers from two problems: <br />- The full data has to be serialized and copied to the spark cluster including going through format conversions for each query and <br />- The data has to be shuffled across multiple partitions.</p><p>These issues add latency to both ingestion and query performance.</p><p>The MemSQL connector, on the other hand, attempts to push as much of the query as possible to MemSQL which provides significant savings in having to move large quantities of data into Spark for each query. Go through <a href=\"https://github.com/memsql/memsql-spark-connector/blob/master/connectorLib/src/main/scala/com/memsql/spark/pushdown/MemSQLPushdownStrategy.scala\">MemSQLPushdownStrategy</a> and <a href=\"https://github.com/memsql/memsql-spark-connector/blob/master/connectorLib/src/main/scala/com/memsql/spark/pushdown/MemSQLPhysicalRDD.scala\">MemSQLPhysicalRDD</a> for details. The other optimization in MemSQL is that it always attempts to collocate its partition to the parent, so, kafka partitions, queuing, and ingestion all occur without ever having to shuffle any records.</p><p>SnappyData embeds its column store alongside the Spark executors providing reference level access to rows. Similar to MemSQL, it also ensures that each partition in the store layer, by default, uses the parent’s partitioning method. i.e. there is no need to shuffle during storing. When queried, the data is column compressed and formatted in the same format as Spark (when cached or persisted). These features provide a significant performance boost in ingestion and query latency.</p><h2>Interactive Query response with AQP</h2><p>We also benchmarked SnappyData’s <a href=\"https://github.com/SnappyDataInc/snappydata/blob/master/docs/aqp.md\">Approximate Query Processing</a> techniques and compared this to “exact” queries against our in-memory column tables. While these sampling techniques require large data volumes for higher accuracy, we compensated by creating a relatively large <a href=\"http://snappydatainc.github.io/snappydata/aqp/#approximations-technique-2-sampling\">stratified sample</a> of 3% to work with smaller data sets in this example. We created a <a href=\"https://github.com/SnappyDataInc/snappy-poc/blob/master/src/main/scala/io/snappydata/adanalytics/SnappySQLLogAggregator.scala#L99\">sample on the base column Table</a>. When queries are executed we append an error clause so the sample is automatically consulted (<em>‘select .. from aggrAdImpressions group by … <em><strong>with error 0.2’</strong></em>). Let’s compare our 3 queries over the exact table and sample table (In SnappyData) at 350m, 400m and 450m records with concurrent streaming. </em></p><p class=\"block-img\"><img alt=\"\" src=\"https://snappyblog.cdn.prismic.io/snappyblog/63c512965721478575757c303bbceb2057422a84_screen-shot-2016-06-21-at-8.59.03-am.png\" width=\"421\" height=\"315\" /></p><p>As expected, the sample table execution is much faster than its counterpart exact table. While the performance is high, usually with large data sets the sample fraction can be much smaller with a resulting performance difference that is 2 or even 3 orders of magnitude better than running against the base table. It is also interesting to note that, <strong>with increasing data volume, the query execution time on the sample stays fairly constant</strong>. While the sample size grows in proportion to the base table size, most of the query execution cost comes from other sources like error computation and query planning through the spark driver. Other performance related blogs:</p><p>SnappyData is <a href=\"https://www.snappydata.io/download?utm_source=blog&amp;utm_campaign=memsql2016blog\">available for download</a>.<br /></p><p>Learn more and chat about SnappyData on any of our community channels:</p><p><a href=\"http://stackoverflow.com/questions/tagged/snappydata\">Stackoverflow</a><br /><a href=\"http://snappydata-slackin.herokuapp.com/\">Slack</a><br /><a href=\"https://groups.google.com/forum/#!forum/snappydata-user\">Mailing List</a><br /><a href=\"https://gitter.im/SnappyDataInc/snappydata\">Gitter</a><br /><a href=\"https://www.reddit.com/r/snappydata/\">Reddit</a><br /><a href=\"https://jira.snappydata.io/projects/SNAP/issues/SNAP-893?filter=allopenissues\">JIRA</a></p><p>Other important links:</p><p><a href=\"https://github.com/SnappyDataInc/snappydata\">SnappyData source</a><br /><a href=\"http://snappydatainc.github.io/snappydata/\">SnappyData docs</a><br /><a href=\"https://twitter.com/snappydata\">SnappyData twitter</a><br /><a href=\"http://www.snappydata.io/snappy-industrial\">SnappyData technical paper</a><br /></p>"}}]}},"pageContext":{"alternative_id":11826}}