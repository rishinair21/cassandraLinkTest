{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Basic Rules of Cassandra Data Modeling","alternative_id":11153,"content":"<div class=\"DXDvBlgCtaAD_wrp1\"><p>Learn more about Apache Cassandra and data modeling</p></div><p>Picking the right <a href=\"http://planetcassandra.org/getting-started-with-time-series-data-modeling/\">data model</a> is the hardest part of using Cassandra.  If you have a relational background, CQL will look familiar, but the way you use it can be very different.  The goal of this post is to explain the basic rules you should keep in mind when designing your schema for Cassandra.  If you follow these rules, you'll get pretty good performance out of the box.  Better yet, your performance should scale linearly as you add nodes to the cluster.</p><h2>Non-Goals</h2><p>Developers coming from a relational background usually carry over rules about relational modeling and try to apply them to Cassandra.  To avoid wasting time on rules that don't really matter with Cassandra, I want to point out some <em>non</em>-goals:</p><h3>Minimize the Number of Writes</h3><p>Writes in Cassandra aren't free, but they're awfully cheap.  Cassandra is optimized for high write throughput, and almost all writes are equally efficient <a href=\"#footnote\"><sup>[1]</sup></a>.  If you can perform extra writes to improve the efficiency of your read queries, it's almost always a good tradeoff.  Reads tend to be more expensive and are much more difficult to tune.</p><h3>Minimize Data Duplication</h3><p>Denormalization and duplication of data is a fact of life with Cassandra.  Don't be afraid of it.  Disk space is generally the cheapest resource (compared to CPU, memory, disk IOPs, or network), and Cassandra is architected around that fact.  In order to get the most efficient reads, you often need to duplicate data.</p><p>Besides, Cassandra doesn't have <code>JOIN</code>s, and you don't really want to use those in a distributed fashion.</p><h2>Basic Goals</h2><p>These are the two high-level goals for your data model:</p><ol><li>Spread data evenly around the cluster</li>\n<li>Minimize the number of partitions read</li>\n</ol><p>There are other, lesser goals to keep in mind, but these are the most important. For the most part, I will focus on the basics of achieving these two goals.  There are other fancy tricks you can use, but you should know how to evaluate them, first.</p><h3>Rule 1: Spread Data Evenly Around the Cluster</h3><p>You want every node in the cluster to have roughly the same amount of data. Cassandra makes this easy, but it's not a given.  Rows are spread around the cluster based on a hash of the <a href=\"https://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureDataDistributeHashing_c.html\"><em>partition key</em></a>, which is the first element of the <a href=\"https://www.datastax.com/documentation/cql/3.0/cql/ddl/ddl_compound_keys_c.html\"><code>PRIMARY KEY</code></a>.  So, the key to spreading data evenly is this: <b>pick a good primary key</b>.  I'll explain how to do this in a bit.</p><h3>Rule 2: Minimize the Number of Partitions Read</h3><p>Partitions are groups of rows that share the same partition key.  When you issue a read query, you want to read rows from as few partitions as possible.</p><p>Why is this important?  Each partition may reside on a different node. The coordinator will generally need to issue separate commands to separate nodes for each partition you request.  This adds a lot of overhead and increases the variation in latency.  Furthermore, even on a single node, it's more expensive to read from multiple partitions than from a single one due to the way rows are stored.</p><h3>Conflicting Rules?</h3><p>If it's good to minimize the number of partitions that you read from, why not put everything in a single big partition?  You would end up violating Rule #1, which is to spread data evenly around the cluster.</p><p>The point is, these two goals often conflict, so you'll need to try to balance them.</p><h2>Model Around Your Queries</h2><p>The way to minimize partition reads is to model your data to fit your queries. Don't model around relations.  Don't model around objects.  Model around your queries.  Here's how you do that:</p><h3>Step 1: Determine What Queries to Support</h3><p>Try to determine <em>exactly</em> what queries you need to support.  This can include a lot of considerations that you may not think of at first.  For example, you may need to think about:</p><ul><li>Grouping by an attribute</li>\n<li>Ordering by an attribute</li>\n<li>Filtering based on some set of conditions</li>\n<li>Enforcing uniqueness in the result set</li>\n<li>etc ...</li>\n</ul><p>Changes to just one of these query requirements will frequently warrant a data model change for maximum efficiency.</p><h3>Step 2: Try to create a table where you can satisfy your query by reading (roughly) one partition</h3><p>In practice, this generally means you will use roughly one table per query pattern. If you need to support multiple query patterns, you usually need more than one table.</p><p>To put this another way, each table should pre-build the \"answer\" to a high-level query that you need to support.  If you need different types of answers, you usually need different tables.  This is how you optimize for reads.</p><p>Remember, data duplication is okay.  Many of your tables may repeat the same data.</p><h2>Applying the Rules: Examples</h2><p>To show some examples of a good throught process, I will walk you through the design of a data model for some simple problems.</p><h3>Example 1: User Lookup</h3><p>The high-level requirement is \"we have users and want to look them up\".  Let's go through the steps:</p><p><b>Step 1</b>: <em>Determine what specific queries to support</em><br />Let's say we want to either be able to look up a user by their username or their email.  With either lookup method, we should get the full set of user details.</p><p><b>Step 2</b>: <em>Try to create a table where you can satisfy your query by reading (roughly) one partition</em><br />Since we want to get the full details for the user with either lookup method, it's best to use two tables:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nCREATE TABLE users_by_username (&#13;\n    username text PRIMARY KEY,&#13;\n    email text,&#13;\n    age int&#13;\n)&#13;\n&#13;\nCREATE TABLE users_by_email (&#13;\n    email text PRIMARY KEY,&#13;\n    username text,&#13;\n    age int&#13;\n)&#13;\n</pre><p>Now, let's check the two rules for this model:</p><p><b>Spreads data evenly?</b> Each user gets their own partition, so yes.<br /><b>Minimal partitions read?</b> We only have to read one partition, so yes.</p><p>Now, let's suppose we tried to optimize for the <em>non</em>-goals, and came up with this data model instead:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nCREATE TABLE users (&#13;\n    id uuid PRIMARY KEY,&#13;\n    username text,&#13;\n    email text,&#13;\n    age int&#13;\n)&#13;\n&#13;\nCREATE TABLE users_by_username (&#13;\n    username text PRIMARY KEY,&#13;\n    id uuid&#13;\n)&#13;\n&#13;\nCREATE TABLE users_by_email (&#13;\n    email text PRIMARY KEY,&#13;\n    id uuid&#13;\n)&#13;\n</pre><p>This data model also spreads data evenly, but there's a downside: we now have to read two partitions, one from <code>users_by_username</code> (or <code>users_by_email</code>) and then one from <code>users</code>.  So reads are roughly twice as expensive.</p><h3>Example 2: User Groups</h3><p>Now the high-level requirement has changed.  Users are in groups, and we want to get all users in a group.</p><p><b>Step 1</b>: <em>Determine what specific queries to support</em><br />We want to get the full user info for every user in a particular group.  Order of users does not matter.</p><p><b>Step 2</b>: <em>Try to create a table where you can satisfy your query by reading (roughly) one partition</em><br />How do we fit a group into a partition?  We can use a compound <code>PRIMARY KEY</code> for this:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nCREATE TABLE groups (&#13;\n    groupname text,&#13;\n    username text,&#13;\n    email text,&#13;\n    age int,&#13;\n    PRIMARY KEY (groupname, username)&#13;\n)&#13;\n</pre><p>Note that the <code>PRIMARY KEY</code> has two components: <code>groupname</code>, which is the partitioning key, and <code>username</code>, which is called the clustering key.  This will give us one partition per <code>groupname</code>.  Within a particular partition (group), rows will be ordered by <code>username</code>.  Fetching a group is as simple as doing the following:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nSELECT * FROM groups WHERE groupname = ?&#13;\n</pre><p>This satisfies the goal of minimizing the number of partitions that are read, because we only need to read one partition.  However, it doesn't do so well with the first goal of evenly spreading data around the cluster.  If we have thousands or millions of small groups with hundreds of users each, we'll get a pretty even spread.  But if there's one group with millions of users in it, the entire burden will be shouldered by one node (or one set of replicas).</p><p>If we want to spread the load more evenly, there are a few strategies we can use. The basic technique is to add another column to the PRIMARY KEY to form a compound partition key.  Here's one example:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nCREATE TABLE groups (&#13;\n    groupname text,&#13;\n    username text,&#13;\n    email text,&#13;\n    age int,&#13;\n    hash_prefix int,&#13;\n    PRIMARY KEY ((groupname, hash_prefix), username)&#13;\n)&#13;\n</pre><p>The new column, <code>hash_prefix</code>, holds a prefix of a hash of the username.  For example, it could be the first byte of the hash modulo four. Together with <code>groupname</code>, these two columns form the compound partition key.  Instead of a group residing on one partition, it's now spread across four partitions.  Our data is more evenly spread out, but we now have to read four times as many partitions.  This is an example of the two goals conflicting.  You need to find a good balance for your particular use case.  If you do a lot of reads and groups don't get too large, maybe changing the modulo value from four to two would be a good choice.  On the other hand, if you do very few reads, but any given group can grow very large, changing from four to ten would be a better choice.</p><p>There are other ways to split up a partition, which I will cover in the next example.</p><p>Before we move on, let me point out something else about this data model: we're duplicating user info potentially many times, once for each group. You might be tempted to try a data model like this to reduce duplication:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nCREATE TABLE users (&#13;\n    id uuid PRIMARY KEY,&#13;\n    username text,&#13;\n    email text,&#13;\n    age int&#13;\n)&#13;\n&#13;\nCREATE TABLE groups (&#13;\n    groupname text,&#13;\n    user_id uuid,&#13;\n    PRIMARY KEY (groupname, user_id)&#13;\n)&#13;\n</pre><p>Obviously, this minimizes duplication.  But how many partitions do we need to read? If a group has 1000 users, we need to read 1001 partitions.  This is probably 100x more expensive to read than our first data model.  If reads need to be efficient at all, this isn't a good model.  On the other hand, if reads are extremely infrequent, but updates to user info (say, the username) are extremely common, this data model might actually make sense.  Make sure to take your read/update ratio into account when designing your schema.</p><h3>Example 3: User Groups by Join Date</h3><p>Suppose we continue with the previous example of groups, but need to add support for getting the X newest users in a group.</p><p>We can use a similar table to the last one:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nCREATE TABLE group_join_dates (&#13;\n    groupname text,&#13;\n    joined timeuuid,&#13;\n    username text,&#13;\n    email text,&#13;\n    age int,&#13;\n    PRIMARY KEY (groupname, joined)&#13;\n)&#13;\n</pre><p>Here we're using a <code>timeuuid</code> (which is like a timestamp, but avoids collisions) as the clustering column.  Within a group (partition), rows will be ordered by the time the user joined the group.  This allows us to get the newest users in a group like so:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nSELECT * FROM group_join_dates&#13;\n    WHERE groupname = ?&#13;\n    ORDER BY joined DESC&#13;\n    LIMIT ?&#13;\n</pre><p>This is reasonably efficient, as we're reading a slice of rows from a single partition.  However, instead of always using <code>ORDER BY joined DESC</code>, which makes the query less efficient, we can simply reverse the clustering order:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nCREATE TABLE group_join_dates (&#13;\n    groupname text,&#13;\n    joined timeuuid,&#13;\n    username text,&#13;\n    email text,&#13;\n    age int,&#13;\n    PRIMARY KEY (groupname, joined)&#13;\n) WITH CLUSTERING ORDER BY (joined DESC)&#13;\n</pre><p>Now we can use the slightly more efficient query:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nSELECT * FROM group_join_dates&#13;\n    WHERE groupname = ?&#13;\n    LIMIT ?&#13;\n</pre><p>As with the previous example, we could have problems with data being spread evenly around the cluster if any groups get too large.  In that example, we split partitions somewhat randomly, but in this case, we can utilize our knowledge about the query patterns to split partitions a different way: by a time range.</p><p>For example, we might split partitions by date:</p><pre class=\"brush: sql; gutter: true; title: ; notranslate\" title=\"\">&#13;\nCREATE TABLE group_join_dates (&#13;\n    groupname text,&#13;\n    joined timeuuid,&#13;\n    join_date text,&#13;\n    username text,&#13;\n    email text,&#13;\n    age int,&#13;\n    PRIMARY KEY ((groupname, join_date), joined)&#13;\n) WITH CLUSTERING ORDER BY (joined DESC)&#13;\n</pre><p>We're using a compound partition key again, but this time we're using the join date.  Each day, a new partition will start.  When querying the X newest users, we will first query today's partition, then yesterday's, and so on, until we have X users.  We may have to read multiple partitions before the limit is met.</p><p>To minimize the number of partitions you need to query, try to select a time range for splitting partitions that will typically let you query only one or two partitions.  For example, if we usually need the ten newest users, and groups usually acquire three users per day, we should split by four-day ranges instead of a single day <a href=\"#footnote\"><sup>[2]</sup></a>.</p><h2>Summary</h2><p>The basic rules of data modeling covered here apply to all (currently) existing versions of Cassandra, and are very likely to apply to all future versions.  Other lesser data modeling problems, such as <a href=\"https://medium.com/@foundev/domain-modeling-around-deletes-1cc9b6da0d24\">dealing with tombstones</a>, may also need to be considered, but these problems are more likely to change (or be mitigated) by future versions of Cassandra.</p><p>Besides the basic strategies covered here, some of Cassandra's fancier features, like <a href=\"https://www.datastax.com/dev/blog/cql3_collections\">collections</a>, <a href=\"https://www.datastax.com/dev/blog/cql-in-2-1\">user-defined types</a>, and <a href=\"https://www.datastax.com/documentation/cql/3.1/cql/cql_reference/refStaticCol.html\">static columns</a>, can also be used to reduce the number of partitions that you need to read to satisfy a query.  Don't forget to consider these options when designing your schema.</p><p>Hopefully I've given you some useful fundamental tools for evaluating different schema designs.  If you want to go further, I suggest taking <a href=\"https://academy.datastax.com/courses/ds220-data-modeling?dxt=blogposting\">Datastax's free, self-paced online data modeling course (DS220)</a>.  Good luck!</p><p>[1]: Notable exceptions: <a href=\"https://www.datastax.com/dev/blog/whats-new-in-cassandra-2-1-a-better-implementation-of-counters\">counters</a>, <a href=\"https://www.datastax.com/dev/blog/lightweight-transactions-in-cassandra-2-0\">lightweight transactions</a>, and <a href=\"http://cassandra.apache.org/doc/cql3/CQL.html#collections\">inserting into the middle of a list collection</a>.</p><p>[2]: I suggest using a timestamp truncated by some number of seconds.  For example, to handle four-day ranges, you might use something like this:</p><pre class=\"brush: python; gutter: true; title: ; notranslate\" title=\"\">&#13;\nnow = time()&#13;\nfour_days = 4 * 24 * 60 * 60&#13;\nshard_id = now - (now % four_days)&#13;\n</pre><hr /><p><a href=\"https://www.datastax.com/\">DataStax</a> has many ways for you to advance in your career and knowledge. \n</p><p>You can take <a href=\"https://academy.datastax.com/user/register?destination=home&amp;utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_DSA_register\" target=\"_self\" title=\"academy.datastax.com\">free classes</a>, <a href=\"https://academy.datastax.com/certifications?utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_DSA_certifications\" target=\"_self\" title=\"academy.datastax.com/certifications\">get certified</a>, or read <a href=\"https://www.datastax.com/dbas-guide-to-nosql\" target=\"_self\" title=\"dbas-guide-to-nosql\">one of our many white papers</a>.\n</p><p><a href=\"https://academy.datastax.com/user/register?destination=home&amp;utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_DSA_register\" target=\"_self\" class=\"dxAllButtons_v3Rad2_whiteNGrayOL\" title=\"academy.datastax.com\">register for classes</a>\n</p><p><a href=\"https://academy.datastax.com/certifications?utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_DSA_certifications\" target=\"_self\" class=\"dxAllButtons_v3Rad2_whiteNGrayOL\" title=\"academy.datastax.com/certifications\">get certified</a>\n</p><p><a href=\"http://www.datastax.com/dbas-guide-to-nosql?utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_dbasguidetonosql\" target=\"_self\" class=\"dxAllButtons_v3Rad2_whiteNGrayOL\" title=\"dbas-guide-to-nosql\">DBA's Guide to NoSQL</a>\n</p><br class=\"clear\" /><div id=\"mto_newsletter_121316_Css\"><p>Subscribe for newsletter:</p><br /></div>"}}]}},"pageContext":{"alternative_id":11153}}