{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Using Cassandra Stress to model a time series workload - Instaclustr","alternative_id":12169,"content":"<p><b>Motivation</b></p><p>When examining whether <a href=\"https://www.instaclustr.com/apache-cassandra/\">Cassandra</a> is a good fit for your needs, it is good practice to stress test Cassandra using a workload that looks similar to the expected workload in Production. </p><p>In the past we have examined the richness of features using YAML profiles in Cassandra’s stress tool – if you haven’t seen the previous post or are unfamiliar with YAML profiles in Cassandra stress, I’d recommend <a href=\"https://www.instaclustr.com/deep-diving-cassandra-stress-part-3-using-yaml-profiles/\">checking it out now</a>. </p><p>YAML profiles are all fine and dandy when it comes to mixed or general workloads using SizeTieredCompactionStrategy (STCS) or LeveledCompactionStrategy (LCS), but sometimes we may want to model a time series workload using TimeWindowCompactionStrategy (TWCS). How would we do that with the current options available to us in stress? Ideally, we would be able to do such a thing without having to schedule cassandra-stress instances every X minutes. </p><p><b>Native functions</b></p><p>As it turns out, Cassandra has a native function <b>now()</b> that returns the current time as a <b>timeuuid</b>, which is a unique representation of time. Cassandra also ships with the function <b>toTimestamp()</b> that accepts a <b>timeuuid</b>. Putting the two together, we are able to obtain the following result:</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-12.27.59-pm.png\"><img class=\"aligncenter size-full wp-image-9517\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-12.27.59-pm.png\" alt=\"\" width=\"670\" height=\"280\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-12.27.59-pm.png 670w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-12.27.59-pm-300x125.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-12.27.59-pm-640x267.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-12.27.59-pm-115x48.png 115w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-12.27.59-pm-258x108.png 258w\" /></a></p><p>So we can use that to our advantage in a YAML profile:</p><div id=\"crayon-5b9a77320c0b8296795884\" class=\"crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-mac print-yes notranslate\" data-settings=\"minimize scroll-mouseover\"><div class=\"crayon-main\"><table class=\"crayon-table\"><tr class=\"crayon-row\"><td class=\"crayon-nums\" data-settings=\"show\"> <div class=\"crayon-nums-content\"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p></div></td>\n<td class=\"crayon-code\"><div class=\"crayon-pre\"><p>table_definition: |</p><p>CREATE TABLE twcstest (</p><p>id text,</p><p>time timestamp,</p><p>metric int,</p><p>value blob,</p><p>PRIMARY KEY((id), time)</p><p>) WITH CLUSTERING ORDER BY (time DESC)</p><p>AND compaction = { 'class':'TimeWindowCompactionStrategy', 'compaction_window_unit':'MINUTES', 'compaction_window_size':'20' }</p><p>AND comment='A table to see what happens with TWCS &amp; Stress'</p><p>columnspec:</p><p>- name: id</p><p>  size: fixed(64)</p><p>  population: uniform(1..1500M)</p><p>- name: time</p><p>  cluster: fixed(288)</p><p>- name: value</p><p>  size: fixed(50)</p><p>queries:</p><p>putindata:</p><p>  cql: insert into twcstest (id, time, metric, value) VALUES (?, toTimestamp(now()), ?, ?)</p></div></td>\n</tr></table></div></div><p>Based on that YAML above, we can now insert time series data as part of our stress. Additionally, please be aware that the <b>compaction_window_unit</b> property has been deliberately kept much smaller than is typical of a normal production compaction strategy!</p><p>The only snag to be aware of is that stress will insert timestamps rapidly, so you may want to tweak the values a little to generate suitably sized partitions with respect to your production workload. </p><p><b>That’s great, now how do I select data?</b></p><p>Well, intuitively we would just make use of the same helpful native functions that got us out from the tight spot before. So we may try this:</p><p>We appear to be a little stuck because selects may not be as straightforward as we had expected.</p><ol><li>We could try qualifying with just <b>&lt;=</b>, but then that would be a whole lot of data we select (You aren’t going to do this in Production, are you?), unless <b>id</b> is bucketed…but it isn’t in our situation. </li>\n<li>We could try qualifying with just <b>&gt;=</b>, but then nothing will be returned (You aren’t testing a case like this either, surely).</li>\n</ol><p>Unfortunately for us, it doesn’t look like Cassandra has anything available to help us out here natively. But it certainly has something we can leverage. </p><p><b>UDFs for the win</b></p><p>User defined functions (UDFs) have been added to Cassandra since <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-7395\">2.2</a>. If you aren’t familiar with them, there are examples of them available in a <a href=\"https://www.instaclustr.com/user-defined-functions-and-aggregates/\">previous blog post</a> and the <a href=\"http://cassandra.apache.org/doc/latest/cql/functions.html\">official cassandra documentation</a>. Since Cassandra doesn’t have any other native functions to help us, we can just write our own UDF, as it should be. </p><p>Typically we may expect to want to select a slice up to a certain number of minutes ago. So we want to write a UDF to allow us to do that.</p><p>This UDF is quite self explanatory so I won’t go into too much detail. Needless to say, it returns a <b>bigint</b> of <b>arg </b>minutes ago. </p><p>Here is a test to illustrate just to be safe:</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-1.12.56-pm.png\"><img class=\"aligncenter size-full wp-image-9516\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-1.12.56-pm.png\" alt=\"\" width=\"987\" height=\"950\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-1.12.56-pm.png 987w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-1.12.56-pm-300x289.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-1.12.56-pm-768x739.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-1.12.56-pm-935x900.png 935w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-1.12.56-pm-640x616.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-1.12.56-pm-50x48.png 50w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/05/Screen-Shot-2018-04-23-at-1.12.56-pm-112x108.png 112w\" /></a></p><p>Here is our new and improved YAML profile:</p><p>Now, when we execute cassandra-stress with <b>simple1</b>, we can expect just data within a certain time frame instead of selecting the whole partition. We can also keep varying the query to select older data if we like, for example, <b>time &gt;= minutesAgo(600) and time &lt;= minutesAgo(590) </b>for data up to 10 hours ago.</p><p><b>A variation with bucketing</b></p><p>We can also create UDFs that model bucketing behaviour. For example, suppose now we have a schema that has data bucketed, like this:</p><p>And we want to be able to insert data in 5 minute buckets. We can create UDFs like so:</p><p>The UDF <b>bucket</b> is quite self explanatory as well – it just returns the nearest 5 minute bucket smaller than <b>arg</b>. This assumes UTC time and 5 minute buckets, but the code can easily be tailored to be more general. </p><p>However, our UDF doesn’t understand <b>timeuuid</b>. Which is why we need another helper function, which is the function <b>nowInMilliSec</b>(). </p><p>The final UDF generates a random bucket based on a lower and upper bound time. The expected input bounds should be in epoch milliseconds. This will help in selecting old/random data bucketed to within 5 minutes in a range. </p><p>And now here is our new and modified YAML profile to accommodate our desires of having stress follow a bucketed workload:</p><p>1524117600000 happens to be Thursday, April 19, 2018 5:20:00 AM in GMT time while 1524129600000 happens to be Thursday, April 19, 2018 9:20:00 AM. It can be tailored to suit needs. It’s kind of ugly, but it will do the job. </p><p>And there we go: Tap into UDFs to be able to model a TWCS workload with Cassandra stress.</p><p>There’s always an option of writing your own client and using that to perform stress instead, with the obvious benefit that there’s no need to write UDFs and you have control over everything. The downside is that you would have to write code that includes rate limiting and reporting of metrics whereas cassandra stress is the stressing tool that comes with Cassandra out of the box and has very rich statistics, down to latency for each query. </p>"}}]}},"pageContext":{"alternative_id":12169}}