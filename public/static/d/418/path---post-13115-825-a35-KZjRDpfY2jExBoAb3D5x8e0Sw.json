{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cassandra row count tips – A developer day – Web Developer from Somewhere","alternative_id":13115,"content":"<p>When you use <a href=\"http://www.datastax.com/what-we-offer/products-services/devcenter\">DevCenter</a>, you define a connection with one or more server.<br />Thus, when you do an CQL instruction, this one is done on the cluster with the default consistency level ( the consistency level defaults to ONE for all write and read operations),<br />and so on the closest replica respond.</p><p>When you use Cqlsh, in the same way your CQL instruction are done on the cluster (and not on the node on which you execute the cqlsh script).</p><p>A simple example :</p><ul><li>Create a cluster of two nodes (update your cassandra.yaml), we call them nodeA and nodeB</li>\n  <li>Start cqlsh on nodeA</li>\n  <li>Create a keyspace (with a replication factor of 2), thus all your node have all datas</li>\n</ul><pre>CREATE KEYSPACE mybeautifulkeyspace WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 2};\n</pre><ul><li>CREATE a simple table on this keyspace</li>\n</ul><pre>USE mybeautifulkeyspace;\nCREATE TABLE mysimpletable (id int, label text, PRIMARY KEY(id));\n</pre><ul><li>Insert a row in this table</li>\n</ul><pre>INSERT INTO mysimpletable (id, label) values (1,'un libelle');\n</pre><ul><li>you can start cqlsh on nodeB, and do a select :</li>\n</ul><pre>USE mybeautifulkeyspace;\nSELECT * FROM mysimpletable;\n</pre><ul><li>your row is correctly returned</li>\n  <li>the tricky things come here, stop cassandra on nodeB</li>\n  <li>insert a new line on nodeA and stop cassandra on nodeA</li>\n  <li>restart cassandra on nodeB, and connect via cqlsh to the keyspace mybeautifulkeyspace, the select return only one rows.</li>\n</ul><pre> id | label\n----+------------\n  1 | un libelle\n</pre><ul><li>restart cassandra on nodeA</li>\n  <li>on nodeB, always with cqlsh do the select, it could take before the cassandra on nodeB could answer (after restarting), but after few select on nodeB the second line appears too</li>\n</ul><pre> id | label\n----+--------------\n  1 |   un libelle\n  2 | un libelle 2\n</pre><ul><li>Ok, this is great, cqlsh get correctly datas from nodeA, but if I stop again my nodeA, what happen ?<br />The select let appear the second line on nodeB, because the node do a read repair.</li>\n</ul><h3 id=\"on-the-cluster-\">On the cluster :</h3><pre>select count(*) from mysimpletable\n</pre><p>However, there is a default limit of 10,000 applied to this statement which will truncate the result for larger tables. The limit can be increased :</p><pre>select count(*) from mysimpletable limit 1000000\n</pre><h3 id=\"on-a-specific-node-\">On a specific node :</h3><p>Or you could use nodetool, but it’s only estimated value (this information disappeared in Cassandra 2.1)</p><pre>&gt;nodetool cfstats mybeautifulkeyspace\nKeyspace: mybeautifulkeyspace\n        Read Count: 0\n        Read Latency: NaN ms.\n        Write Count: 0\n        Write Latency: NaN ms.\n        Pending Tasks: 0\n                Table: mysimpletable\n                SSTable count: 1\n                Space used (live), bytes: 4734\n                Space used (total), bytes: 4734\n                SSTable Compression Ratio: 0.5972222222222222\n                Number of keys (estimate): 128\n                Memtable cell count: 0\n                Memtable data size, bytes: 0\n                Memtable switch count: 0\n                Local read count: 0\n                Local read latency: 0,000 ms\n                Local write count: 0\n                Local write latency: 0,000 ms\n                Pending tasks: 0\n                Bloom filter false positives: 0\n                Bloom filter false ratio: 0,00000\n                Bloom filter space used, bytes: 16\n                Compacted partition minimum bytes: 61\n                Compacted partition maximum bytes: 86\n                Compacted partition mean bytes: 79\n                Average live cells per slice (last five minutes): 0.0\n                Average tombstones per slice (last five minutes): 0.0\n</pre><p>For my two rows the estimated value is 128 …</p><p>Or other option is to use the sstablekeys that allows to get the keys from sstable file (generaly in /var/lib/cassandra/data but<br />it could be specified in cassandra.yaml).</p><p>An example of usage on this bash script :</p><pre>#!/bin/bash\n#prend en parametre le nom de la table\nif [ -z \"$1\" ]\n  then echo \"fournir le nom d'une table en parametre\"\n  exit 1\nfi\nnodetool flush\n#recuperation de tout les fichiers data correspondant\nfor file in `ls /data/cassandra/data/mybeautifulkeyspace/$1/*-$1-*-Data.db`\ndo\n  echo \"operating $file\"\n  sstablekeys $file &gt;&gt; output.txt\ndone\nnbLigne=$(sort output.txt | uniq | wc -l)\nrm output.txt\necho \"nombre de ligne $nbLigne\"\n</pre><p>Deletes in Cassandra rely on Tombstones to support the Eventual Consistency model. More information <a href=\"http://wiki.apache.org/cassandra/DistributedDeletes\">here</a><br />Tombstones are markers that can exist at different levels of the data model and let the cluster know that a delete was recored on a replica, and when it happened.<br />Tombstones then play a role in keeping deleted data hidden and help with freeing space used by deleted columns on disk.<br />The CQL count query doesn’t count them,</p><p>Instead the compaction process reconciles the data in multiple SSTables on disk. The row fragments from each SSTable are collated and columns with the same name reconciled using the process we’ve already seen. The result of the compaction is a single SSTable that contains the same “truth” as the input files, but may be considerably smaller due to reconciling overwrites and deletions.<br />So it was possible that the count by sstable count these deleted rows until the compaction is done.</p>"}}]}},"pageContext":{"alternative_id":13115}}