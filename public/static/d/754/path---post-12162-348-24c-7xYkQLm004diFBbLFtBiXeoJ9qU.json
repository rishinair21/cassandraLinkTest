{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cassandra Collections: Hidden Tombstones and How to Avoid Them - Instaclustr","alternative_id":12162,"content":"<h2>Overview</h2><p>Multi-value data types (sets, lists and maps) are a powerful feature of <a href=\"https://www.instaclustr.com/apache-cassandra/\">Cassandra</a>, aiding you in denormalisation while allowing you to still retrieve and set data at a very fine-grained level. However, some of Cassandra’s behaviour when handling these data types is not always as expected and can cause issues.</p><p>In particular, there can be hidden surprises when you update the value of a collection type column. For simple-type columns, Cassandra performs an update by simply writing a new value for the cell and the most recently written value wins when the data is read. However, when you overwrite a collection Cassandra can’t simply write the new elements because all the existing elements in the map have their own individual cells and would still be returned alongside the new elements whenever a read is performed on the map.</p><h2>The options</h2><p>This leaves Cassandra with two options:</p><ol><li>Perform a read and discover all the existing map elements and either delete them or update them if they were specified in the overwrite.</li> <li>Forget about all existing elements in the map by deleting them.</li> </ol><p>Option 1 doesn’t sound very optimised does it? A read for every write you perform? Ouch.<br />Cassandra chooses option 2, because it just can’t resist those performance gains. It knows you’re performing an overwrite, and that you obviously don’t care about the contents of those columns, so it will delete them for you, and we can all pretend they never existed in the first place.</p><p>Or so we thought… until one day your queries start failing because you’ve hit 100k tombstones. Didn’t expect that, especially when you never delete any data.<br />In most cases, compactions will just handle this problem for you and the tombstones will be gone before you even get close to the query failure limit. However, compaction strategies aren’t perfect and depending on how much you overwrite, plus how well compactions remove those tombstones, there are many cases where this behaviour can become a huge issue. If you are performing many writes, and all of them are overwrites where a collection type is involved, you will be generating a tombstone for every single write.</p><h2>Examples for avoiding the issue</h2><p>I’ve created a very basic schema with a map and a few fields, as below:</p><p>I then inserted a single row and performed a flush:</p><p>And I now have an SSTable in my tombs.staff data directory.</p><p>Using sstable2json to analyse the data, as expected we have one key, a, however it has two locations entries, despite the fact we only did one write.</p><p>This is to do with the map, and the whole overwrite thing I was talking about earlier. Already we can see that C* has written a range tombstone for the locations cell immediately before writing the value that I inserted.</p><p>Now this is kind of a spoiler, as we haven’t actually done any “overwrites” yet, but we’ve identified the feature we’re talking about. This is because in Cassandra, overwrites, updates, and inserts, are really all just the same thing. The insert against the map will do the same thing whether the key already exists or not.</p><p>Anyway, we can see how this delete first strategy begins to work if we simply insert another record with the same key:</p><p>We now have 2 sstables: tombs-staff-ka-1-Data.db and tombs-staff-ka-2-Data.db. And if we run sstable2json on the new SSTable, we see a very similar entry:</p><p>Nothing surprising, and furthermore, if we trigger a major compaction against our 2 SSTables:</p><p>And run sstable2json against our new SSTable…</p><p>We have the latest range tombstone plus the latest insert, and compactions have, as expected,  gotten rid of the previous insert as it knows everything older than the latest range tombstone is moot.</p><p>Now you can start to see where issues can arise when overwriting a key with a collection type. If it weren’t for the compaction, I’d have 2 tombstones for that single row across 2 SSTables. Obviously it’s very likely those SSTables will compact and the tombstones will get cleared out, however things are not always as clear cut, especially when you are frequently overwriting keys and the tombstones get spread across many SSTables of differing sizes, causing tombstone bloat that may not be removed when left up to minor compactions.</p><p>So how can we avoid this potential catastrophe? A simple solution would be to instead store JSON and leave the updates to your application, however there is an alternative. You can use the provided append and subtraction operators. These operators will modify the collection without having to perform a read, and also won’t create any range tombstones. This works for specific use cases where you simply need to insert/append/prepend, however if you frequently find yourself having to rewrite a whole collection you will need to take a different approach. You can also specify a collection as frozen which would give the the desired overwrite behaviour, but you will no longer be able to add and remove elements using the +, -, and [] operators.</p><p>Here is an example of performing collection operations on a list.</p><div id=\"crayon-5b9a5da245d96328149275\" class=\"crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-mac print-yes notranslate\" data-settings=\"minimize scroll-mouseover\"><div class=\"crayon-main\"><table class=\"crayon-table\"><tr class=\"crayon-row\"><td class=\"crayon-nums\" data-settings=\"show\"> <div class=\"crayon-nums-content\"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p></div></td>\n<td class=\"crayon-code\"><div class=\"crayon-pre\"><p>ALTER TABLE staff ADD leave_dates list&amp;lt;text&amp;gt;; # Creates a tombstone and an entry in the list    </p><p>insert into staff (id, leave_dates) values ('c', ['20160620']);   </p><p>$ nodetool flush    </p><p>$ sstable2json tombs-staff-ka-6-Data.db    </p><p>[    </p><p>{\"key\": \"c\",     \"cells\": [[\"\",\"\",1466427765961455],</p><p>[\"leave_dates:_\",\"leave_dates:!\",1466427765961454,\"t\",1466427765],   </p><p>[\"leave_dates:484b79b036e711e681757906eb0f5a6e\",\"3230313630363230\",1466427765961455]]}    </p><p>]    </p><p># Prepends an element to the list without creating any additional tombstones    </p><p>UPDATE staff SET leave_dates = [ '20160621' ] + leave_dates where id='c';   </p><p> $ nodetool flush    # The new SSTable has only a single entry in the list, no extra tombstone.   </p><p> # This works the same for appending to the list as well.    </p><p>$ sstable2json tombs-staff-ka-7-Data.db    </p><p>[   </p><p>{\"key\": \"c\",     \"cells\":    [[\"leave_dates:af13b22fb5e911d781757906eb0f5a6e\",\"3230313630363231\",1466427869996855]]}    </p><p>]</p></div></td>\n</tr></table></div></div><p>Be careful when using addition and subtraction on list types, as removing elements from a list can be an expensive operation. Cassandra will have to read in the entire list in order to remove a single entry. Note that this is not true for sets, removing a single entry from a set requires no reads, as Cassandra will simply write a tombstone for the matching cell.</p><p>See the below trace for a deletion from a list, where we can clearly see C* performing a read query before making the modifications.</p><p>The following statements for the SET type result in similar functionality. Note that appending and prepending is non-existent with sets, it is simply add and remove.</p><div id=\"crayon-5b9a5da245d9e680868585\" class=\"crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-mac print-yes notranslate\" data-settings=\"minimize scroll-mouseover\"><div class=\"crayon-main\"><table class=\"crayon-table\"><tr class=\"crayon-row\"><td class=\"crayon-nums\" data-settings=\"show\"> <div class=\"crayon-nums-content\"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p></div></td>\n<td class=\"crayon-code\"><div class=\"crayon-pre\"><p>    ALTER TABLE staff ADD leave_dates list&amp;lt;text&amp;gt;;</p><p>    # Creates a tombstone and an entry in the list</p><p>    insert into staff (id, leave_dates) values ('c', ['20160620']);</p><p>    $ nodetool flush</p><p>    $ sstable2json tombs-staff-ka-6-Data.db</p><p>    [</p><p>    {\"key\": \"c\",</p><p>     \"cells\": [[\"\",\"\",1466427765961455],</p><p>    [\"leave_dates:_\",\"leave_dates:!\",1466427765961454,\"t\",1466427765],</p><p>    [\"leave_dates:484b79b036e711e681757906eb0f5a6e\",\"3230313630363230\",1466427765961455]]}</p><p>    ]</p><p>    # Prepends an element to the list without creating any additional tombstones</p><p>    UPDATE staff SET leave_dates = [ '20160621' ] + leave_dates where id='c';</p><p>    $ nodetool flush</p><p>    # The new SSTable has only a single entry in the list, no extra tombstone.</p><p>    # This works the same for appending to the list as well.</p><p>    $ sstable2json tombs-staff-ka-7-Data.db</p><p>    [</p><p>    {\"key\": \"c\",</p><p>     \"cells\": [[\"leave_dates:af13b22fb5e911d781757906eb0f5a6e\",\"3230313630363231\",1466427869996855]]}</p><p>    ]</p></div></td>\n</tr></table></div></div>"}}]}},"pageContext":{"alternative_id":12162}}