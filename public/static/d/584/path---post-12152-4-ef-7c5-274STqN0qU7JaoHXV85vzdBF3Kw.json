{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Testing Multiple Tables with Cassandra Stress - Instaclustr","alternative_id":12152,"content":"<header id=\"page-masthead\"><div id=\"page-content\"><div class=\"container\"><div class=\"row\"><div class=\"col-md-6 col-md-offset-0 col-sm-8 col-sm-offset-2\"><div class=\"primary first-p-bold\"><p>The cassandra-stress tool is a powerful tool for benchmarking <a href=\"https://www.instaclustr.com/apache-cassandra/\">Cassandra</a> performance. It allows quite sophisticated specification of data and loads profiles to run against almost any table definition you can create in Cassandra. We’ve previously published detailed blog posts on the use of cassandra-stress: <a href=\"https://www.instaclustr.com/deep-diving-into-cassandra-stress-part-1/\">Part 1</a>, <a href=\"https://www.instaclustr.com/deep-diving-into-cassandra-stress-part-2/\">Part 2</a> and <a href=\"https://www.instaclustr.com/deep-diving-cassandra-stress-part-3-using-yaml-profiles/\">Part 3</a>.</p><p>One significant limitation of cassandra-stress has been that it is only able to execute operations against once table at a time. You could work around that by running multiple instances of cassandra-stress but that was not ideal.</p><p>I recently submitted a patch for <a href=\"https://www.instaclustr.com/apache-cassandra/\">Apache Cassandra</a> that now enables multiple tables to be stressed simultaneously with cassandra-stress (<a href=\"https://issues.apache.org/jira/browse/CASSANDRA-8780\">https://issues.apache.org/jira/browse/CASSANDRA-8780</a>). This blog post provides some more explanation of how to use this new feature. (While the feature won’t hit release until Cassandra 4.0, it’s pretty easy to download the code and build cassandra-stress yourself if you want to use it in the meantime.)</p><p>The three core changes you need to know to stress multiple tables in one run are as follows:</p><ol><li>The profile= command line argument now accepts a comma delimited list of profile yaml files.</li> <li> Profile yaml files can now optionally contain a specname attribute which provide a way to identify the profile. If it’s not specified, the specname is inferred as &lt;keyspace&gt;.&lt;table&gt;.</li> <li>When specifying operation counts using the ops= command line argument you can prefix them with a specname to refer to an operation from a particular profile (eg spec1.insert). If you don’t specify a   specname, the specname from the first listed yaml file will be inferred.</li> </ol><p>The inferred specnames means that existing single yaml file cassandra-stress configurations will continue to run without requiring any change.</p><p>The following provides an example of how this can be used in practice:</p><p>(add all the other standard arguments you would pass to a cassandra-stress run).</p><p>Within table1.yaml, might look something like:</p><div id=\"crayon-5b9a6445f3531231561943\" class=\"crayon-syntax crayon-theme-sublime-text crayon-font-monaco crayon-os-pc print-yes notranslate\" data-settings=\"minimize scroll-mouseover\"><div class=\"crayon-main\"><table class=\"crayon-table\"><tr class=\"crayon-row\"><td class=\"crayon-nums\" data-settings=\"show\"> <div class=\"crayon-nums-content\"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p></div></td>\n<td class=\"crayon-code\"><div class=\"crayon-pre\"><p># Keyspace name and create CQL</p><p>#</p><p>specname: t1</p><p>keyspace: stressexample</p><p>keyspace_definition: |</p><p>CREATE KEYSPACE stressexample WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'};</p><p>#</p><p># Table name and create CQL</p><p>#</p><p>table: test1</p><p>table_definition: |</p><p>CREATE TABLE test5 (</p><p>pk int,</p><p>val text,</p><p>PRIMARY KEY (pk)</p><p>)</p><p>columnspec:</p><p>- name: pk</p><p>size: fixed(64)</p><p>population: seq(1..100000)</p><p>#</p><p># Specs for insert queries</p><p>#</p><p>insert:</p><p>partitions: fixed(1) # 1 partition per batch</p><p>batchtype: UNLOGGED # use unlogged batches</p><p>select: fixed(10)/10 # no chance of skipping a row when generating inserts</p><p>#</p><p># Read queries to run against the schema</p><p>#</p><p>queries:</p><p>single_read:</p><p>cql: select * from test1 where pk = ?</p><p>fields: samerow</p></div></td>\n</tr></table></div></div><p>table2.yaml would be similar but with specname=t2.</p><p>When you run this command cassandra-stress will first ensure that keyspaces and tables specified in each of the yaml files are created, creating them itself if necessary. It will then execute operations in the ratios specified in the ops argument – in this case, 10% inserts to table test1 as specified in table1.yaml, 10% reads using the single_read query definition and 80% inserts in the table specified in table2.yaml.</p><p>One interesting feature is that the multiple yaml files can all reference the same table in your cassandra cluster. I can see this being useful, for instance, where you want to simulate one read/write pattern against the bulk of your partitions while simultaneously simulating a different pattern against a small number of hot partitions. One thing to be aware of with this approach is that the data overlap between two different specs addressing the same table is hard to predict and so may bear close inspection if it’s important to your scenario.</p><p>I really hope this feature is useful to the Cassandra community. Let me know in the comments section (<a href=\"http://www.mail-archive.com/user@cassandra.apache.org/\">or the Cassandra user mailing list</a>) if you have any queries or suggestions.</p></div></div></div></div></div></header>"}}]}},"pageContext":{"alternative_id":12152}}