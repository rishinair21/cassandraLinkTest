{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"CMB","alternative_id":15,"content":"<pre>--------------------------------------------------------------------------------------\n- CMB (Cloud Message Bus) README\n--------------------------------------------------------------------------------------\nA highly available, horizontally scalable queuing and notification service compatible \nwith AWS SQS and SNS. This document covers these topics:\n- FAQ\n- User Forum\n- Binaries for Download\n- Accessing CQS/CNS Using AWS SDK\n- Brief Tutorial\n- Quickstart Guide\n- Monitoring, Logging\n- Multi Datacenter Support and Failover\n- Known Limitations\n--------------------------------------------------------------------------------------\n- FAQ\n--------------------------------------------------------------------------------------\nIf you have trouble installing or using CMB check our FAQ first.\n--------------------------------------------------------------------------------------\n- User Forum\n--------------------------------------------------------------------------------------\nIf you have any questions or comments please go to our user forum at\n<a href=\"https://groups.google.com/forum/#!forum/cmb-user-forum\" rel=\"nofollow\">https://groups.google.com/forum/#!forum/cmb-user-forum</a>\n--------------------------------------------------------------------------------------\n- Binaries for Download\n--------------------------------------------------------------------------------------\nIf you do not want to build from source you can download binary distributions from\nthe release section of this github repository.\n--------------------------------------------------------------------------------------\n- Accessing CQS/CNS Using AWS SDK\n--------------------------------------------------------------------------------------\nIf you prefer getting started by looking at some code, here's a complete end-to-end \nclient-side example for accessing CQS/CNS services using the AWS SDK:\n<a href=\"https://github.com/Comcast/cmb/blob/master/examples/java/Example.java\">https://github.com/Comcast/cmb/blob/master/examples/java/Example.java</a>\nIn this example, we first create a queue and a topic. Next we subscribe the queue and \nalso an http endpoint to the topic and finally we publish, receive and delete messages. \nConfirmation of pending subscriptions is also demonstrated.\n--------------------------------------------------------------------------------------\n- Brief Tutorial\n--------------------------------------------------------------------------------------\nCMB consists of two separate services, CQS and CNS. CQS offers queuing services while \nCNS offers publish / subscribe notification services. Both services are API-compatible \nwith Amazon Web Services SNS (Simple Notification Service) and SQS (Simple Queuing \nService). CNS currently supports these protocols for subscribers: HTTP, CQS, SQS and \nemail. CMB services are implemented with a Cassandra / Redis backend and are designed \nfor high availability and horizontal scalability.\nNote: While CQS and CNS are two functionally distinct services, CNS uses CQS \ninternally to distribute the fan-out work. Therefore, CNS cannot be deployed without \nCQS, however, you can deploy CQS in isolation if you do not need the pub-sub \ncapabilities of CNS.    \nThe most basic CMB system consists of one of each \n - CQS Service Endpoint (HTTP endpoint for CQS web service)\n - CNS Service Endpoint (HTTP endpoint for CNS web service)\n - CNS Publish Worker (required by CNS, used to publish messages to endpoints) \n - Cassandra Ring (persistence layer, used by CNS and CQS)\n - Sharded Redis (caching layer, used by CQS)\n \nFor testing purposes all five components can be run on a single host in a single JVM \nbut a production deployment typically uses separate hosts for each.    \nFor a detailed documentation of the CNS / CQS APIs please refer to the Amazon SNS / \nSQS specifications here:\n<a href=\"http://docs.amazonwebservices.com/sns/latest/api/Welcome.html\" rel=\"nofollow\">http://docs.amazonwebservices.com/sns/latest/api/Welcome.html</a>\n<a href=\"http://docs.amazonwebservices.com/AWSSimpleQueueService/latest/APIReference/Welcome.html\" rel=\"nofollow\">http://docs.amazonwebservices.com/AWSSimpleQueueService/latest/APIReference/Welcome.html</a>\nAccessing CNS / CQS:\nThere are three different ways to access CNS / CQS services:\n1. Using the web based CMB Admin UI:\nThe Admin UI is a simple Web UI for testing and administration purposes. To access \nthe CMB Admin UI use any web browser and go to\nWeb UI URL: http://&lt;cqs_host&gt;:6059/webui/\n2. Using the AWS SDK for Java or similar language bindings:\nAmazon offers a Java SDK to access SNS / SQS and other AWS services. Since CNS / CQS \nare API-compatible you can use the AWS SDK to access our implementation in the same \nway. Thus, instead of having to engineer your own REST requests you can get started \nwith a few lines of simple code as the following example illustrates.\n  BasicAWSCredentials credentialsUser = new BasicAWSCredentials(\"&lt;access_key&gt;\", \"&lt;secret_key&gt;\");\n \n  String cqsServerUrl = \"http://&lt;cqs_host&gt;:&lt;cqs_port&gt;/\";\n             \n  AmazonSQSClient sqs = new AmazonSQSClient(credentialsUser);\n  sqs.setEndpoint(cqsServerUrl);\n \n  Random randomGenerator = new Random();\n  String queueName = QUEUE_PREFIX + randomGenerator.nextLong();\n        \n  HashMap&lt;String, String&gt; attributeParams = new HashMap&lt;String, String&gt;();\n  CreateQueueRequest createQueueRequest = new CreateQueueRequest(queueName);\n  createQueueRequest.setAttributes(attributeParams);\n  String queueUrl = sqs.createQueue(createQueueRequest).getQueueUrl();\nAmazon offers a few other language bindings of its SDK and there are also a number of \nthird party SDKs available for languages not supported by Amazon.\n3. Sending REST requests directly to the service endpoint:\nAll CNS / CQS features can also be accessed by sending REST requests as HTTP GET or \nPOST directly to the service endpoints. Note that you need to timestamp and digitally \nsign every request if signature verification is enabled (signature verification \nis disabled by default, you can enable this feature by changing cmb.properties).\nExample REST request to create a CQS queue using curl:\ncurl -d \"Action=CreateQueue&amp;SignatureMethod=HmacSHA256&amp;AWSAccessKeyId=48JT2LKD3TX9X5JD6NMM&amp;QueueName=TSTQ_-3098387640939725337&amp;SignatureVersion=2&amp;Version=2011-10-01&amp;Signature=FemvuycfOczDIySdw9K4fjHvBWDm9W4iLDFUNQK220M%3D&amp;Timestamp=2012-08-04T00%3A14%3A54.157Z\" http://&lt;cqs_host&gt;:&lt;cqs_port&gt;\nExample response:\n&lt;CreateQueueResponse&gt;\n    &lt;CreateQueueResult&gt;\n        &lt;QueueUrl&gt;http://&lt;cqs_host&gt;:&lt;cqs_port&gt;/342126204596/TSTQ_-3098387640939725337&lt;/QueueUrl&gt;\n    &lt;/CreateQueueResult&gt;\n    &lt;ResponseMetadata&gt;\n        &lt;RequestId&gt;ad0ea46c-23fb-49bf-bb79-3784140451ae&lt;/RequestId&gt;\n    &lt;/ResponseMetadata&gt;\n&lt;/CreateQueueResponse&gt; \n--------------------------------------------------------------------------------------\n- Quickstart Guide\n--------------------------------------------------------------------------------------\nCMB comes with an embedded Jetty server. As a result the required components (CQS \nService Endpoint, CNS Service Endpoint and CNS Publish Worker) can all be conveniently\nlaunched using the cmb.sh script within a single JVM. The only external components\nyou need to install separately are Cassandra and Redis (make sure Redis does not \npersist to disk!). \n1. Build CMB from source\n   git clone <a href=\"https://github.com/Comcast/cmb.git\">https://github.com/Comcast/cmb.git</a>\n   mvn -Dmaven.test.skip=true assembly:assembly\n   \n   or download binary from\n   \n   <a href=\"http://cmb-releases.s3-website-us-west-1.amazonaws.com/\" rel=\"nofollow\">http://cmb-releases.s3-website-us-west-1.amazonaws.com/</a>\n   \n2. Unpack binary from target folder:\n   tar -xzvf cmb-distribution-&lt;version&gt;.tar.gz\n   \n3. Edit cmb.properties with a particular focus on the Redis and Cassandra settings. \n   For a single standalone CMB node ensure the CNS and CQS options are fully enabled \n   (default).\n   \n   cmb.cns.serviceEnabled=true\n   cmb.cqs.serviceEnabled=true\n   cmb.cns.publisherEnabled=true\n   cmb.cns.publisherMode=Consumer,Producer \n4. Install the correct schema version in your Cassandra ring\n   \n   NOTE: CMB does not work with Cassandra versions prior to 1.0.10. For Cassandra \n   versions 1.1.X and 1.2.X edit cassandra.yaml to activate the global row cache:\n   \n   row_cache_size_in_mb: 100\n   \n   To install the schema, use the appropriate command based on your Cassandra version\n   Using cli (deprecated):\n   \n   /&lt;path_to_cassandra&gt;/bin/cassandra-cli -h localhost -f cmb/schema/cassandra_1.0.schema\n   /&lt;path_to_cassandra&gt;/bin/cassandra-cli -h localhost -f cmb/schema/cassandra_1.1.schema\n   /&lt;path_to_cassandra&gt;/bin/cassandra-cli -h localhost -f cmb/schema/cassandra_1.2.schema\n   Using cql:\n   \n   /&lt;path_to_cassandra&gt;/bin/cqlsh localhost 9160 -f schema/cassandra_1.2.cql.schema    \n   NOTE: In newer versions of Cassandra thrift is disabled by default, as a result CMB \n   cannot connect to Cassandra. A solution to this is to run \"nodetool enablethrift\"\n   while Cassandra is running.\n   \n   NOTE: If you want the keyspaces to be replicated, you will need to change the keyspace \n   definitions before adding the schema. Make sure to pick a suitable replication factor \n   for your Cassandra ring, for example, RF=1 for single node rings and RF=3 for 3 nodes \n   or larger rings.\n   \n5. Redis version 2.6 or higher is required. Also be sure Redis does not persist \n   to disk.\n   Edit the redis.conf file and disable all persistence by commenting out the three \n   lines starting with \"save\".\n   \n   # save 900 1\n   # save 300 10\n   # save 60 10000\n   \n6. Start your CMB node:\n   ./bin/cmb.sh\n7. Check if web UI is available at localhost:6059/webui/ (login with username \n   cns_internal and password cns_internal).\n   \n--------------------------------------------------------------------------------------\n- Monitoring, Logging\n--------------------------------------------------------------------------------------\n    \nBy default all CMB components (CNS and CQS API Servers, CNS Worker Nodes) write INFO\nlevel logging into a file /tmp/cmb.log. You can adjust the logging behavior by \nediting config/log4.properties and restarting CMB. Logging primarily happens in a \nkey=value fashion. Example log line:\n2012-09-03 08:07:56,321 [\"http-bio-6060\"-exec-8] INFO  CMBControllerServlet - event=handleRequest status=success client_ip=172.20.3.117 action=Publish responseTimeMS=66 topic_arn=arn:cmb:cns:ccp:344284593534:XYZ CassandraTimeMS=19 CassandraReadNum=4 CassandraWriteNum=0 CNSCQSTimeMS=23 user_name=test_app\nIn addition, the state of the API servers as well as Worker Nodes can be checked with\nJMX using jconsole.\nCQS Metrics:\n  jconsole &lt;cqs_host&gt;:&lt;jmx_port&gt; \nThere is a CQSMonitor MBean exposing a number of CQS attributes including\n  - Number of open Redis connections\n  \nand these queue specific attributes\n  - Number of messages in the queue\n  - Number of messages deleted\n  - Number of messages marked invisible\n  - Number of empty receives\n  - Number of messages returned\n  - Number of messages received\n  - Cache hit percentage for messages received\n  - Message paylaod cache hit percentage\n  \nCNS Metrics:\n  jconsole &lt;cns_worker_host&gt;:&lt;jms_port&gt; \nThere is a CNSMonitor MBean exposing a number of CNS attributes including\n      \n  - Number of messages published in past 5 minutes\n  - Number of http connections in pool\n  - Number of pending publish jobs\n  - Error rate for endpoints\n  - Delivery queue size\n  - Redelivery queue size\n  - Consumer overloaded (boolean)      \nFinally the admin UI provides a dashboard like view of \n  - CQS API Server State\n  - CNS API Server State\n  - CNS Publish Worker State\n  - API Call Statistics (if enabled in cmb.properties)\n--------------------------------------------------------------------------------------\n- Multi-Data-Center Deployment and Failover (CQS)\n--------------------------------------------------------------------------------------\nActive-Passive Mode\nA CQS deployment consists of a Cassandra ring, one or more Redis shards and one or \nmore CMB service endpoints hosting the CNS/CQS REST API front end and Web UI. A \nproduction deployment typically consists of two (or more) identical deployments in \nseparate data centers with the ability to fail-over in case the service in one data \ncenter becomes unavailable. \nA small two-data-center deployment could look like this: One 8-Node Cassandra ring \n(4 nodes in each data center), 2 independent redis shards per data center (4 nodes \ntotal), 2 redundant CQS API servers per data center (also 4 nodes total). Each \ndata center also hosts a simple load balancer directing traffic to its two CQS API \nservers. One of the two data centers is the designated active data center while the \nsecond one operates in stand by mode. All CQS API calls are routed through a global \nload balancer which will direct all traffic to the local load balancer of the active \ndata center.\nEvery few seconds the global load balancer should call a health check API on the \ncurrently active CQS service. \nhttp://primarycqsserviceurl/?Action=HealthCheck\nWhile the service is available this call will return some XML encoded information \nalong with HTTP 200. Should any of the service components (CMB, Redis or \nCassandra) fail the return code will change to HTTP 503 (service unavailable). The \nglobal load balancer should detect this and start directing all CQS traffic to the \nsecond data center. \nBefore sending CQS request to the fail-over data center, the global load balancer \nshould also submit a clear cache request to make sure the Redis cache in the fail-over \ndata center does not contain any stale data.\nhttp://secondarycqsserviceurl/?Action=ManageService&amp;Task=ClearCache&amp;AWSAccessKeyId=&lt;adminaccesskey&gt;\nPseudo-Active-Active Mode\nYou may wish to operate a deployment across two or more data centers in active-active\nmode, meaning you have clients sending and receiving messages in both data centers. \nYou can do this with the current version of CMB but there are some limitations. \nMost notably, messages will never cross data center boundaries - in other words a \nmessage sent by a client in data center A cannot be received by another client \nin data center B. As long as you have redundant producers and consumers in both data \ncenters this is ok for many applications.  \n--------------------------------------------------------------------------------------\n- Known Limitations\n--------------------------------------------------------------------------------------\n- Compatibility with the Java AWS SDK has been tested up to version 1.11.2\n- CMB does not work with Cassandra versions prior to 1.0.10, however, 1.1.X, 2.0.X , \n  2.1.X and up are ok\n \n- CNS does not support SMS protocol\n- CNS does not support throttle policy\n- CNS does not support mobile push notifications\n- CQS does not support dead letter queue\n</pre>"}}]}},"pageContext":{"alternative_id":15}}