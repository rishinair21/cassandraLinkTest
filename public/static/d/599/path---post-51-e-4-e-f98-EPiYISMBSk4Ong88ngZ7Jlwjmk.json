{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Synthetic Sharding with Cassandra. Or How To Deal With Large Partitions.","alternative_id":51,"content":"<p id=\"67ee\" class=\"graf graf--p graf-after--h3\">Extremely overdue that I write this down as it’s a common problem, and really applies to any database that needs to scale horizontally, not just Cassandra.</p><h4 id=\"8e61\" class=\"graf graf--h4 graf-after--p\">Problem Statement</h4><p id=\"c539\" class=\"graf graf--p graf-after--h4\">Good partition keys are not always obvious, and it’s easy to create a bad one.</p><h4 id=\"18b9\" class=\"graf graf--h4 graf-after--p\">Defining A Bad Partition</h4><ol class=\"postList\"><li id=\"d027\" class=\"graf graf--li graf-after--h4\"><strong class=\"markup--strong markup--li-strong\">Uneven Access. </strong>Read OR write count is more than 2x different from one partition to another. This is a purist view and some of you using time series are screaming at me right now, but set that aside, I’ll have another blog post for you, but if you’re new to Cassandra consider it a good principle and goal to aim for.</li><li id=\"61ed\" class=\"graf graf--li graf-after--li\"><strong class=\"markup--strong markup--li-strong\">Uneven Size. </strong>Same as above really you can run cfhistograms and if you see really tiny or empty partitions next to really large ones or ones with really high cell count, you are at least on ingest uneven. I would shoot for within an order of magnitude or two. If you’re smart enough to tell me why I’m wrong here that’s fine, I’m not gonna care, but if you’re new to Cassandra this is a good goal.</li><li id=\"ef36\" class=\"graf graf--li graf-after--li\"><strong class=\"markup--strong markup--li-strong\">Too Many Cells.</strong> The partition cell count for a given partition is over 100k (run cfhistograms to get these numbers). This is entirely a rule of thumb and varies amazingly between hardware, tuning and column names (length matters). You may find you can add more and not hit a problem and you may find you can’t get near this. If you want to be exacting you should test.</li><li id=\"2e64\" class=\"graf graf--li graf-after--li\"><strong class=\"markup--strong markup--li-strong\">Too Large.</strong> Your partition size is over 32mb (also in cfhisograms). This also varies like cell count. Some people tell me this matters less now (as of 2.1), and they run a lot larger. However, I’ve seen it cause problems on a number of clusters. I repeat as a new user this is a good number to shoot for, once you’re advanced enough to tell me why I’m wrong you may ignore this rule. Again you should test your cluster to get the number where things get problematic.</li></ol><h4 id=\"ad33\" class=\"graf graf--h4 graf-after--li\">Options if you have a bad partition</h4><ol class=\"postList\"><li id=\"1f72\" class=\"graf graf--li graf-after--h4\">Pick a better partition key (read <a href=\"http://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" data-href=\"http://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">http://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling</a>).</li><li id=\"32f4\" class=\"graf graf--li graf-after--li\">Give up and use Synthetic Sharding.</li><li id=\"bfd5\" class=\"graf graf--li graf-after--li\">Pretend it’s not a problem and find out the hard way that it really is, usually this is at 3 am.</li></ol><h4 id=\"c16b\" class=\"graf graf--h4 graf-after--li\">Synthetic Sharding Strategy: Shard Table</h4><p id=\"ab05\" class=\"graf graf--p graf-after--h4\"><strong class=\"markup--strong markup--p-strong\">Pros</strong></p><ul class=\"postList\"><li id=\"1c7f\" class=\"graf graf--li graf-after--p\">Always works.</li><li id=\"a7b6\" class=\"graf graf--li graf-after--li\">Easy to parallelize (can be writing to shards in parallel).</li><li id=\"8f7f\" class=\"graf graf--li graf-after--li\">Very very common and therefore battle tested.</li></ul><p id=\"0822\" class=\"graf graf--p graf-after--li\"><strong class=\"markup--strong markup--p-strong\">Cons</strong></p><ul class=\"postList\"><li id=\"8451\" class=\"graf graf--li graf-after--p\">May have to do shards of shards for particularly large partitions.</li><li id=\"4f29\" class=\"graf graf--li graf-after--li\">Hard for new users to understand.</li><li id=\"3fce\" class=\"graf graf--li graf-after--li\">Hard to use in low latency use cases (but so are REALLY large partitions, so it’s a problem either way).</li></ul><p id=\"e7d3\" class=\"graf graf--p graf-after--li\"><strong class=\"markup--strong markup--p-strong\">Example Idea</strong></p><pre id=\"78f2\" class=\"graf graf--pre graf-after--p\"><em class=\"markup--em markup--pre-em\">-shard table<br /></em>CREATE TABLE IF NOT EXISTS shard_table ( id uuid, shard_id uuid, PRIMARY KEY(id, shard_id));<br /><em class=\"markup--em markup--pre-em\">-data table<br /></em>CREATE TABLE IF NOT EXISTS my_table ( id uuid, shard_id uuid, clustering_id timeuuid, data text, PRIMARY KEY((id, shard_id), clustering_id));</pre><pre id=\"f2b3\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\"> — first you have to query the shard table<br /></em>SELECT * FROM shard_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749;<br /><em class=\"markup--em markup--pre-em\">— the shard table returns <br /> — 7bc5204a-f24f-4a1a-8dcc-e19073d3e4d2<br /> — f3836d84-a694–47d5-ba1e-65eea128de13 <br />— and you do queries for each shard (using async in the driver)</em></pre><pre id=\"4759\" class=\"graf graf--pre graf-after--pre\">SELECT * FROM my_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id = 7bc5204a-f24f-4a1a-8dcc-e19073d3e4d2;<br />SELECT * FROM my_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id =  f3836d84-a694–47d5-ba1e-65eea128de13;</pre><pre id=\"eadd\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">- ingest will have to first create shards (say every 10k or split up by workers).</em><br />INSERT INTO shard_table (id, shard_id) VALUES (38bea878–3bc9–48ea-9b12–38aefcefb749, 7bc5204a-f24f-4a1a-8dcc-e19073d3e4d2);</pre><pre id=\"78f1\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">- insert into my_table using the shard you just created.</em><br />INSERT INTO my_table (id, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749, 7bc5204a-f24f-4a1a-8dcc-e19073d3e4d2, 9eb3f56a-bf24-11e5-9912-ba0be0483c18, 'my data');<br />INSERT INTO my_table (id, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749, 7bc5204a-f24f-4a1a-8dcc-e19073d3e4d2, f84532ba-bf24-11e5-9912-ba0be0483c18, 'my other data');<br /><em class=\"markup--em markup--pre-em\">- repeat insert until you \"fill up\" the shard with your calculated max.</em></pre><h4 id=\"a449\" class=\"graf graf--h4 graf-after--pre\">Synthetic Sharding Strategy: Shard Count Static Column</h4><p id=\"dda2\" class=\"graf graf--p graf-after--h4\"><strong class=\"markup--strong markup--p-strong\">Pros</strong></p><ul class=\"postList\"><li id=\"a29a\" class=\"graf graf--li graf-after--p\">No separate shard table.</li><li id=\"25fb\" class=\"graf graf--li graf-after--li\">No shards of shards problem</li><li id=\"6bad\" class=\"graf graf--li graf-after--li\">2x faster to read when there is a single shard than the shard table option.</li><li id=\"19f6\" class=\"graf graf--li graf-after--li\">Still faster even when there is more more than a single shard than the shard table option.</li></ul><p id=\"95a9\" class=\"graf graf--p graf-after--li\"><strong class=\"markup--strong markup--p-strong\">Cons</strong></p><ul class=\"postList\"><li id=\"2776\" class=\"graf graf--li graf-after--p\">Maybe even harder for new users since it’s a little bit of a surprise.</li><li id=\"59cf\" class=\"graf graf--li graf-after--li\">Harder to load concurrently.</li><li id=\"077b\" class=\"graf graf--li graf-after--li\">I don’t see this in wide use.</li></ul><p id=\"5083\" class=\"graf graf--p graf-after--li\"><strong class=\"markup--strong markup--p-strong\">Example Idea</strong></p><pre id=\"d4ba\" class=\"graf graf--pre graf-after--p\"><em class=\"markup--em markup--pre-em\">-single table<br /></em>CREATE TABLE IF NOT EXISTS my_table ( id uuid, shard_count int STATIC, shard_id int, clustering_id timeuuid, data text, PRIMARY KEY((id, shard_id), clustering_id));</pre><pre id=\"a6ca\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">— first you have to query the first shard to see if there are more.<br /></em>SELECT * FROM my_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id = 0<br /><em class=\"markup--em markup--pre-em\">— and it returns<br />- |  id                                |</em><strong class=\"markup--strong markup--pre-strong\"><em class=\"markup--em markup--pre-em\">shard_count</em></strong><em class=\"markup--em markup--pre-em\">|shard_id|<br />— |</em>38bea878–3bc9–48ea-9b12–38aefcefb749|<strong class=\"markup--strong markup--pre-strong\">2</strong>          |0       |<br />- |clustering_id                       |data     |<br />- |9eb3f56a-bf24-11e5-9912-ba0be0483c18|'my data'|</pre><pre id=\"cb76\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">— Since we have more than one shard we can now query the other shard<br /></em>SELECT * FROM my_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id = 1;</pre><pre id=\"5a42\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">You can just update the count as a separate update as you generate new shards or if you know how many shards you'll end up with before you start ingesting.</em><br />UPDATE my_table set shard_count = 2 WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id = 0</pre><pre id=\"e3e9\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">- ingest into a given shard.<br /></em>INSERT INTO my_table (id, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749, 0, 9eb3f56a-bf24-11e5-9912-ba0be0483c18, 'my data');<br />INSERT INTO my_table (id, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749, 0 , f84532ba-bf24-11e5-9912-ba0be0483c18, 'my other data');</pre><pre id=\"71b7\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">- ingesting into another shard. <br /></em>INSERT INTO my_table (id, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749, 1, f84532ba-bf24-11e5-9912-ba0be0483c18, 'my shard 2 data');<br />INSERT INTO my_table (id, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749, 1, f84532ba-bf24-11e5-9912-ba0be0483c18, 'my other shard 2 data');</pre><h4 id=\"d981\" class=\"graf graf--h4 graf-after--pre\">Synthetic Sharding Strategy: Known Shard Count</h4><p id=\"7b42\" class=\"graf graf--p graf-after--h4\"><strong class=\"markup--strong markup--p-strong\">Pros</strong></p><ul class=\"postList\"><li id=\"a869\" class=\"graf graf--li graf-after--p\">No separate shard table.</li><li id=\"2e21\" class=\"graf graf--li graf-after--li\">No shards of shards problem</li><li id=\"76fc\" class=\"graf graf--li graf-after--li\">Not as fast as static column shard count option when only a single shard.</li><li id=\"76b6\" class=\"graf graf--li graf-after--li\">Easy to grasp once the rule is explained.</li><li id=\"9d27\" class=\"graf graf--li graf-after--li\">Can easily abstract the shards away (if you always query for example 5 shards, then this can be a series of queries added to a library).</li><li id=\"13a4\" class=\"graf graf--li graf-after--li\">Useful when you just want to shrink the overall size of the partitions by a set order of magnitude, but don’t care so much about making sure the shards are even.</li><li id=\"2070\" class=\"graf graf--li graf-after--li\">Can use random shard selection and probably call it ‘good enough’</li><li id=\"5b04\" class=\"graf graf--li graf-after--li\">Can even use a for loop on ingest (and on read).</li></ul><p id=\"52c4\" class=\"graf graf--p graf-after--li\"><strong class=\"markup--strong markup--p-strong\">Cons</strong></p><ul class=\"postList\"><li id=\"0f2e\" class=\"graf graf--li graf-after--p\">I don’t see this in wide use.</li><li id=\"19c0\" class=\"graf graf--li graf-after--li\">Shard selection has to be somewhat thoughtful.</li></ul><p id=\"6a21\" class=\"graf graf--p graf-after--li\"><strong class=\"markup--strong markup--p-strong\">Example Idea</strong></p><pre id=\"9c87\" class=\"graf graf--pre graf-after--p\"><em class=\"markup--em markup--pre-em\">-single table<br /></em>CREATE TABLE IF NOT EXISTS my_table ( id uuid, shard_id int, clustering_id timeuuid, data text, PRIMARY KEY((id, shard_id), clustering_id));</pre><pre id=\"6ad0\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">— You always assume there are 5 shards. This is useful when you <br />— just want to shrink the max partition size down and so you throw every record in a different shard.<br /></em>SELECT * FROM my_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id = 0;<br />SELECT * FROM my_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id = 1;<br />SELECT * FROM my_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id = 2;<br />SELECT * FROM my_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id = 3;<br />SELECT * FROM my_table WHERE id = 38bea878–3bc9–48ea-9b12–38aefcefb749 AND shard_id = 4;</pre><pre id=\"4ad8\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">- ingest into a shard.<br /></em>INSERT INTO my_table (id, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749, 0, 9eb3f56a-bf24-11e5-9912-ba0be0483c18, 'my data');<br />INSERT INTO my_table (id, shard_count, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749, 0 , f84532ba-bf24-11e5-9912-ba0be0483c18, 'my other data');</pre><pre id=\"c7fb\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">- inserting into another shard.<br /></em>INSERT INTO my_table (id, shard_count, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749, 1, f84532ba-bf24-11e5-9912-ba0be0483c18, 'my shard 2 data');<br />INSERT INTO my_table (id, shard_count, shard_id, clustering_id, data) VALUES (<br />38bea878–3bc9–48ea-9b12–38aefcefb749,  1, f84532ba-bf24-11e5-9912-ba0be0483c18, 'my other shard 2 data');</pre><h4 id=\"d47a\" class=\"graf graf--h4 graf-after--pre\">Appendix: Java Example For Async</h4><p id=\"1eb3\" class=\"graf graf--p graf-after--h4\">A lot of folks seem to struggle with async queries. So for example using an integer style of shards this would just be a very simple:</p><pre id=\"123b\" class=\"graf graf--pre graf-after--p\">private final Cluster cluster;<br />private final Session session;<br />private final PreparedStatement query;</pre><pre id=\"aaf2\" class=\"graf graf--pre graf-after--pre\">public CassandraDAO(){<br />  cluster = Cluster.Builder.addContactPoint(“127.0.0.1”).build();<br />  session = cluster.newSession();<br />  query = session.prepare(“SELECT * FROM my_table WHERE id = ? and shard_id = ?”);<br />}</pre><pre id=\"074f\" class=\"graf graf--pre graf-after--pre\"><strong class=\"markup--strong markup--pre-strong\">public List&lt;String&gt; findDataById(UUID id) {<br /> List&lt;ResultSetFuture&gt; futures = new ArrayList&lt;&gt;(); </strong></pre><pre id=\"4583\" class=\"graf graf--pre graf-after--pre\"><strong class=\"markup--strong markup--pre-strong\"> for (int i = 0; i&lt;5; i++) {<br />   futures.add(session.executeAsync(query.bind(id, i)));<br /> }</strong></pre><pre id=\"f5df\" class=\"graf graf--pre graf-after--pre\"><strong class=\"markup--strong markup--pre-strong\">List&lt;String&gt; dataResults = new ArrayList&lt;&gt;();<br /> for(ResultSetFuture future: futures) {<br />  Result result = future.getUninterruptibly();</strong></pre><pre id=\"8ae6\" class=\"graf graf--pre graf-after--pre\"><strong class=\"markup--strong markup--pre-strong\">  dataResults.add(result.getString(“data”));<br /> }</strong></pre><pre id=\"cf2a\" class=\"graf graf--pre graf-after--pre graf--trailing\"><strong class=\"markup--strong markup--pre-strong\"> return dataResults;<br />}</strong></pre>"}}]}},"pageContext":{"alternative_id":51}}