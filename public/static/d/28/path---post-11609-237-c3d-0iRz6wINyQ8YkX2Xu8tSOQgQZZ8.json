{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"hawkular/cassalog","alternative_id":11609,"content":"<article class=\"markdown-body entry-content\" itemprop=\"text\">\n<div id=\"user-content-preamble\">\n<div>\n<div>\n<p>Cassalog is a schema change management library and tool for\n<a href=\"http://cassandra.apache.org\" rel=\"nofollow\">Apache Cassandra</a> that can be used with\napplications running on the JVM.</p>\n</div>\n</div>\n</div>\n<div>\n<h2 id=\"user-content-why\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#why\"></a>Why?</h2>\n<div>\n<div>\n<p>Just as application code evolves and changes so do database schemas. If you are\nbuilding an application and intend to support upgrading from one version to\nanother, then managing schema changes is essential. If you are lucky, you might\nbe able to get by with running some simple upgrade scripts to bring the schema\nup to date with the new version. This likely will not work however if you\nsupport multiple upgrade paths. For example, suppose we have versions 1 and 2,\nand are introducing version 3 of an application. We want to allow upgrading to\nversion 3 from either 1 or 2 in addition to upgrading from 1 to 2.</p>\n</div>\n<div>\n<p>You could add schema upgrade logic to application code, but that is often a\nless that ideal solution as it convolutes the code base. Fortunately, there are\ntool for managing schema changes like <a href=\"http://www.liquibase.org/\" rel=\"nofollow\">Liquibase</a>,\n<a href=\"http://flywaydb.org/\" rel=\"nofollow\">Flyway</a>, and\n<a href=\"http://guides.rubyonrails.org/active_record_basics.html\" rel=\"nofollow\">Active Record</a> for Ruby\non Rails applications. These tools however, are designed specifically for\nrelational databases. I previously spent time trying to patch Liquibase to\nsupport Cassandra but found that it was not a good fit. Cassalog is designed\nsolely for use with Cassandra, not for any other database systems.</p>\n</div>\n<div>\n<p>Cassalog is written in Groovy. There are several reasons for this. First,\nGroovy offers great interoperability with Java, making it usable and accessible\nto application running on the JVM. Groovyâ€™s dynamic and meta programming\nfeatures make it easy to write domain specific languages. Groovy has multi-line\nstrings and string interpolation out of the box, both of which can be really\nuseful for writing schema change scripts. Lastly, with Cassalog schema changes\nare not written in XML or JSON. Instead they are written as Groovy scripts\ngiving you the full power and flexibility of Groovy.</p>\n</div>\n</div>\n</div>\n<div>\n<h2 id=\"user-content-usage\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#usage\"></a>Usage</h2>\n<div>\n<div>\n<p>The Cassalog class is the primary class with which you will interact.</p>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-groovy\"><pre>// Groovy\ndef script = // load schema change script\ndef session = // obtain DataStax driver Session object\ndef cassalog = new Cassalog(session: session)\ncassalog.execute(script)</pre></div>\n</div>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-java\"><pre>// Java\nURI script = // load schema change script\nSession session = // obtain DataStax driver Session object\nCassalog cassalog = new Cassalog();\ncassalog.setSession(session);\ncassalog.execute(script);</pre></div>\n</div>\n</div>\n<div>\n<p>And here is what a cassalog script might look like,</p>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-groovy\"><pre>createKeyspace {\n  version '0.1'\n  name 'my_keyspace'\n  author 'admin'\n  description 'Set up a keyspace for unit tests'\n}\nschemaChange {\n  version '0.1.1'\n  author 'admin'\n  description 'Create table for storing time series data'\n  cql \"\"\"\nCREATE TABLE metrics (\n    id uuid,\n    time timeuuid,\n    value double,\n    PRIMARY KEY (id, time)\n)\n\"\"\"\n}</pre></div>\n</div>\n</div>\n<div>\n<table><tbody><tr><td>\n</td>\n<td>\nSchema changes are applied in the order that they are declared in the\nscript(s) regardless of the assigned versions.\n</td>\n</tr></tbody></table></div>\n</div>\n</div>\n<div>\n<h2 id=\"user-content-features\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#features\"></a>Features</h2>\n<div>\n<div>\n<ul><li>\n<p>Tagging</p>\n</li>\n<li>\n<p>Execute arbitrary Groovy / Java code in schema change scripts</p>\n</li>\n<li>\n<p>Pass variables to scripts</p>\n</li>\n<li>\n<p>Changes can stored across multiple scripts</p>\n</li>\n<li>\n<p>Schema change detection</p>\n</li>\n</ul></div>\n<div>\n<h3 id=\"user-content-tagging\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#tagging\"></a>Tagging</h3>\n<div>\n<p>You can specify tags when running Cassalog, e.g.</p>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-groovy\"><pre>// Groovy\ndef script = // load schema change script\ndef session = // obtain DataStax driver Session object\ndef cassalog = new Cassalog(session: session)\ncassalog.execute(script, ['dev', 'test_data'])</pre></div>\n</div>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-java\"><pre>// Java\nURI script = // load schema change script\nSession session = // obtain DataStax driver Session object\nCassalog cassalog = new Cassalog();\ncassalog.setSession(session);\ncassalog.execute(script, Collections.asList(\"dev\", \"test_data\"));</pre></div>\n</div>\n</div>\n<div>\n<p>Cassalog will apply schema changes that have not already been run and that</p>\n</div>\n<div>\n<ul><li>\n<p>Dot not specify any tags or</p>\n</li>\n<li>\n<p>Specify tags and include the <code>dev</code> and <code>test_data</code> tags</p>\n</li>\n</ul></div>\n</div>\n<div>\n<h3 id=\"user-content-execute-arbitrary-code\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#execute-arbitrary-code\"></a>Execute arbitrary code</h3>\n<div>\n<p>Cassandra is frequently used for time series data. Suppose we have a metrics\ntable, and we want to generate some sample data for tests.</p>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-groovy\"><pre>schemaChange {\n  version '1.0'\n  cql \"\"\"\nCREATE TABLE metrics (\n    id text PRIMARY KEY,\n    time timestamp,\n    value double\n)\n\"\"\"\n}\ntestData = []\nrandom = new Random\n10.times { i -&gt;\n  testData &lt;&lt; \"INSERT INTO metrics (id, time, value) VALUES ('$i', ${new Date().time + 100}, ${random.nextDouble()})\"\n}\nschemaChange {\n  version '1.0.1'\n  tags 'test_data'\n  cql testData\n}</pre></div>\n</div>\n</div>\n<div>\n<p>This script first calls the <code>schemaChange</code> function to create the metrics table.\nThe next few lines generate a list of INSERT statements with some test data.\nFinally, we have another call to <code>schemaChange</code>. It specifies the test_data\ntag and passes the <code>testData</code> list to the <code>cql</code> parameter.</p>\n</div>\n</div>\n<div>\n<h3 id=\"user-content-pass-variables-to-scripts\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#pass-variables-to-scripts\"></a>Pass variables to scripts</h3>\n<div>\n<p>You can pass arbitrary variables to scripts, not just strings.</p>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-groovy\"><pre>// Groovy\ndef vars = [\n  metricIds: ['M1', 'M2', 'M3'],\n  startDate: new Date()\n  maxValue: 100,\n  minValue: 50\n]\ncassalog.execute(script, vars)</pre></div>\n</div>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-java\"><pre>// Java\nMap&lt;String, ?&gt; vars = ImmutableMap.of(\n    \"metricIds\", asList(\"M1\", \"M2\", \"M3\"),\n    \"startDate\", new Date(),\n    \"maxValue\", 100,\n    \"minValue\", 50\n);\ncassalog.execute(script, vars);</pre></div>\n</div>\n</div>\n</div>\n<div>\n<h3 id=\"user-content-changes-can-stored-across-multiple-scripts\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#changes-can-stored-across-multiple-scripts\"></a>Changes can stored across multiple scripts</h3>\n<div>\n<p>You can use the <code>include</code> function to store changes in multiple script to\nkeep your schema changes more modular and better organized.</p>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-groovy\"><pre>include '/dbchanges/base_tables.groovy'\ninclude '/dbchanges/seed_data.groovy'</pre></div>\n</div>\n</div>\n<div>\n<p>The <code>include</code> function currently takes a single string argument that should\nspecify the absolute path of a script on the classpath or from the configured <code>baseScriptsPath</code>.</p>\n</div>\n<div>\n<p><code>baseScriptsPath</code> is an absolute path to where the other include scripts are located e.g. <code>/Users/john/cassalog/scripts</code>.</p>\n</div>\n</div>\n<div>\n<h3 id=\"user-content-schema-change-detection\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#schema-change-detection\"></a>Schema change detection</h3>\n<div>\n<p>Cassalog does not store the CQL code associated with each schema change. It\ncomputes a hash of the CQL and stores that instead. If the hash in the change\nlog differs from the hash of the CQL in the source script, Cassalog will throw\na ChangeSetAlteredException.</p>\n</div>\n<div>\n<p>You will need to manually resolve the issue that caused the\nChangeSetAlteredException. Cassandra does not support transactions like a\nrelational database, so there no rollback functionality to fall back on.</p>\n</div>\n</div>\n</div>\n</div>\n<div>\n<h2 id=\"user-content-change-log-table\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#change-log-table\"></a>Change Log Table</h2>\n<div>\n<div>\n<p>All schema changes are recorded in the change log table, <em>cassalog</em>. The table\nwill be created the first time Cassalog is run. Change log data looks like,</p>\n</div>\n<div>\n<div>\n<pre>bucket | revision | applied_at               | author | description | hash         | version  | tags\n--------+----------+--------------------------+--------+-----------------------------------------------------+\n     0 |        0 | 2016-01-28 11:09:54-0500 | admin | First table  | 0xe361957eeb |      1.0 | {'legacy'}\n     0 |        1 | 2016-01-28 11:09:54-0500 | admin | Second table | 0xf336e725d4 |      1.1 | {'legacy'}\n     0 |        2 | 2016-01-28 11:09:55-0500 | admin | Third table  | 0xcecef5f840 |      1.2 | {'legacy', 'dev'}\n     0 |        3 | 2016-01-28 11:09:55-0500 | admin | Fourth table | 0x4b5d24b77c |      1.3 | {'legacy'}</pre>\n</div>\n</div>\n<div>\n<p>Here is a brief overview of the schema.</p>\n</div>\n<div>\n<div>\n<pre>CREATE TABLE cassalog (\n    bucket int,\n    revision int,\n    applied_at timestamp,\n    author text,\n    description text,\n    hash blob,\n    version text,\n    tags set&lt;text&gt;,\n    PRIMARY KEY (bucket, revision)\n)</pre>\n</div>\n</div>\n<div>\n<p><strong>author</strong><br />The username, or email address, etc. of the person making the change. This is\nan optional field and can be null.</p>\n</div>\n<div>\n<p><strong>description</strong><br />A summary of the changes. This is an optional field and can be null.</p>\n</div>\n<div>\n<p><strong>hash</strong><br />Cassalog does not store the CQL statements that it executes. Instead it stores a\nhash that uniquely identifies the CQL statement(s). Cassalog generates this\nhash value.</p>\n</div>\n<div>\n<p><strong>version</strong><br />The version can be an arbitrary string. It should be a unique identifier for the\nchange; however, Cassalog does not enforce uniqueness. This is a required field.</p>\n</div>\n<div>\n<p><strong>tags</strong><br />An optional set of user-supplied tags.</p>\n</div>\n<div>\n<p><strong>revision</strong><br />Cassalog assigns a revision number to each change that it applies. It uses the\nrevision number to keep track of the order in which changes are applied. If the\norder of schema changes in a source script is changed, then a\nChangeSetAlteredException will be thrown.</p>\n</div>\n<div>\n<p><strong>bucket</strong><br />Cassalog stores multiple rows per physical partition. This is a revision offset.\nThe bucket size defaults to 100.</p>\n</div>\n</div>\n</div>\n<div>\n<h2 id=\"user-content-building-from-source\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#building-from-source\"></a>Building from Source</h2>\n<div>\n<div>\n<p>Cassandra is built with Maven and requires a JVM version 1.7 or later. Test\nexecution requires a running Cassandra cluster (which can be a single node) with\na node listening on 127.0.0.1. Cassandra 2.0 or later should be used.</p>\n</div>\n<div>\n<div>\n<div class=\"highlight highlight-source-shell\"><pre>git clone https://github.com/jsanda/cassalog.git\ncd cassalog\nmvn install</pre></div>\n</div>\n</div>\n<div>\n<table><tbody><tr><td>\n</td>\n<td>\nIf you want to build without having a running Cassandra instance, you can\nrun <code>mvn install -DskipTests</code>\n</td>\n</tr></tbody></table></div>\n</div>\n</div>\n<div>\n<h2 id=\"user-content-setting-up-cassandra-for-development-or-testing\"><a class=\"anchor\" aria-hidden=\"true\" href=\"#setting-up-cassandra-for-development-or-testing\"></a>Setting up Cassandra for development or testing</h2>\n<div>\n<div>\n<p>As Cassalog evolves and looks to support different versions of Cassandra and\nCQL, ccm is the likely tool of choice to use for testing against different\nversions.</p>\n</div>\n</div>\n</div></article>"}}]}},"pageContext":{"alternative_id":11609}}