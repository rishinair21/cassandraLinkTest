{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Consider the Apache Cassandra database","alternative_id":5121,"content":"<p class=\"dw-article-subhead\">What are the pros and cons of this NoSQL database?</p>\n                                        <!-- Article Top Bar -->\n                                                <div class=\"ibm-columns dw-article-topbar\" readability=\"37\">\n                                                    <!-- Author and article info. -->\n                                                    <div class=\"ibm-col-6-2 ibm-col-medium-6-4 dw-article-metadata\" readability=\"34\">\n                                                        <div class=\"dw-article-avatar\"><img width=\"42\" height=\"42\" src=\"https://www.ibm.com/developerworks/i/p-sperera.jpg\" alt=\"Photo of Srinath Perera\"/></div><p>Srinath Perera<br/>Published on July 03,  2012</p>\n                                                    </div>\n                                                    <!-- Social -->\n                                                    <div class=\"ibm-col-6-2 ibm-col-medium-6-4 ibm-col-small-6-2 dw-article-social\">\n                                                        <!-- Sharing links -->\n                                                        \n                                                        <!-- Number of comments and link to comments -->\n                                                        <div id=\"dw-article-cmts\">\n                                                            <div class=\"dw-article-cmtslink\">\n                                                                <a onclick=\"tocLink('#icomments')\" href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#icomments\" role=\"link\" tabindex=\"0\" aria-label=\"Comments\">\n                                                                    <img src=\"https://dw1.s81c.com/developerworks/i/v18/article/dw-article-cmt-icon.png\" width=\"29\" height=\"29\" alt=\"Comments\"/></a>\n                                                            </div>\n                                                            \n                                                        </div>\n                                                    </div>\n                                                </div>\n                                        <!-- Article Body -->\n                                        \n                                        <p>In the database history article \"What Goes Around Comes Around,\" (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related topics</a>) Michal Stonebraker\n                describes in detail how storage techniques have evolved over time. Before\n                arriving at the relational model, developers tried other models such as\n                hierarchical and directed graph. It is worth noting that the SQL-based\n                relational model—which is the de facto standard even\n                    now—has prevailed for about 30 years. Given the short\n                history and fast pace of computer science, this is a remarkable\n                achievement. The relational model is so well-established that for many\n                years, selecting data storage for an application was an easy choice for\n                the solution architect. The choice was invariably a relational database. </p><p>Developments like increasing user bases of systems, mobile devices,\n                extended online presence of users, cloud computing, and multi-core systems\n                have led to increasingly large-scale systems. High-tech companies such as\n                Google and Amazon were among first to hit those problems of scale. They\n                soon found out that relational databases are not adequate to support\n                large-scale systems. </p><p>To circumvent those challenges, Google and Amazon came up with two\n                alternative solutions: Big Table and Dynamo (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related topics</a>) where they relaxed the\n                guarantees provided by the relational data model to achieve higher\n                scalability. Eric Brewer's \"CAP Theorem\" (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related topics</a>) later formalized those observations. It claims\n                that for scalable systems, consistency, availability, and partition\n                tolerance are trade-offs where it is impossible to build systems\n                containing all those properties. Soon, based on earlier work by Google and\n                Amazon, and understanding acquired about scalable systems, a new class of\n                storage systems was proposed. They were named \"NoSQL\" systems. The name\n                first meant \"do not use SQL if you want to scale\" and later it was\n                redefined to \"not only SQL\" to mean that there are other solutions in\n                addition to SQL-based solutions.</p><p>There are many NoSQL systems, and each relaxes or alters some aspect of the\n                relational model. It is worth noting that none of the NoSQL solutions work\n                for all scenarios. Each does better than relational models and scales for\n                some subsets of the use cases. My earlier article \"Finding the Right Data\n                Solution for Your Application in the Data Storage Haystack\" discusses how\n                to match application requirements to NoSQL solutions (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related topics</a>). </p><p>Apache Cassandra (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related topics</a>) is\n                one of the first and most widely used NoSQL solutions. This article takes\n                a detailed look at Cassandra and points out details and tricky points not\n                readily apparent when you look at Cassandra for the first time. </p><h2 id=\"2ApacheCassandra\" class=\"ibm-h2\">Apache\n                Cassandra</h2><p>Cassandra is a NoSQL Column family implementation supporting the Big Table\n                data model using the architectural aspects introduced by Amazon Dynamo.\n                Some of the strong points of Cassandra are: </p><ul class=\"ibm-bullet-list\"><li>Highly scalable and highly available with no single point of\n                    failure</li><li>NoSQL column family implementation</li><li>Very high write throughput and good read throughput</li><li>SQL-like query language (since 0.8) and support search through\n                    secondary indexes</li><li>Tunable consistency and support for replication</li><li>Flexible schema</li></ul><p>These positive points make it easy to recommend Cassandra, but it is\n                crucial for a developer to delve into the details and tricky points of\n                Cassandra to grasp the intricacies of this program. </p><p>Cassandra stores data according to the column family data model, depicted\n                in <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#fig1\">Figure 1</a>.</p><h5 id=\"fig1\" class=\"ibm-h5\">Figure 1. Cassandra data model</h5><img src=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/figure001.gif\" class=\"ibm-downsize\" alt=\"Diagram showing column and row relationships in keyspaces\" height=\"507\" width=\"576\"/><div class=\"ibm-common-overlay ibm-overlay-alt-three\" data-widget=\"overlay\" id=\"N10096\"><img alt=\"Diagram showing column and row relationships in keyspaces\" src=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/figure001.gif\" width=\"576\"/></div><div class=\"dw-article-sidebar ibm-background-cool-white-20\" readability=\"9\"><h5>What is a Column?</h5><p><em>Column</em> is bit of a misnomer, and possibly the name\n                        <em>cell</em> would have been easier to understand. I will stick\n                    with <em>column</em> as that is the common usage.</p></div><p>Cassandra data model consists of columns, rows, column families, and\n                keyspace. Let's look at each part in detail. </p><ul class=\"ibm-bullet-list\" readability=\"11\"><li> Column – the most basic unit in the Cassandra data model, and each\n                    column consists of a name, a value, and a timestamp. For this\n                    discussion, ignore the timestamp, and then you can represent a column\n                    as a name value pair (such as author=\"Asimov\"). </li><li readability=\"15\"> Row – a collection of columns labeled with a name. For example, <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#list1\">Listing 1</a> shows how a row might be represented:\n                        <h5 id=\"list1\" class=\"ibm-h5\">Listing 1. Example of a\n                        row</h5><pre data-widget=\"syntaxhighlighter\" class=\"brush: js; html-script: true; gutter: true;\">    \"Second Foundation\"-&gt; {\n    author=\"Asimov\", \n    publishedDate=\"..\",\n    tag1=\"sci-fi\", tag2=\"Asimov\"\n    }</pre><p>Cassandra\n                        consists of many storage nodes and stores each row within a single\n                        storage node. Within each row, Cassandra always stores columns\n                        sorted by their column names. Using this sort order, Cassandra\n                        supports slice queries where given a row, users can retrieve a\n                        subset of its columns falling within a given column name range.\n                        For example, a slice query with range tag0 to tag9999 will get all\n                        the columns whose names fall between tag0 and tag9999.</p></li><li readability=\"10\"> Column family – a collection of rows labeled with a name. <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#list2\">Listing 2</a> shows how sample data might look:\n                        <h5 id=\"list2\" class=\"ibm-h5\">Listing 2. Example of a column\n                            family</h5><pre data-widget=\"syntaxhighlighter\" class=\"brush: js; html-script: true; gutter: true;\">    Books-&gt;{\n    \"Foundation\"-&gt;{author=\"Asimov\", publishedDate=\"..\"},\n    \"Second Foundation\"-&gt;{author=\"Asimov\", publishedDate=\"..\"},\n    …\n    }</pre><p>It\n                        is often said that a column family is like a table in a relational\n                        model. As shown in the following example, the similarities end\n                        there. </p></li><li> Keyspace – a group of many column families together. It is only a\n                    logical grouping of column families and provides an isolated scope for\n                    names. </li></ul><p>Finally, super columns reside within a column family that groups several\n                columns under a one key. As developers discourage the use of super\n                columns, I do not discuss them here. </p><h2 id=\"3CassandravsRDBMSdatamodels\" class=\"ibm-h2\">Cassandra\n                versus RDBMS data models</h2><p>From the above description of the Cassandra data model, data is placed in a\n                two dimensional (2D) space within each column family. To retrieve data in\n                a column family, users need two keys: row name and column name. In that\n                sense, both the relational model and Cassandra are similar, although there\n                are several crucial differences. </p><ul class=\"ibm-bullet-list\"><li> Relational columns are homogeneous across all rows in the table. A\n                    clear vertical relationship usually exists between data items, that is\n                    not the case with Cassandra columns. This is the reason Cassandra\n                    stores the column name with each data item (column). </li><li> With the relational model, 2D data space is complete. Each point in\n                    the 2D space should have at least the null value stored there. Again,\n                    this is not the case with Cassandra, and it can have rows containing\n                    only a few items, while other rows can have millions of items. </li><li> With a relational model, the schema is predefined and cannot be\n                    changed at runtime, while Cassandra lets users change the schema at\n                    runtime. </li><li> Cassandra always stores data such that columns are sorted based on\n                    their names. This makes it easier to search for data through a column\n                    using slice queries, but it is harder to search for data through a row\n                    unless you use an order-preserving partitioner. </li><li> Another crucial difference is that column names in RDMBS represent\n                    metadata about data, but never data. In Cassandra, however, the names\n                    of columns can include data. Consequently, Cassandra rows can have\n                    millions of columns, while a relational model usually has tens of\n                    columns. </li><li>Using a well-defined immutable schema, relational models support\n                    sophisticated queries that include JOINs, aggregations, and more. With\n                    a relational model, users can define the data schema without worrying\n                    about queries. Cassandra does not support JOINs and most SQL search\n                    methods. Therefore, schema has to be catered to the queries required\n                    by the application. </li></ul><p>To explore the above differences, consider a book rating site where users\n                can add books (author, rank, price, link), comments (text, time, name),\n                and tag them. The Application needs to support the following operations by\n                the users: </p><ul class=\"ibm-bullet-list\"><li> Adding books </li><li> Adding comments for books </li><li> Adding tags for books</li><li> Listing books sorted by rank</li><li> Listing books given a tag </li><li> Listing the comments given a book ID</li></ul><p>It is rather trivial to implement the above application with a relational\n                model. <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#fig2\">Figure 2</a> shows the Entity–relationship (ER)\n                diagram for the database design. </p><h5 id=\"fig2\" class=\"ibm-h5\">Figure 2. ER Model for the Book rating\n                    site</h5><img src=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/figure002.gif\" class=\"ibm-downsize\" alt=\"Flow diagram of the book site data model\" height=\"289\" width=\"524\"/><div class=\"ibm-common-overlay ibm-overlay-alt-three\" data-widget=\"overlay\" id=\"N10100\"><img alt=\"Flow diagram of the book site data model\" src=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/figure002.gif\" width=\"524\"/></div><p> Let's see how this can be implemented using the Cassandra data model. <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#list3\">Listing 3</a> shows a potential schema with Cassandra,\n                where the first line represents the \"Books\" column family which has\n                multiple rows, each having properties of the book as columns. &lt;TS1&gt;\n                and &lt;TS2&gt; denote timestamps. </p><h5 id=\"list3\" class=\"ibm-h5\">Listing 3. Cassandra schema for the book rating\n                sample</h5><pre data-widget=\"syntaxhighlighter\" class=\"brush: js; html-script: true; gutter: true;\">Books[BookID-&gt;(author, rank, price, link, tag&lt;TS1&gt;, tag&lt;TS2&gt; .., \n    cmt+&lt;TS1&gt;= text + \"-\" + author) …] \nTags2BooksIndex[TagID-&gt;(&lt;TS1&gt;=bookID1, &lt;TS2&gt;=bookID2, ..) ] \nTags2AuthorsIndex[TagID-&gt;(&lt;TS1&gt;=bookID1, &lt;TS2&gt;=bookID2, ..) ]\nRanksIndex[\"RANK\" -&gt; (rank&lt;TS1&gt;=bookID)]</pre><p><a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#table1\">Table 1</a> is a sample data set as per the schema. </p><h5 id=\"table1\" class=\"ibm-h5\">Table 1. Sample data for the book\n                    rating site</h5><table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" data-widget=\"datatable\" summary=\"Sample data for the book rating site\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th class=\"ibm-background-neutral-white-30\"> Column Family\n                            Name </th><th class=\"ibm-background-neutral-white-30\"> Sample Dataset\n                        </th></tr></thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" readability=\"10\"><tr readability=\"16\"><td> Books</td><td>\"Foundation\" -&gt;\n                            (\"author\"=\"Asimov\", \"rank\"=9, \"price\"=14, \"tag1\"=\"sci-fi\",\n                            \"tag2\"=\"future\", \"cmt1311031405922\"=\"best book-sanjiva\",\n                            \"cmt1311031405923\"=\"well I disagree-srinath\")<br/>\"I Robot\"\n                            -&gt; (\"author\"=\"Asimov\", \"rank\"=7, \"price\"=14,\n                            \"tag1\"=\"sci-fi\" \"tag2\"=\"robots\", \"cmt1311031405924\"=\"Asimov's\n                            best-srinath\", \"cmt1311031405928\"=\"I like foundation\n                            better-sanjiva\")<br/></td></tr><tr readability=\"2\"><td> RanksIndex </td><td> \"Rank\" -&gt; (9=\"Foundation\", 7=\"I\n                            Robot\") </td></tr><tr readability=\"2\"><td> Tags2BooksIndex <br/></td><td> \"sci-fi\" -&gt;\n                            (\"1311031405918\"=\"Foundation\", \"1311031405919\"=\"I Robot\"<br/>\"future\" -&gt; …<br/></td></tr><tr readability=\"1\"><td> Tags2AuthorsIndex </td><td> \"sci-fi\" -&gt;\n                            (1311031405920=\"Asimov\")<br/>\"future\" -&gt; … </td></tr></tbody></table><p>This example shows several design differences between the relational and\n                Cassandra models. The Cassandra model stores data about books in a single\n                column family called \"Books,\" and the other three Column Families are\n                indexes built to support queries. </p><p>Looking at the \"Books\" column family in detail, the model uses a row to\n                represent each book where a book name is the row ID. Details about the\n                book are represented as columns stored within the row. </p><p>Looking closely, you might notice that data items stored (like comments,\n                and tags that have 1:M relationship with books) are also within a single\n                row. To do that, append the time stamp to the column names for tags and\n                comments. This approach stores all data within the same column. This\n                action avoids having to do JOINs to retrieve data. Cassandra circumvents\n                the lack of support for JOINs through this approach.</p><p>This provides several advantages.</p><ul class=\"ibm-bullet-list\"><li>You can read all data about a book through a single query reading the\n                    complete row. </li><li>You can retrieve comments and tags without a JOIN by using slice\n                    queries that have cmt0-cmt9999 and tag0-tag9999 as starting and ending\n                    ranges. </li></ul><p>Because Cassandra stores columns sorted by their column names, making slice\n                queries is very fast. It is worth noting that storing all the details\n                about the data item in a single row and the use of sort orders are the\n                most crucial ideas behind the Cassandra data design. Most Cassandra data\n                model designs follow these ideas in some form. User can use the sort\n                orders while storing data and building indexes. For example, another side\n                effect of appending time stamps to column names is that as column names\n                are stored in the sorted order, comments having column names post-fixed by\n                the timestamps are stored in the order they are created, and search\n                results would have the same order. </p><p>Cassandra does not support any search methods from the basic design.\n                Although it supports secondary indexes, they are supported using indexes\n                that are built later, and secondary indexes have several limitations\n                including lack of support for range queries. </p><p>Consequently, the best results in a Cassandra data design needs users to\n                implement searches by building custom indexes and utilizing column and row\n                sort orders. Other three-column families (Tags2BooksIndex,\n                Tags2AuthorsIndex, and RankIndex) do exactly that. Since users need to\n                search for books given a tag, \"Tags2BooksIndex\" column family builds an\n                index by storing the tag name as the row ID and all books tagged by that\n                tag as columns under that row. As shown by the example, timestamps are\n                added as the column keys, but that is to provide a unique column ID. The\n                search implementation simply reads the index by looking up the row by tag\n                name and finding the matches by reading all columns stored within that\n                rowID. </p><p><a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#table2\">Table 2</a> discusses how each of the queries required by\n                the application is implemented using the above Cassandra indexes. </p><h5 id=\"table2\" class=\"ibm-h5\">Table 2. Comparison of query\n                    implementations</h5><table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" data-widget=\"datatable\" summary=\"Comparison of query implementations\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th class=\"ibm-background-neutral-white-30\"> Query\n                            description </th><th class=\"ibm-background-neutral-white-30\"> Query as SQL </th><th class=\"ibm-background-neutral-white-30\"> Cassandra\n                            implementation </th></tr></thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" readability=\"12\"><tr readability=\"8\"><td> List books sorted by the\n                            rank</td><td> Run the\n                            query <br/><code>\"Select * from Books order by rank\"</code>\n                            and then on each result do\n                            <code>\"Select tag from Tags where\n                            bookid=?\" and \"Select comment from Comments where\n                            bookid=?\"</code></td><td> Do a slice query on \"RankIndex\"\n                            column family to receive an ordered list of books, and for\n                            each book do a slice query on \"Books\" column family to read\n                            the details about the book. </td></tr><tr readability=\"5\"><td> Given a tag, find the authors\n                            whose books have the given tag. </td><td><code>Select distinct author from Tags, Books where\n                            Tags.bookid=Books.bookid and tag=?</code></td><td> Read all columns for the given tag\n                            from Tags2Authors using a slice query. </td></tr><tr readability=\"4\"><td> Given a tag, list books that have\n                            the given tag. </td><td><code>Select bookid from Tags where tag=? </code></td><td> Read all columns for the given tag\n                            from Tags2BooksIndex using a slice query. </td></tr><tr readability=\"10\"><td> Given a book, list the comments\n                            for that book in sorted order of the time when the comments\n                            were created. </td><td><code>Select text, time, user from Comments where bookid=? Order by\n                            time</code></td><td> In \"Books\" column family, do a\n                            slice query from the row corresponding to the given book. They\n                            are in sorted order due to timestamps used as the column name.\n                        </td></tr></tbody></table><p>Although the above design can efficiently support queries required by the\n                book-rating site, it can only support queries that it is designed for and\n                cannot support ad-hoc queries. For example, it cannot do the following\n                queries without building new indexes. </p><ul class=\"ibm-bullet-list\"><li><code>Select * from Books where price &gt; 50; </code></li><li><code>Select * from Books where author=\"Asimov\"</code></li></ul><p>It is possible to change the design to support those and other queries by\n                either building appropriate indexes or by writing code to walk through the\n                data. The need for custom code to support new queries, however, is a\n                limitation compared to relational models where adding new queries often\n                needs no changes to the schema. </p><p>From the 0.8 release, Cassandra supports secondary indexes where users can\n                specify a search by a given property, and Cassandra automatically builds\n                indexes for searching based on that property. That model, however,\n                provides less flexibility. For example, secondary indexes do not support\n                range queries and provide no guarantees on sort orders of results. </p><h2 id=\"4UsingCassandrafromJavaoutline\" class=\"ibm-h2\">Using Cassandra from the Java environment</h2><p>Cassandra has many clients written in different languages. This article\n                focuses on the Hector client (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related\n                    topics</a>), which is the most widely used Java client for Cassandra.\n                Users can add to their application by adding the Hector JARs to the\n                application classpath. <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#list4\">Listing 4</a> shows a sample\n                Hector client. </p><p>First, connect to a Cassandra cluster. Use the instructions in the\n                Cassandra Getting Started Page (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related\n                    topics</a>) to set up a Cassandra node. Unless its configuration has\n                been changed, it typically runs on port 9160. Next, define a keyspace.\n                This can be done either through the client or through the\n                conf/cassandra.yaml configuration file.</p><h5 id=\"list4\" class=\"ibm-h5\">Listing 4. Sample Hector client code for\n                Cassandra</h5><pre data-widget=\"syntaxhighlighter\" class=\"brush: js; html-script: true; gutter: true;\">Cluster cluster = HFactory.createCluster('TestCluster', \n        new CassandraHostConfigurator(\"localhost:9160\"));\n//define a keyspace\nKeyspace keyspace = HFactory.createKeyspace(\"BooksRating\", cluster);\n//Now let's add a new column. \nString rowID = \"Foundation\"; \nString columnFamily = \"Books\";\nMutator&lt;String&gt;\n mutator = HFactory.createMutator(keyspace, user);\nmutator.insert(rowID, columnFamily, \n        HFactory.createStringColumn(\"author\", \"Asimov\"));\n//Now let's read the column back \nColumnQuery&lt;String, String, String&gt;\n        columnQuery = HFactory.createStringColumnQuery(keyspace);\ncolumnQuery.setColumnFamily(columnFamily).setKey(”wso2”).setName(\"address\");\nQueryResult&lt;HColumn&lt;String, String&gt;\n result = columnQuery.execute();\nSystem.out.println(\"received \"+ result.get().getName() + \"= \" \n        + result.get().getValue() + \" ts = \"+ result.get().getClock());</pre><p>Find the complete code for the book rating example in <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artdownload\">Download</a>. It includes samples for slice\n                queries and other complex operations. </p><h2 id=\"5CassandraArchitecture\" class=\"ibm-h2\">Cassandra\n                architecture</h2><p>Having looked at the data model of Cassandra, let's return to its\n                architecture to understand some of its strengths and weaknesses from a\n                distributed systems point of view. </p><p><a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#fig3\">Figure 3</a> shows the architecture of a Cassandra cluster.\n                The first observation is that Cassandra is a distributed system. Cassandra\n                consists of multiple nodes, and it distributes the data across those nodes\n                (or shards them, in the database terminology). </p><h5 id=\"fig3\" class=\"ibm-h5\">Figure 3. Cassandra cluster</h5><img src=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/figure003.gif\" class=\"ibm-downsize\" alt=\"Diagram for the cassandra cluster showing how each node is connected in a loop\" height=\"434\" width=\"471\"/><div class=\"ibm-common-overlay ibm-overlay-alt-three\" data-widget=\"overlay\" id=\"N101FA\"><img alt=\"Diagram for the cassandra cluster showing how each node is connected in a loop\" src=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/figure003.gif\" width=\"471\"/></div><p>Cassandra uses consistent hashing to assign data items to nodes. In simple\n                terms, Cassandra uses a hash algorithm to calculate the hash for keys of\n                each data item stored in Cassandra (for example, column name, row ID). The\n                hash range or all possible hash values (also known as keyspace) is divided\n                among the nodes in the Cassandra cluster. Then Cassandra assigns each data\n                item to the node, and that node is responsible for storing and managing\n                the data item. The paper \"Cassandra - A Decentralized Structured Storage\n                System\" (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related topics</a>) provides a\n                detailed discussion about Cassandra architecture. </p><p>The resulting architecture provides the following properties: </p><ul class=\"ibm-bullet-list\"><li> Cassandra distributes data among its nodes transparently to the\n                    users. Any node can accept any request (read, write, or delete) and\n                    route it to the correct node even if the data is not stored in that\n                    node.</li><li> Users can define how many replicas are needed, and Cassandra handles\n                    replica creation and management transparently. </li><li> Tunable consistency: When storing and reading data, users can choose\n                    the expected consistency level per each operation. For example, if the\n                    \"quorum\" consistency level is used while writing or reading, data is\n                    written and read from more than half of the nodes in the cluster.\n                    Support for tunable consistency enables users to choose the\n                    consistency level best suited to the use case.</li><li> Cassandra provides very fast writes, and they are actually faster\n                    than reads where it can transfer data about 80-360MB/sec per node. It\n                    achieves this using two techniques. <ul class=\"ibm-bullet-list\"><li> Cassandra keeps most of the data within memory at the\n                            responsible node, and any updates are done in the memory and\n                            written to the persistent storage (file system) in a lazy\n                            fashion. To avoid losing data, however, Cassandra writes all\n                            transactions to a commit log in the disk. Unlike updating data\n                            items in the disk, writes to commit logs are append-only and,\n                            therefore, avoid rotational delay while writing to the disk.\n                            For more information on disk-drive performance\n                            characteristics, see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related\n                                topics</a>.</li><li> Unless writes have requested full consistency, Cassandra\n                            writes data to enough nodes without resolving any data\n                            inconsistencies where it resolves inconsistencies only at the\n                            first read. This process is called \"read repair.\" </li></ul></li></ul><p>The resulting architecture is highly scalable. You can build a Cassandra\n                cluster that has 10s of 100s of nodes that is capable of handling\n                terabytes to petabytes of data. There is a trade-off with distributed\n                systems, and scale almost never comes for free. As mentioned before, a\n                user might face many surprises moving from a relational database to\n                Cassandra. The next section discusses some of them. </p><h2 id=\"6SurpriseyoumightgetwithCassandra\" class=\"ibm-h2\">Possible surprises with Cassandra</h2><p>Be aware of these differences when you move from a relational database to\n                Cassandra.</p><h3 id=\"N10222\" class=\"ibm-h3\">No transactions, no JOINs</h3><p>It is well known that Cassandra does not support ACID transactions.\n                Although it has a batch operation, there is no guarantee that\n                sub-operations within the batch operation are carried out in an atomic\n                fashion. This will be discussed more under <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#failedops\">Failed\n                    operations may leave changes</a>. </p><p>Furthermore, Cassandra does not support JOINs. If a user needs to join two\n                column families, you must retrieve and join data programmatically. This is\n                often expensive and time-consuming for large data sets. Cassandra\n                circumvents this limitation by storing as much data as possible in the\n                same row, as described in the example. </p><h3 id=\"N1022F\" class=\"ibm-h3\">No foreign keys and keys are\n                immutable</h3><p>Cassandra does not support foreign keys, so it is not possible for\n                Cassandra to manage the data consistency on a user's behalf. Therefore,\n                the application should handle the data consistency. Furthermore, users\n                cannot change the keys. It is recommended to use surrogate keys (generated\n                keys instead of the key, and managing the key as a property) with the use\n                cases that need changes to the keys. </p><h3 id=\"N10236\" class=\"ibm-h3\">Keys have to be unique</h3><p>Each key, for example row keys and column keys, has to be unique in its\n                scope, and if the same key has been used twice it will overwrite the data. </p><p>There are two solutions to this problem. First, you can use a composite\n                key. In other words, create the key by combining several fields together,\n                and this solution is often used with row keys. The second solution is when\n                there is a danger of the same key occurring twice, postfix the key with a\n                random value or a timestamp. This often happens with indexes when an index\n                stores a value as the column name. For example, in the book rating\n                application the rank was used as the column name. To avoid having two\n                entries having the same column name because both have the same rank, the\n                timestamp is added to the rank as a postfix. </p><h3 id=\"failedops\" class=\"ibm-h3\">Failed operations may leave\n                changes</h3><p>As explained before, Cassandra does not support atomic operations. Instead,\n                it supports idempotent operations. Idempotent operations leave the system\n                in the same state regardless of how many times the operations are carried\n                out. All Cassandra operations are idempotent. If an operation fails, you\n                can retry it without any problem. This provides a mechanism to recover\n                from transient failures. </p><p>Also Cassandra supports batch operations, but they do not have any\n                atomicity guarantees either. Since the operations are idempotent, the\n                client can keep retrying until all operations of the batch are successful. </p><p>Idempotent operations are not equal to atomic operations. If an operation\n                is successful, all is well and the outcome is identical to atomic\n                operations. If an operation fails, the client can retry, and if it is\n                successful, again all is well. If, however, the operations fails even\n                after retrying, unlike with atomic operations, it might leave side\n                effects. Unfortunately, with Cassandra, this is a complexity that\n                programmers have to deal with themselves. </p><h3 id=\"N1024A\" class=\"ibm-h3\">Searching is complicated</h3><p>Searching is not built into the core of the Cassandra architecture, and\n                search mechanisms are layered on top using sort orders as described\n                earlier. Cassandra supports secondary indexes where the system\n                automatically builds them, with some limited functionality. When secondary\n                indexes do not work, users have to learn the data model and build indexes\n                using sort orders and slices. </p><p>Three types of complexities area associated with building search\n                methods:</p><ol type=\"1\"><li> Building custom search methods require programmers to understand\n                    indexing and details about storage to a certain extent. Therefore,\n                    Cassandra needs higher skilled developers than with relational models. </li><li> Custom indexes heavily depend on sorted orders, and they are\n                    complicated. There are two types of sort orders: first, the columns\n                    are always sorted by name, and second, the row sort orders work only\n                    if an order-preserving partitioner (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related topics</a>) is used. </li><li> Adding a new query often needs new indexes and code changes unlike\n                    with relational models. This requires developers to analyze queries\n                    before storing the data. </li></ol><h3 id=\"N1025F\" class=\"ibm-h3\">Super columns and order preserving\n                partitioners are discouraged</h3><p>Cassandra super columns can be useful when modeling multi-level data, where\n                it adds one more level to the hierarchy. Anything that can be modeled with\n                super columns, however, can also be supported through columns. Hence,\n                super columns do not provide additional power. Also, they do not support\n                secondary indexes. Therefore, the Cassandra developers discourage the use\n                of super columns. Although there is no firm date for discontinuing\n                support, it might happen in future releases. </p><p>A partitioner in Cassandra decides how to distribute (shard) data among\n                Cassandra nodes, and there are many implementations. If an\n                order-preserving partitioner is used, rowIDs are stored in a sorted order\n                and Cassandra can do slices (searches) across rowIDs as well. This\n                partitioner does not distribute the data uniformly among its nodes,\n                however, and with large datasets, some of the nodes might be hard-pressed\n                while others are lightly loaded. Therefore, developers also discourage the\n                use of order-preserving partitioners.</p><h3 id=\"N10268\" class=\"ibm-h3\">Healing from failure is\n                manual</h3><p>If a node in a Cassandra cluster has failed, the cluster will continue to\n                work if you have replicas. Full recovery, which is to redistribute data\n                and compensate for missing replicas, is a manual operation through a\n                command line tool called <em>node tool</em> (see <a href=\"https://www.ibm.com/developerworks/library/os-apache-cassandra/index.html#artrelatedtopics\">Related topics</a>). Also, while the manual\n                operation happens, the system will be unavailable. </p><h3 id=\"N10276\" class=\"ibm-h3\">It remembers deletes</h3><p>Cassandra is designed such that it continues to work without a problem even\n                if a node goes down (or gets disconnected) and comes back later. A\n                consequence is this complicates data deletions. For example, assume a node\n                is down. While down, a data item has been deleted in replicas. When the\n                unavailable node comes back on, it will reintroduce the deleted data item\n                at the syncing process unless Cassandra remembers that data item has been\n                deleted. </p><p>Therefore, Cassandra has to remember that the data item has been deleted.\n                In the 0.8 release, Cassandra was remembering all the data even if it is\n                deleted. This caused disk usage to keep growing for update-intensive\n                operations. Cassandra does not have to remember all the deleted data, but\n                just the fact that a data item has been deleted. This fix was done in\n                later releases of Cassandra. </p><h2 id=\"7Conclusionoutline\" class=\"ibm-h2\">Conclusion</h2><p>This article delves into some details that are not readily apparent when\n                you consider Cassandra. I described the Cassandra data model, comparing it\n                with the relational data model, and demonstrated a typical schema design\n                with Cassandra. A key observation is that unlike the relational model that\n                breaks data into many tables, Cassandra tends to keep as much as data as\n                possible within the same row to avoiding having to join that data for\n                retrieval.</p><p>You also looked at several limitations of the Cassandra-based approach.\n                These limitations, however, are common to most NoSQL solutions, and are\n                often conscious design trade-offs to enable high scalability. </p><!--CMA ID: 823612--><!--Site ID: 1--><!--XSLT stylesheet used to transform this file: dw-document-html-8.0.xsl-->\n                                        <!-- Article Quiz -->\n                                        \n                                        <!-- Article Resources -->\n                                        <h4 id=\"artdownload\" class=\"ibm-h4\">Downloadable resources</h4><h4 id=\"artrelatedtopics\" class=\"ibm-h4\">Related topics</h4><ul><li>Read <a href=\"http://idke.ruc.edu.cn/seminars/phd/2007/11.07/What%20Goes%20Around%20Comes%20Around.pdf\">What goes around comes around</a> (Michael Stonebraker and Joey\n                    Hellerstein, 2007), if you are interested about the history of storage\n                    technologies.</li><li>Read <a href=\"http://wiki.apache.org/cassandra/GettingStarted\">Getting Started Page</a> in the Cassandra Wiki to install\n                    Cassandra, run single node Cassandra, and find an overview of how to\n                    configure multinode clusters.</li><li>Read the paper, <a href=\"http://www.cs.cornell.edu/Projects/ladis2009/papers/Lakshman-ladis2009.PDF\">Cassandra - A Decentralized Structured Storage System</a>\n                    (Avinash Lakshman and Prashant Malik, 2009) to understand the\n                    Cassandra architecture in more detail.</li><li>Read more about Google's <a href=\"http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/bigtable-osdi06.pdf\">Big Table</a> and Amazon's <a href=\"http://db.cs.pitt.edu/courses/cs3551/11-1/handouts/10-1.1.1.115.1568.pdf\">Dynamo</a>.</li><li>Read about Eric Brewer's <a href=\"http://www.julianbrowne.com/article/viewer/brewers-cap-theorem\">CAP theorem</a> (Julian Browne, January 2009).</li><li>See <a href=\"http://www.infoq.com/articles/perera-data-storage-haystack\">Finding the Right Data Solution for Your Application in the Data\n                        Storage Haystack</a> (Srinath Perera, InfoQ, October 2011) for an\n                    overview of NoSQL landscape and recommendations on how to choose the\n                    right NoSQL storage.</li><li>Explore <a href=\"http://cassandra.apache.org/\">Cassandra</a>\n                    on the project website.</li><li>Check out the <a href=\"https://github.com/rantav/hector\">Hector client</a> on the project website.</li><li>Learn more about <a href=\"http://en.wikipedia.org/wiki/Disk-drive_performance_characteristics\">Disk-drive performance characteristics</a> on\n                    Wikipedia.</li><li>Read about <a href=\"http://wiki.apache.org/cassandra/NodeTool\">node tool</a>, a simple command line interface to these exposed\n                    operations and attributes on the Cassandra Wiki.</li><li>Find more details about consistency levels in <a href=\"http://wiki.apache.org/cassandra/API\">the Casandra API\n                        wiki</a>. </li><li>Read more about <a href=\"http://wiki.apache.org/cassandra/StorageConfiguration\">storage configurations</a>.</li><li><a href=\"http://cassandra.apache.org/\">Download Cassandra</a>\n                    and find instructions on how to use it at\n                    cassandra.apache.org.</li><li><a href=\"https://www.ibm.com/developerworks/develop\">Start developing</a> with product trials, free downloads, and IBM\n                    Bluemix services.</li></ul><!-- Commenting --><!-- INLINE_COMMENTS_BEGIN: -->\n<div id=\"dw-article-cmts-top\" class=\"ibm-columns\" readability=\"35\">\n    <div class=\"ibm-col-6-2\" readability=\"4\">\n        \n        <div id=\"dw-article-cmts-login\" readability=\"26\">\n            <p><a onclick=\"window.location=userLinks[0].url;\" tabindex=\"0\" role=\"link\">Sign in</a> or \n                <a onclick=\"window.location=userLinks[1].url;\" tabindex=\"0\" role=\"link\">register</a> to add and subscribe to comments.</p>\n        </div>\n    </div>    \n    <p> \n        <label for=\"comment_notification\">Subscribe me to comment notifications</label>\t   \n    </p>\n</div>\n<!-- INLINE_COMMENTS_END -->                                        <!-- CENTER_6_4_CONTENT_COLUMN_END -->"}}]}},"pageContext":{"alternative_id":5121}}