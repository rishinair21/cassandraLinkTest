{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"This Team Used Apache Cassandra… You Won’t Believe What Happened Next","alternative_id":5276,"content":"<p>You know that old saying, “If it seems too good to be true, it probably is?” We technologists should probably apply that saying to database vendor claims pretty regularly.</p>\n<p>In the summer of 2014, the Parse.ly team finally kicked the tires on Apache Cassandra. I say “finally”, because after years of using other distributed database technologies on our real-time analytics problems, I was tired of hearing from technologists — even ones on my own team — saying that our problem domain was “so obviously a fit for Cassandra”, that I figured we should at least entertain the notion.</p>\n<p>After all, Cassandra is a highly-available, linearly-scalable data store. It is supposedly battle-tested at Facebook, Apple, and Netflix scale. It is supposedly the key to Netflix’s horizontal and elastic scalability in the AWS cloud. It is supposedly built to let your ops staff sleep easily at night, handling relentless write volumes of hundreds of thousands per second with ease and grace. It supposedly has an unassailable reliability model that lets you pull the plug on nodes without intervention, thanks to cluster auto-healing. And here’s the kicker — it’s supposedly optimized for Parse.ly’s data set: analytics data, and especially for time series data.</p>\n<div style=\"margin: auto;\"><a href=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/04/cassandra-e1430921268579.png\"><img data-attachment-id=\"1890\" data-permalink=\"https://blog.parse.ly/post/1822/event-loops/cassandra/\" data-orig-file=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/04/cassandra-e1430921268579.png?fit=500%2C335&amp;ssl=1\" data-orig-size=\"500,335\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}\" data-image-title=\"cassandra\" data-image-description=\"\" data-medium-file=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/04/cassandra-e1430921268579.png?fit=300%2C201&amp;ssl=1\" data-large-file=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/04/cassandra-e1430921268579.png?fit=1024%2C687&amp;ssl=1\" src=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/04/cassandra-e1430921268579.png?resize=500%2C335\" alt=\"cassandra\" width=\"500\" height=\"335\" class=\"alignnone size-full wp-image-1890\" data-recalc-dims=\"1\" /></a></div>\n<p>That’s a lot of “supposedly’s!”</p>\n<p>What we learned over the course of the next 6 months really, really surprised us. I think it’ll surprise you, too. We learned that Cassandra, though a very cool technology, is not a panacea for real-time analytics or time series problems. We also learned that the technology is loaded with traps that require deep knowledge of Cassandra internals to work around.</p>\n<p>We also find the technology to very much violate the “principle of least surprise” — indeed, almost every Cassandra feature has some surprising behavior.</p>\n<p>The rest of this article explores these surprises through the use of fun “Internet news style headlines” followed by a short explanation of the problem. We hope it helps other teams use Cassandra with more confidence and fewer battle scars.</p>\n<p>Here’s a preview of the headlines:</p>\n<h2>INDUSTRY SHOCKER: CQL is not SQL</h2>\n<p>Our team had studied Cassandra before the project had introduced CQL, the “Cassandra Query Language”, and the 2.x line of Cassandra releases. You would be wise to study Cassandra’s history before diving into CQL, because CQL has nothing to do with SQL, and any relationship will only lead you to surprises.</p>\n<p>You see, in Cassandra 1.x, the data model is centered around what Cassandra calls “column families”. A column family contains rows, which are identified by a row key. The row key is what you need to fetch the data from the row. The row can then have one or more columns, each of which has a name, value, and timestamp. (A value is also called a “cell”). Cassandra’s data model flexibility comes from the following facts:</p>\n<ul><li>column names are defined per-row</li>\n<li>rows can be “wide” — that is, have hundreds, thousands, or even millions of columns</li>\n<li>columns can be sorted, and ranges of ordered columns can be selected efficiently using “slices”</li>\n</ul><div style=\"margin: auto;\"><img data-attachment-id=\"1945\" data-permalink=\"https://blog.parse.ly/post/1928/cass/cass_data_model/\" data-orig-file=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/cass_data_model.png?fit=595%2C416&amp;ssl=1\" data-orig-size=\"595,416\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}\" data-image-title=\"cass_data_model\" data-image-description=\"\" data-medium-file=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/cass_data_model.png?fit=300%2C210&amp;ssl=1\" data-large-file=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/cass_data_model.png?fit=595%2C416&amp;ssl=1\" src=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/cass_data_model.png?resize=595%2C416\" alt=\"cass_data_model\" width=\"595\" height=\"416\" class=\"alignnone size-full wp-image-1945\" srcset=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/cass_data_model.png?w=595&amp;ssl=1 595w, https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/cass_data_model.png?resize=300%2C210&amp;ssl=1 300w\" data-recalc-dims=\"1\" /></div>\n<p>Cassandra’s data partitioning scheme comes from ensuring sharding and replication occurs on a row key basis. That is, ranges of row keys will establish cluster “shards”, and rows will be automatically replicated among cluster nodes.</p>\n<p>Notice that I haven’t mentioned CQL yet. That’s because, CQL tries to hide every detail I described above from you, even though this knowledge is <em>critical</em> to running a Cassandra cluster. In CQL and Cassandra 2.x, column families are renamed to “tables”. Row keys become “primary keys” on those tables. A syntax that looks like a restricted subset of SQL (SELECT, INSERT, CREATE TABLE) offers a facade on these Cassandra facilities, but with none of the underlying SQL machinations.</p>\n<p>The fact that rows can be wide or narrow falls out of how you design your CQL schema and how you use the resultant “tables” (that is, column families). We will discuss wide vs skinny rows later, so I’ll get there.</p>\n<p>Here’s the core warning: CQL is SQL in the same way JavaScript is Java. (That is, it’s <strong>not</strong>.)</p>\n<p>JavaScript was designed to look somewhat “Java-like”, because Java was trendy and well-understood by technologists when JavaScript was designed. But JavaScript is not Java. In fact, JavaScript, in all respects other than a superficial set of syntax similarities, couldn’t be more different than Java if it tried.</p>\n<p>CQL was designed to look somewhat “SQL-like”, because SQL is trendy and well-understood by technologists today. But the relationship with SQL is the same: in all respects other than the superficial, it is a completely different beast.</p>\n<p>I hope this warning helps. It will definitely help you interpret the following statement that is in Apache Cassandra’s Github README: “The Cassandra Query Language (CQL) is a close relative of SQL.” This is a false statement. You should ignore it. It’s more like a distant cousin — who later finds out she was actually adopted by her parents.</p>\n<p>The way I read this line in the README is that the developers are excited, because CQL does actually make Cassandra easier to use. It does something important for the community: it unifies the client libraries around a single way of interacting with the database, like SQL did for many SQL databases. This is A Good Thing, but it doesn’t mean that CQL is anything like SQL.</p>\n<p>There’s more to learn, so let’s keep going.</p>\n<h2>We Didn’t Use COMPACT STORAGE… You Won’t Believe What Happened Next</h2>\n<p>OK, so I cheated and re-used the headline format of this blog post itself, but I couldn’t resist. It just fit so well.</p>\n<p>What’s COMPACT STORAGE, you ask?</p>\n<p>Well, along with Cassandra 2.0 and CQL, the Cassandra project introduced some more capabilities that are built directly into CQL’s schema modeling capabilities. It tried to codify patterns from the community, specifically, ways of storing maps, lists, and sets of data inside a Cassandra row.</p>\n<p>A Cassandra row is already sort of like an ordered map, where each column is a key in the map; so, storing maps/lists/sets in a Cassandra row is like storing maps/lists/sets inside an ordered map. This is an admirable goal, since it does provide some data modeling flexibility. Cassandra calls these CQL Collections, and, like sirens singing beautiful hymns off a sun-kissed shoreline, they seem very attractive.</p>\n<p>CQL Collections required some enforced structure onto the rows that are stored in column families. This structure allows a mixture of map fields, list fields, and set fields to exist within a single logical table (remember: table = column family). Under the hood, Cassandra only knows about keys, column names, and values. So, this structure is built up by smartly inserting “marker columns” and embedding concatenated key names into column names appropriately. Imagine if in Python, rather than storing a dict in a dict, you needed to store the sub-dict keys inside the parent dict’s keys.</p>\n<pre># \"embedding\" of unstructured data\npoints = {\n    \"point1\": {\"x\": 12, \"y\": 10},\n    \"point2\": {\"x\": 8: \"y\": 3},\n    # ... and so on ...\n}\n# vs \"encoding\" of unstructured data\npoints = {\n    \"point1::\": \"dict\"\n    \"point1::x\": 12,\n    \"point1::y\": 10,\n    \"point2::\": \"dict\"\n    \"point2::x\": 8,\n    \"point2::y\": 3,\n    # ... and so on ...\n}\n</pre>\n<p>CQL Collections don’t really “embed” structure into cells, so much as they “encode” structure into columns. The cost of all of this structure: data storage on disk.</p>\n<p>To be fair, Cassandra operates with the assumption that “disk is cheap”, but in a simple example we had at Parse.ly where we attempted to use a CQL Map to store analytics data, we saw 30X data size overhead vs using a simpler storage format and Cassandra’s old storage format, now called COMPACT STORAGE. Ah, that’s where the name comes from: COMPACT, as in small, lightweight. Put another way, Cassandra and CQL’s new default storage format is NOT COMPACT, that is, large and heavyweight.</p>\n<div style=\"margin: auto;\"><a href=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/say_big_data.jpg\"><img data-attachment-id=\"1948\" data-permalink=\"https://blog.parse.ly/post/1928/cass/say_big_data/\" data-orig-file=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/say_big_data.jpg?fit=500%2C351&amp;ssl=1\" data-orig-size=\"500,351\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}\" data-image-title=\"say_big_data\" data-image-description=\"\" data-medium-file=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/say_big_data.jpg?fit=300%2C211&amp;ssl=1\" data-large-file=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/say_big_data.jpg?fit=500%2C351&amp;ssl=1\" src=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/say_big_data.jpg?resize=500%2C351\" alt=\"say_big_data\" width=\"500\" height=\"351\" class=\"alignnone size-full wp-image-1948\" srcset=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/say_big_data.jpg?w=500&amp;ssl=1 500w, https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/say_big_data.jpg?resize=300%2C211&amp;ssl=1 300w\" data-recalc-dims=\"1\" /></a></div>\n<p>Now, the whole reason we were adopting Cassandra in the first place is because we have huge datasets. Terabytes upon terabytes of raw analytics and event data. Suffering a 30X data overhead for storage (and that’s even after compression) is not a trivial matter. We were actually hoping that Cassandra could store things <strong>more compactly</strong> than our raw data, but this wasn’t happening, due to the overhead of CQL Collections and the CQL 3.0 row format.</p>\n<p>So, we did what any team that enjoys practicality over purity would do. We scrapped our hopes of using the “new shiny” and stuck with the appropriately-named COMPACT STORAGE. Though the Cassandra documentation is full of warnings about how COMPACT STORAGE is only for backwards-compatibility with CQL 2.0 and that this restricts your use of the more advanced features, what we found is that the cost of those features simply did not make sense at large data scale.</p>\n<p>This team didn’t use COMPACT STORAGE, and the result was they got storage that wasn’t compact!</p>\n<h2>REVEALED: \\x01 Separators Are Not The Ugly Hack They Appear To Be</h2>\n<p>Speaking of compact vs non-compact storage types, if we aren’t able to use Cassandra CQL 3.0 and CQL Maps to store unstructured data in Cassandra, how do we pull it off?</p>\n<p>We decided to pick an extremely simple separated-value storage format for every analytics event, each of which goes into a column that is named with that analytics event identifier and timestamp. We lovingly labeled this scheme “xsv”, because the separator we chose to use is the Unicode escape character, \\x01.</p>\n<p>So, for example, in storing a visit to a specific URL from Twitter, we might store values like this:</p>\n<pre>name=d, ts=2015-02-01T08:00:01.123Z::\nhttp://site.com/url1x01http://t.co/1234\nname=d, ts=2015-02-01T08:00:05.832Z::\nhttp://site.com/url2x01http://t.co/1235\n</pre>\n<p>The way to read the xsv values is to imagine them being unpacked by Python that looks like this:</p>\n<pre class=\"python\">&gt;&gt;&gt; url, urlref = xsv_parse(line)\n&gt;&gt;&gt; url\n\"http://site.com/url1\"\n&gt;&gt;&gt; urlref\n\"http://t.co/1234\"\n</pre>\n<p>In other words, the keys for these separated values are not stored in Cassandra itself; instead, they are stored in our serialization/deserialization code.</p>\n<p>This seems like a terribly ugly hack, but it’s actually really not.</p>\n<p>The \\x01 value shows up in a different color in Cassandra’s CQL shell, cqlsh. It is easy to split and serialize. It doesn’t require quoting of values, like traditional CSV would (because, every byte counts!). Of course, you need to worry about \\x01’s showing up in your raw data, but you can escape these, and they are quite rare.</p>\n<div style=\"margin: auto;\"><a href=\"https://i1.wp.com/blog.parse.ly/wp-content/uploads/2015/05/xsv_data.png\"><img data-attachment-id=\"1950\" data-permalink=\"https://blog.parse.ly/post/1928/cass/xsv_data/\" data-orig-file=\"https://i1.wp.com/blog.parse.ly/wp-content/uploads/2015/05/xsv_data.png?fit=777%2C434&amp;ssl=1\" data-orig-size=\"777,434\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}\" data-image-title=\"xsv_data\" data-image-description=\"\" data-medium-file=\"https://i1.wp.com/blog.parse.ly/wp-content/uploads/2015/05/xsv_data.png?fit=300%2C168&amp;ssl=1\" data-large-file=\"https://i1.wp.com/blog.parse.ly/wp-content/uploads/2015/05/xsv_data.png?fit=777%2C434&amp;ssl=1\" src=\"https://i1.wp.com/blog.parse.ly/wp-content/uploads/2015/05/xsv_data.png?resize=777%2C434\" alt=\"xsv_data\" width=\"777\" height=\"434\" class=\"alignnone size-full wp-image-1950\" srcset=\"https://i1.wp.com/blog.parse.ly/wp-content/uploads/2015/05/xsv_data.png?w=777&amp;ssl=1 777w, https://i1.wp.com/blog.parse.ly/wp-content/uploads/2015/05/xsv_data.png?resize=300%2C168&amp;ssl=1 300w\" data-recalc-dims=\"1\" /></a></div>\n<p>The downside is that the schema stored in each row is not “self-describing”, as it might be with CQL Maps. But, the storage savings are so tremendous that we can live with that. And, since we use a consistent order, we can “grow” our schema over time by simply appending new values on the right side of the serialization form.</p>\n<p>Here’s the other amazing thing. The client performance of these xsv values is much, much better than the CQL Collections equivalent, and even better than a schema we tried where we actually modeled every field directly in the CQL schema. Why? Because the client would spend most of its time decoding the “structure” of the row, rather than decoding the actual values, in both of those cases.</p>\n<p>I know what you’re thinking — why not use something like Avro or Protocol Buffers? We considered this, but felt that this would make Cassandra’s data storage a bit too inscrutable. You wouldn’t be able to meaningfully use the CQL shell — thus eliminating one of the main benefits of CQL. We were willing to throw out CQL 3.0 and CQL Collections, but not the entire idea of having a usable CQL shell!</p>\n<p>We also did some calculations and found that xsv performed similarly for our data set, anyway — since most of our values are strings, the binary serialization approach doesn’t actually help much.</p>\n<p>So, to store large gobs of  unstructured data in Cassandra, we recommend COMPACT STORAGE with serialized values in an “xsv” format. They are more storage-efficient and more CPU- and I/O-efficient. Go figure! It smokes all the “official” ways of modeling unstructured data in Cassandra.</p>\n<p>That means our team’s advice is to ignore all the advice against using COMPACT STORAGE in the docs, and ignore all the fancy new CQL 3 stuff. Pretty weird — but, unlike the marketed features, this scheme actually works!</p>\n<h2>Evil Cassandra Counters: They Still Hate Us! (Even in 2.1.x)</h2>\n<p>Oh, my. I was dreading this section. I got burned badly by Cassandra Counters.</p>\n<p>I shudder even now to think about the six-or-so weeks of development time I lost trying to make Counters work for our use case.</p>\n<p>If you watch a lot of Cassandra presentations online, you’ll hear different things about Counters from different people. Cassandra old-timers will say things like, “Counters are evil”, “Counters are a hack”, “Counters barely work”, “Counters are dangerous, “Never, ever use Counters…” — you get the idea.</p>\n<p>When I’m in a good mood, I sometimes ask questions about Counters in the Cassandra IRC channel, and if I’m lucky, long-time developers don’t laugh me out of the room. Sometimes, they just call me a “brave soul”.</p>\n<p>In Cassandra 2.x, things are more hopeful. Counters received several sprints of development and the feature was starting to be better understood. First, a bunch of fixes in 2.0.x that made Counters more reliable. Then, a whole new Counters implementation in 2.1.x that improved their performance, especially under contention.</p>\n<div style=\"margin: auto;\"><img data-attachment-id=\"1952\" data-permalink=\"https://blog.parse.ly/post/1928/cass/counter_incs/\" data-orig-file=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/counter_incs.png?fit=426%2C256&amp;ssl=1\" data-orig-size=\"426,256\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}\" data-image-title=\"counter_incs\" data-image-description=\"\" data-medium-file=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/counter_incs.png?fit=300%2C180&amp;ssl=1\" data-large-file=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/counter_incs.png?fit=426%2C256&amp;ssl=1\" src=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/counter_incs.png?resize=426%2C256\" alt=\"counter_incs\" width=\"426\" height=\"256\" class=\"alignnone size-full wp-image-1952\" srcset=\"https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/counter_incs.png?w=426&amp;ssl=1 426w, https://i0.wp.com/blog.parse.ly/wp-content/uploads/2015/05/counter_incs.png?resize=300%2C180&amp;ssl=1 300w\" data-recalc-dims=\"1\" /></div>\n<p>The reason Counters are so controversial and weird in the Cassandra community is because they seem to be at odds with Cassandra’s philosophy. Cassandra is meant to be a data store built on principles of immutability and idempotence. Incrementing a counter is a non-idempotent operation that seems to require an inherently mutable data store (like Redis or MongoDB).</p>\n<p>Cassandra works around this by implementing Counter increments as “read-then-write” operation, similar to another Cassandra trap feature, Light-Weight Transactions (LWT). The implementation is clever and it works, but it does not have the same performance as plain Cassandra row/column INSERT’s, for which it is optimized.</p>\n<p>Now, even if you can live with Cassandra’s different performance characteristics for Counters, you’ll discover other oddities. For example, column families that use counters have to live on their own, because the underlying storage is different. Counters can’t really be deleted — unless the delete is “definitive”, and even, then, there seem to be weird cluster bugs that surface with counter deletes. Related to counters not being deletable, you also learn that Cassandra’s time-to-live (TTL) features for data expiration simply do not work on Counters.</p>\n<p>Finally, you’ll find that by opting into Counters, you threw out the baby with the bathwater — yes, you got a convenient durable data structure for storing counts, but you lost all the benefits of having an idempotent data store. This matters in analytics use cases, although we didn’t realize quite how much it mattered until we were well into it.</p>\n<p>All of this is to say: Cassandra Counters — it’s a trap! Run!</p>\n<p>Even in 2.1.x, when many of Cassandra Counters problems were fixed, we still find it’s a trap. Since we didn’t need Counters, we also decided to roll back to the “more stable” Cassandra line, 2.0.x. It still supports CQL, but has been in production longer, and is maintained as a parallel stable branch to 2.1.x.</p>\n<h2>Check Your Row Size: Too Wide, Too Narrow, or Just Right?</h2>\n<p>Remember when I mentioned how in Cassandra’s underlying data model, the row key determines how the system distributes your data?</p>\n<p>It turns out, the most important data model challenge for Cassandra users is controlling your row size. In the same way a fashion magazine ebbs and flows on what the right waist size is for men and women, Cassandra ebbs and flows on the question of what the right row size is.</p>\n<p>The short answer, that will be frustrating, is that you want your rows to be neither too wide, nor too narrow — but, just right. This is frustrating because you have no rules of thumb to go by. Cassandra theoretically supports rows with 2 billion columns, and is quite proud of this fact. But, you ask anyone in the community, and they will tell you — storing 2 billion columns in one row is a very, very bad idea. So, how many is right? 10,000? 100,000? A million? A hundred million?</p>\n<p>We demanded answers, but we couldn’t get consistent ones. For our own data set, we settled on roughly 100,000 — and we also suggested that our average row should have many fewer columns than that — typically a few thousand. For our data set, this seems to strike the right balance between read performance and compaction/memory pressure on the cluster.</p>\n<p>But, determining the right row size for your data will be an iterative process, and will require testing. So, think hard about it during schema design and during your integration tests. In our case, we decided to partition data by event type and on every tracked URL. We further partitioned the data by hour, so that the data for a single URL on a single day was stored in 24 row keys. This seemed to work well for 99.99% of our rows, until something awful happened.</p>\n<h2>“The Dress” Breaks the Internet — and, Our Database</h2>\n<p>The silly Internet meme about “The Dress” went around many of our customer sites, who are large news and information publishers. The result was that many customer URLs were receiving upwards of 40 million unique visitors <strong>per hour</strong> to a single URL. This meant that our partitioning scheme for Cassandra would get a “very wide row” — nowhere near 2 billion columns, to be sure, but definitely in the tens and hundreds of millions.</p>\n<p>This put compaction pressure on our cluster and also led to some write contention.</p>\n<p>Unfortunately, we couldn’t come up with a more natural partitioning scheme that would handle this rare case, so, instead, we had to introduce a “synthetic partition key”. That is, we have another system that tracks very hot URLs in a lightweight way, and when they reach a certain threshold, we systematically “partition the partitions” using a split factor.</p>\n<p>So, 40 million events might now be spread among 400 row keys, ensuring that each only holds 100,000 columns of data, keeping our row size “just right”.</p>\n<div style=\"margin: auto;\"><a href=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/partitioning.png\"><img data-attachment-id=\"1946\" data-permalink=\"https://blog.parse.ly/post/1928/cass/partitioning/\" data-orig-file=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/partitioning.png?fit=699%2C386&amp;ssl=1\" data-orig-size=\"699,386\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}\" data-image-title=\"partitioning\" data-image-description=\"\" data-medium-file=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/partitioning.png?fit=300%2C166&amp;ssl=1\" data-large-file=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/partitioning.png?fit=699%2C386&amp;ssl=1\" src=\"https://i1.wp.com/blog.parse.ly/wp-content/uploads/2015/05/partitioning-300x166.png?resize=300%2C166\" alt=\"partitioning\" width=\"300\" height=\"166\" class=\"alignnone size-medium wp-image-1946\" srcset=\"https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/partitioning.png?resize=300%2C166&amp;ssl=1 300w, https://i2.wp.com/blog.parse.ly/wp-content/uploads/2015/05/partitioning.png?w=699&amp;ssl=1 699w\" data-recalc-dims=\"1\" /></a></div>\n<p>This introduced operational complexity, but was necessary to make Cassandra work for our use case.</p>\n<h2>For Future Travelers: Here Be Dragons!</h2>\n<p>A well-seasoned technologist friend of mine was not at all surprised when I walked him through some of these issues we had with Cassandra. He said, “You honestly expected that adopting a data store at your scale would not require you to learn all of its internals?” He has a point. After all, we didn’t adopt Elasticsearch until <a href=\"http://blog.parse.ly/post/1691/lucene/\">we really grokked Lucene</a>.</p>\n<p>But what about time series and analytics data? The funny thing about Parse.ly’s use of Cassandra is that our original adoption of it was driven by the desire to utilize its “time series analytics” capabilities. But it turns out, without any capability to group, filter, or aggregate (the core functions of any <a href=\"http://en.wikipedia.org/wiki/OLAP_cube#Operations\">OLAP system</a>), Cassandra simply could not play that role. We had hoped that Counters would give us “basic aggregation” (by holding cumulative sums), but, no dice!</p>\n<p>Instead, we ended up using it as a data staging area, where data sits before we index in our Lucene-based time series system. We discussed this a little bit over at the Elastic blog, in the article, <a href=\"https://www.elastic.co/blog/pythonic-analytics-with-elasticsearch\">“Pythonic Analytics with Elasticsearch”</a>.</p>\n<p>Now that we’ve come to understand its strengths and limitations, it works well in that role — because providing a time-ordered, durable, idempotent, distributed data store <strong>is</strong> something that Cassandra can handle.</p>\n<p>If you adopt Cassandra for a large data use case, I recommend you heed the above advice:</p>\n<ul><li>learn what CQL actually is;</li>\n<li>avoid CQL Collections;</li>\n<li>use COMPACT STORAGE;</li>\n<li>adopt custom serialization formats;</li>\n<li>don’t use counters;</li>\n<li>stay on 2.0.x “most-stable”;</li>\n<li>manage row size carefully;</li>\n<li>and, watch out for partitioning hotspots</li>\n</ul><p>With these guidelines in mind, you will likely end up with a better experience.</p>\n<p>“If it’s too good to be true, it probably is.” Indeed.</p>\n<p>But, overall, Cassandra is a powerful tool. It’s one of the few <a href=\"https://aphyr.com/posts/294-call-me-maybe-cassandra/\">truly “AP” (Highly Available and Partition-Tolerant) data stores</a> with a very powerful data distribution and cluster scale-out model. Its main fault is over-marketing its bugs as features, and trying too hard to make its quirky features appealing to the mass market, by dumbing them down.</p>\n<p>For experienced distributed systems practitioners, adopt Cassandra with the comfort of knowing the scale of its existing deployments, but with the caution that comes from knowing that in large-scale data management, there is no silver bullet.</p>\n<h2>Postscript: Living with Cassandra</h2>\n<p><em>I asked Didier Deshommes, a long-time Parse.ly backend engineer, if he had any tips for newcomers. His tips are included here as the postscript to this article.</em></p>\n<p>Though this article discussed many of the traps we hit with Cassandra, there are many resources online for how to model data “the Cassandra way”. These can serve as some positive instruction.</p>\n<p>I find that modeling data in Cassandra involves essentially one trick with several variations (wide rows).</p>\n<p>Although there are several Cassandra how-to and data modeling tutorials, I usually keep going back to only a handful of links when I want to refresh my memory on them. The funny thing about these links is that many of them come from around the time CQL was introduced, or even before.</p>\n<h3>The WHERE Clause</h3>\n<p>Writing data is so easy in Cassandra that you often forget how to read it efficiently. The best guide I know for knowing what you can get away with is <a href=\"http://mechanics.flite.com/blog/2013/11/05/breaking-down-the-cql-where-clause/\">Breaking Down the CQL Where Clause</a>.</p>\n<p>As a nice side effect, this will also inform how to structure your writes so that you can take advantage of some of these rules.</p>\n<h3>Time Series Models</h3>\n<p>Cassandra is a one-trick pony, so sometimes you need a little creativity for fitting it to your problem. When I’m feeling stuck and worried I might run out of wide row tricks, I go back to <a href=\"http://www.datastax.com/dev/blog/advanced-time-series-with-cassandra\">Advanced Time Series with Cassandra</a> to give me ideas.</p>\n<p>This builds on Cassandra modeling techniques developed in 2011, in <a href=\"http://rubyscale.com/blog/2011/03/06/basic-time-series-with-cassandra/\">Basic Time Series with Cassandra</a>. I don’t go back to this older article as often, but it does introduce the well-worn idea of time-based rollups.</p>\n<h3>Tyler Hobbes</h3>\n<p>Tyler Hobbes, the author of the advanced time series post, also recently put out <a href=\"http://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\">Basic Rules of Cassandra Data Modeling</a>, which is a great place to get started. It’s the article I point newer Cassandra users to right away.</p>\n<p>Tyler is the primary author of Cassandra’s <a href=\"https://github.com/datastax/python-driver\">CQL Python driver</a>, so there is also much to learn from him via his public slides, such as:</p>\n<ul><li><a href=\"http://www.slideshare.net/tylerhobbs/intro-to-cassandra\">Intro to Cassandra</a> — focuses on the “what makes Cassandra special” parts without marketing hype</li>\n<li><a href=\"http://www.slideshare.net/tylerhobbs/cassandra-for-python-developers\">Cassandra for Python developers</a> — these slides are interesting because they predate CQL</li>\n<li><a href=\"https://speakerdeck.com/tylerhobbs/principles-of-cassandra-data-modeling\">Principles of Cassandra data modeling</a> — visual aid for the above “rules of data modeling” blog post</li>\n</ul><p>Avoid the traps, embrace the tricks. Good luck!</p>"}}]}},"pageContext":{"alternative_id":5276}}