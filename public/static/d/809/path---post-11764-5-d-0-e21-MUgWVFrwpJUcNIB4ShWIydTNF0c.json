{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"riptano/ccm","alternative_id":11764,"content":"<p>A script/library to create, launch and remove an Apache Cassandra cluster on\nlocalhost.</p><p>The goal of ccm and ccmlib is to make it easy to create, manage and destroy a\nsmall Cassandra cluster on a local box. It is meant for testing a Cassandra cluster.</p><h2>Requirements</h2><ul><li>\n<p>A working python installation (tested to work with python 2.7).</p>\n</li>\n<li>\n<p>pyYAML (<a href=\"http://pyyaml.org/\" rel=\"nofollow\">http://pyyaml.org/</a> -- <code>sudo easy_install pyYaml</code>)</p>\n</li>\n<li>\n<p>six (<a href=\"https://pypi.org/project/six/\" rel=\"nofollow\">https://pypi.org/project/six/</a> -- <code>sudo easy_install six</code>)</p>\n</li>\n<li>\n<p>ant (<a href=\"http://ant.apache.org/\" rel=\"nofollow\">http://ant.apache.org/</a>, on Mac OS X, <code>brew install ant</code>)</p>\n</li>\n<li>\n<p>psutil (<a href=\"https://pypi.org/project/psutil/\" rel=\"nofollow\">https://pypi.org/project/psutil/</a>)</p>\n</li>\n<li>\n<p>Java (which version depends on the version of Cassandra you plan to use. If\nunsure, use Java 7 as it is known to work with current versions of Cassandra).</p>\n</li>\n<li>\n<p>If you want to create multiple node clusters, the simplest way is to use\nmultiple loopback aliases. On modern linux distributions you probably don't\nneed to do anything, but on Mac OS X, you will need to create the aliases with</p>\n<pre>sudo ifconfig lo0 alias 127.0.0.2 up\nsudo ifconfig lo0 alias 127.0.0.3 up\n...\n</pre>\n<p>Note that the usage section assumes that at least 127.0.0.1, 127.0.0.2 and\n127.0.0.3 are available.</p>\n</li>\n</ul><h3>Optional Requirements</h3><ul><li>Paramiko (<a href=\"http://www.paramiko.org/\" rel=\"nofollow\">http://www.paramiko.org/</a>): Paramiko adds the ability to execute CCM\nremotely; <code>pip install paramiko</code></li>\n</ul><p><strong>Note</strong>: The remote machine must be configured with an SSH server and a working\nCCM. When working with multiple nodes each exposed IP address must be\nin sequential order. For example, the last number in the 4th octet of\na IPv4 address must start with <code>1</code> (e.g. 192.168.33.11). See\n<a href=\"https://github.com/riptano/ccm/blob/master/misc/Vagrantfile\">Vagrantfile</a> for help with configuration of remote\nCCM machine.</p><h2>Known issues</h2><p>Windows only:</p><ul><li><code>node start</code> pops up a window, stealing focus.</li>\n<li>cqlsh started from ccm show incorrect prompts on command-prompt</li>\n<li>non nodetool-based command-line options fail (sstablesplit, scrub, etc)</li>\n<li>To install psutil, you must use the .msi from pypi. pip install psutil will not work</li>\n<li>You will need ant.bat in your PATH in order to build C* from source</li>\n<li>You must run with an Unrestricted Powershell Execution-Policy if using Cassandra 2.1.0+</li>\n<li>Ant installed via <a href=\"https://chocolatey.org/\" rel=\"nofollow\">chocolatey</a> will not be found by ccm, so you must create a symbolic\nlink in order to fix the issue (as administrator):\n<ul><li>cmd /c mklink C:\\ProgramData\\chocolatey\\bin\\ant.bat C:\\ProgramData\\chocolatey\\bin\\ant.exe</li>\n</ul></li>\n</ul><p>Remote Execution only:</p><ul><li>Using <code>--config-dir</code> and <code>--install-dir</code> with <code>create</code> may not work as\nexpected; since the configuration directory and the installation directory\ncontain lots of files they will not be copied over to the remote machine\nlike most other options for cluster and node operations</li>\n<li>cqlsh started from ccm using remote execution will not start\nproperly (e.g.<code>ccm --ssh-host 192.168.33.11 node1 cqlsh</code>); however\n<code>-x &lt;CMDS&gt;</code> or <code>--exec=CMDS</code> can still be used to execute a CQLSH command\non a remote node.</li>\n</ul><h2>Installation</h2><p>ccm uses python distutils so from the source directory run:</p><pre>sudo ./setup.py install\n</pre><p>ccm is available on the <a href=\"https://pypi.org/project/ccm/\" rel=\"nofollow\">Python Package Index</a>:</p><pre>pip install ccm\n</pre><p>There is also a <a href=\"https://github.com/Homebrew/homebrew/blob/master/Library/Formula/ccm.rb\">Homebrew package</a> available:</p><pre>brew install ccm\n</pre><h2>Usage</h2><p>Let's say you wanted to fire up a 3 node Cassandra cluster.</p><h3>Short version</h3><pre>ccm create test -v 2.0.5 -n 3 -s\n</pre><p>You will of course want to replace <code>2.0.5</code> by whichever version of Cassandra\nyou want to test.</p><h3>Longer version</h3><p>ccm works from a Cassandra source tree (not the jars). There are two ways to\ntell ccm how to find the sources:</p><ol><li>\n<p>If you have downloaded <em>and</em> compiled Cassandra sources, you can ask ccm\nto use those by initiating a new cluster with:</p>\n<p>ccm create test --install-dir=&lt;path/to/cassandra-sources&gt;</p>\n<p>or, from that source tree directory, simply</p>\n<pre> ccm create test\n</pre>\n</li>\n<li>\n<p>You can ask ccm to use a released version of Cassandra. For instance to\nuse Cassandra 2.0.5, run</p>\n<pre> ccm create test -v 2.0.5\n</pre>\n<p>ccm will download the binary (from <a href=\"http://archive.apache.org/dist/cassandra\" rel=\"nofollow\">http://archive.apache.org/dist/cassandra</a>),\nand set the new cluster to use it. This means\nthat this command can take a few minutes the first time you\ncreate a cluster for a given version. ccm saves the compiled\nsource in <code>~/.ccm/repository/</code>, so creating a cluster for that\nversion will be much faster the second time you run it\n(note however that if you create a lot of clusters with\ndifferent versions, this will take up disk space).</p>\n</li>\n</ol><p>Once the cluster is created, you can populate it with 3 nodes with:</p><pre>ccm populate -n 3\n</pre><p>For Mac OSX, create a new interface for every node besides the first, for example if you populated your cluster with 3 nodes, create interfaces for 127.0.0.2 and 127.0.0.3 like so:</p><pre>sudo ifconfig lo0 alias 127.0.0.2\nsudo ifconfig lo0 alias 127.0.0.3\n</pre><p>Note these aliases will disappear on reboot. For permanent network aliases on Mac OSX see <a target=\"_blank\" href=\"https://github.com/riptano/ccm/blob/master/NETWORK_ALIASES.md\"><img src=\"https://github.com/riptano/ccm/raw/master/NETWORK_ALIASES.md\" alt=\"Network Aliases\" /></a>.</p><p>After that execute:</p><pre>ccm start\n</pre><p>That will start 3 nodes on IP 127.0.0.[1, 2, 3] on port 9160 for thrift, port\n7000 for the internal cluster communication and ports 7100, 7200 and 7300 for JMX.\nYou can check that the cluster is correctly set up with</p><pre>ccm node1 ring\n</pre><p>You can then bootstrap a 4th node with</p><pre>ccm add node4 -i 127.0.0.4 -j 7400 -b\n</pre><p>(populate is just a shortcut for adding multiple nodes initially)</p><p>ccm provides a number of conveniences, like flushing all of the nodes of\nthe cluster:</p><pre>ccm flush\n</pre><p>or only one node:</p><pre>ccm node2 flush\n</pre><p>You can also easily look at the log file of a given node with:</p><pre>ccm node1 showlog\n</pre><p>Finally, you can get rid of the whole cluster (which will stop the node and\nremove all the data) with</p><pre>ccm remove\n</pre><p>The list of other provided commands is available through</p><pre>ccm\n</pre><p>Each command is then documented through the <code>-h</code> (or <code>--help</code>) flag. For\ninstance <code>ccm add -h</code> describes the options for <code>ccm add</code>.</p><h3>Remote Usage (SSH/Paramiko)</h3><p>All the usage examples above will work exactly the same for a remotely\nconfigured machine; however remote options are required in order to establish a\nconnection to the remote machine before executing the CCM commands:</p><table><thead><tr><th align=\"left\">Argument</th>\n<th align=\"left\">Value</th>\n<th align=\"left\">Description</th>\n</tr></thead><tbody><tr><td align=\"left\">--ssh-host</td>\n<td align=\"left\">string</td>\n<td align=\"left\">Hostname or IP address to use for SSH connection</td>\n</tr><tr><td align=\"left\">--ssh-port</td>\n<td align=\"left\">int</td>\n<td align=\"left\">Port to use for SSH connection<br />Default is 22</td>\n</tr><tr><td align=\"left\">--ssh-username</td>\n<td align=\"left\">string</td>\n<td align=\"left\">Username to use for username/password or public key authentication</td>\n</tr><tr><td align=\"left\">--ssh-password</td>\n<td align=\"left\">string</td>\n<td align=\"left\">Password to use for username/password or private key passphrase using public key authentication</td>\n</tr><tr><td align=\"left\">--ssh-private-key</td>\n<td align=\"left\">filename</td>\n<td align=\"left\">Private key to use for SSH connection</td>\n</tr></tbody></table><h4>Special Handling</h4><p>Some commands require files to be located on the remote server. Those commands\nare pre-processed, file transfers are initiated, and updates are made to the\nargument value for the remote execution of the CCM command:</p><table><thead><tr><th align=\"left\">Parameter</th>\n<th align=\"left\">Description</th>\n</tr></thead><tbody><tr><td align=\"left\"><code>--dse-credentials</code></td>\n<td align=\"left\">Copy local DSE credentials file to remote server</td>\n</tr><tr><td align=\"left\"><code>--node-ssl</code></td>\n<td align=\"left\">Recursively copy node SSL directory to remote server</td>\n</tr><tr><td align=\"left\"><code>--ssl</code></td>\n<td align=\"left\">Recursively copy SSL directory to remote server</td>\n</tr></tbody></table><h4>Short Version</h4><pre>ccm --ssh-host=192.168.33.11 --ssh-username=vagrant --ssh-password=vagrant create test -v 2.0.5 -n 3 -i 192.168.33.1 -s\n</pre><p><strong>Note</strong>: <code>-i</code> is used to add an IP prefix during the create process to ensure\nthat the nodes communicate using the proper IP address for their node</p><h3>Source Distribution</h3><p>If you'd like to use a source distribution instead of the default binary each time (for example, for Continuous Integration), you can prefix cassandra version with <code>source:</code>, for example:</p><pre>ccm create test -v source:2.0.5 -n 3 -s\n</pre><h3>Automatic Version Fallback</h3><p>If 'binary:' or 'source:' are not explicitly specified in your version string, then ccm will fallback to building the requested version from git if it cannot access the apache mirrors.</p><h3>Git and GitHub</h3><p>To use the latest version from the <a href=\"https://git-wip-us.apache.org/repos/asf?p=cassandra.git\" rel=\"nofollow\">canonical Apache Git repository</a>, use the version name <code>git:branch-name</code>, e.g.:</p><pre>ccm create trunk -v git:trunk -n 5\n</pre><p>and to download a branch from a GitHub fork of Cassandra, you can prefix the repository and branch with <code>github:</code>, e.g.:</p><pre>ccm create patched -v github:jbellis/trunk -n 1\n</pre><h3>Bash command-line completion</h3><p>ccm has many sub-commands for both cluster commands as well as node commands, and sometimes you don't quite remember the name of the sub-command you want to invoke. Also, command lines may be long due to long cluster or node names.</p><p>Leverage bash's <em>programmable completion</em> feature to make ccm use more pleasant. Copy <code>misc/ccm-completion.bash</code> to somewhere in your home directory (or /etc if you want to make it accessible to all users of your system) and source it in your <code>.bash_profile</code>:</p><pre>. ~/scripts/ccm-completion.bash\n</pre><p>Once set up, <code>ccm sw&lt;tab&gt;</code> expands to <code>ccm switch</code>, for example. The <code>switch</code> sub-command has extra completion logic to help complete the cluster name. So <code>ccm switch cl&lt;tab&gt;</code> would expand to <code>ccm switch cluster-58</code> if cluster-58 is the only cluster whose name starts with \"cl\". If there is ambiguity, hitting <code>&lt;tab&gt;</code> a second time shows the choices that match:</p><pre>$ ccm switch cl&lt;tab&gt;\n    ... becomes ...\n$ ccm switch cluster-\n    ... then hit tab twice ...\ncluster-56  cluster-85  cluster-96\n$ ccm switch cluster-8&lt;tab&gt;\n    ... becomes ...\n$ ccm switch cluster-85\n</pre><p>It dynamically determines available sub-commands based on the ccm being invoked. Thus, users running multiple ccm's (or a ccm that they are continuously updating with new commands) will automagically work.</p><p>The completion script relies on ccm having two hidden subcommands:</p><ul><li>show-cluster-cmds - emits the names of cluster sub-commands.</li>\n<li>show-node-cmds - emits the names of node sub-commands.</li>\n</ul><p>Thus, it will not work with sufficiently old versions of ccm.</p><h2>Remote debugging</h2><p>If you would like to connect to your Cassandra nodes with a remote debugger you have to pass the <code>-d</code> (or <code>--debug</code>) flag to the populate command:</p><pre>ccm populate -d -n 3\n</pre><p>That will populate 3 nodes on IP 127.0.0.[1, 2, 3] setting up the remote debugging on ports 2100, 2200 and 2300.\nThe main thread will not be suspended so you don't have to connect with a remote debugger to start a node.</p><p>Alternatively you can also specify a remote port with the <code>-r</code> (or <code>--remote-debug-port</code>) flag while adding a node</p><pre>ccm add node4 -r 5005 -i 127.0.0.4 -j 7400 -b\n</pre><h2>Where things are stored</h2><p>By default, ccm stores all the node data and configuration files under <code>~/.ccm/cluster_name/</code>.\nThis can be overridden using the <code>--config-dir</code> option with each command.</p><h2>DataStax Enterprise</h2><p>CCM 2.0 supports creating and interacting with DSE clusters. The --dse\noption must be used with the <code>ccm create</code> command. See the <code>ccm create -h</code>\nhelp for assistance.</p><h2>CCM Lib</h2><p>The ccm facilities are available programmatically through ccmlib. This could\nbe used to implement automated tests against Cassandra. A simple example of\nhow to use ccmlib follows:</p><pre>import ccmlib.cluster\nCLUSTER_PATH=\".\"\ncluster = ccmlib.cluster.Cluster(CLUSTER_PATH, 'test', cassandra_version='2.1.14')\ncluster.populate(3).start()\n[node1, node2, node3] = cluster.nodelist()\n# do some tests on the cluster/nodes. To connect to a node through thrift,\n# the host and port to a node is available through\n#   node.network_interfaces['thrift']\ncluster.flush()\nnode2.compact()\n# do some other tests\n# after the test, you can leave the cluster running, you can stop all nodes\n# using cluster.stop() but keep the data around (in CLUSTER_PATH/test), or\n# you can remove everything with cluster.remove()\n</pre><p>--\nSylvain Lebresne <a href=\"mailto:sylvain@datastax.com\">sylvain@datastax.com</a></p>"}}]}},"pageContext":{"alternative_id":11764}}