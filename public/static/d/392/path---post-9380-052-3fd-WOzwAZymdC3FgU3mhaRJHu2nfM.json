{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Amazon DynamoDB vs Apache Cassandra – Beyond the lines","alternative_id":9380,"content":"<div id=\"ssba-classic-2\" class=\"ssba ssbp-wrap left ssbp--theme-1\"><div><a data-site=\"\" class=\"ssba_twitter_share\" href=\"http://twitter.com/share?url=https://www.beyondthelines.net/databases/dynamodb-vs-cassandra/&amp;text=Amazon%20DynamoDB%20vs%20Apache%20Cassandra%20\" target=\"&quot;_blank&quot;\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/twitter.png\" title=\"Twitter\" class=\"ssba ssba-img\" alt=\"Tweet about this on Twitter\" /><div title=\"Twitter\" class=\"ssbp-text\">Twitter</div></a><a data-site=\"linkedin\" class=\"ssba_linkedin_share ssba_share_link\" href=\"http://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.beyondthelines.net/databases/dynamodb-vs-cassandra/\" target=\"&quot;_blank&quot;\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/linkedin.png\" title=\"LinkedIn\" class=\"ssba ssba-img\" alt=\"Share on LinkedIn\" /><div title=\"Linkedin\" class=\"ssbp-text\">Linkedin</div></a><a data-site=\"\" class=\"ssba_facebook_share\" href=\"http://www.facebook.com/sharer.php?u=https://www.beyondthelines.net/databases/dynamodb-vs-cassandra/\" target=\"_blank\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/facebook.png\" title=\"Facebook\" class=\"ssba ssba-img\" alt=\"Share on Facebook\" /><div title=\"Facebook\" class=\"ssbp-text\">Facebook</div></a><a data-site=\"\" class=\"ssba_google_share\" href=\"https://plus.google.com/share?url=https://www.beyondthelines.net/databases/dynamodb-vs-cassandra/\" target=\"&quot;_blank&quot;\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/google.png\" title=\"Google+\" class=\"ssba ssba-img\" alt=\"Share on Google+\" /><div title=\"Google+\" class=\"ssbp-text\">Google+</div></a><a data-site=\"reddit\" class=\"ssba_reddit_share\" href=\"http://reddit.com/submit?url=https://www.beyondthelines.net/databases/dynamodb-vs-cassandra/&amp;title=Amazon DynamoDB vs Apache Cassandra\" target=\"&quot;_blank&quot;\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/reddit.png\" title=\"Reddit\" class=\"ssba ssba-img\" alt=\"Share on Reddit\" /><div title=\"Reddit\" class=\"ssbp-text\">Reddit</div></a></div></div><p>Cassandra and DynamoDB both origin from the same paper: <a href=\"http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf\">Dynamo: Amazon’s Highly Available Key-value store</a>. (By the way – it has been a very influential paper and set the foundations for several NoSQL databases).</p>\n<p>Of course it means that DynamoDB and Cassandra have a lot in common! (They have the same DNA). However both AWS DynamoDB and Apache Cassandra have evolved quite a lot since this paper was written back in 2007 and there are now some key differences to be aware of when choosing between the two.</p>\n<p>This post aims at comparing these 2 distributed databases so that you can choose the one that best matches your requirements.</p>\n<h2>The concept</h2>\n<p>First of all let’s talk about the things they have in common and it starts with their implementation concept: Both of them map partition key onto a token ring using constant hashing to determine where to store the data.</p>\n<p>The idea is that the partition key is hashed into a 128 bits value. All the possible hash-values form a ring and each node in the cluster is responsible for one (or more) range of the ring.</p>\n<p><a href=\"http://beyondthelines.net/wp-content/uploads/2017/09/tokenring.png\"><img src=\"http://beyondthelines.net/wp-content/uploads/2017/09/tokenring.png\" alt=\"\" width=\"568\" height=\"508\" class=\"aligncenter size-full wp-image-1406\" srcset=\"https://www.beyondthelines.net/wp-content/uploads/2017/09/tokenring.png 568w, https://www.beyondthelines.net/wp-content/uploads/2017/09/tokenring-300x268.png 300w\" /></a></p>\n<p>By hashing the partition key every node is able to know the range it belongs to and from there the node in charge of this range. Of course we also need availability so the data needs to be replicated across multiple nodes. Where to place replicas (aka replication strategy) depends on the database implementation – (more on that later).</p>\n<p>It means that both DynamoDB and Cassandra are true peer-to-peer systems, with no master nodes (and no single point-of-failures). It also means that you can send your queries to any node in the cluster (or even better have your driver sent the request to the most appropriate node).</p>\n<h2>The data structure</h2>\n<h3>Primary key</h3>\n<p>Both databases belong to the column-family. Each item is identified by a primary key composed of 2 parts:</p>\n<ul><li>The partition key (mandatory): determines the partition where the item is stored</li>\n<li>The sort or cluster key (optional): determines how the item are sorting inside a partition</li>\n</ul><p>Cassandra supports any number of fields for both the partition key and the clustering key. On the other hand DynamoDB supports only 2 fields: one for the partition key and one for the sort key. It means that if you need several attributes to compose your key you need to manually concatenate them into a single field.</p>\n<h3>Schema</h3>\n<p>Cassandra supports structured data by means of a schema definition that you define in the table creation request in CQL (Cassandra Query Language).</p>\n<p>DynamoDB is schema-less (except for the primary key). Items in the same table can have completely different attributes (except for the partition and sort key).</p>\n<h3>Indexes</h3>\n<p>Both Cassandra and DynamoDB supports secondary indexes in order to query an item using an attribute that is not part of the primary key.</p>\n<p>However secondary index are usually slower and should be used wisely (preferred for attributes with low-cardinality).</p>\n<h3>Materialised views</h3>\n<p>Again both databases support materialised views (although DynamoDB calls them “Global secondary index”).</p>\n<h3>Time-To-Live</h3>\n<p>DynamoDB supports TTL at the item level. It means that when the TTL expires the whole item is deleted.</p>\n<p>Cassandra offers finer control as it supports TTL on columns which makes it possible to expire only certain fields of an item.</p>\n<h2>Consistency</h2>\n<p>One of the advantage of the dynamo family of NoSQL databases is that you can control the level of consistency that you need. E.g. if eventual consistency is enough for your application you can read one copy from any node in the cluster – it might not be the most up-to-date version of the data but it’s the fastest way to query the database.</p>\n<p>On the other hand you can require multiple nodes to answer your query making sure that you retrieve the latest version of the data.</p>\n<p>This is basically the 2 consistency levels that DynamoDB offers. You can control it with a “strong-consistency” flag in the query. If false eventual consistency is enough and you might not retrieve the latest version of the data. It true DynamoDB makes sure that you get the most up-to-date version of the data. Of course using strong consistency is slower and cost you more as well.</p>\n<p>Cassandra offers the same sort of consistency levels but with much finer control. You can choose between ANY (any node may answer), ONE (one node among the replicas of the given key), QUORUM (the majority of the replicas), LOCAL_QUORUM (the local majority of the replicas), ALL (all replicas).</p>\n<h3>Conflicts resolution</h3>\n<p>Although there is a preferred node in charge of a partition it may happen that we end up with a conflict for a given key (e.g. the preferred node wasn’t available). In this case DynamoDB and Cassandra take a different approach.</p>\n<p>The Cassandra strategy is simple: Every node add a timestamp when it writes the data. When there is a conflict the data with the most recent timestamp wins. This is the last-write-wins (LWW) strategy.</p>\n<p>Note that each field has its own timestamp so that it’s always possible to merge the changes if they concern different fields of the same object.</p>\n<p>The Dynamo paper relies on vector-clock to detect conflicts. Every node maintains a counter (or version number) of the changes it makes to an object. When it detects a conflict it tries to merge the results (which makes sense for Amazon because in the worst case you end-up with an extra item in your cart).</p>\n<p>Although it’s not clear from the AWS documentation it seems that DynamoDB in AWS now relies on a LLW strategy as well (or a combination of vector-clocks and timestamps).</p>\n<p>In the end there is not much difference between the 2 because both of them always return a single version of an object and the application never has to resolve conflicting objects.</p>\n<p>The only control that you have is the consistency level that you set in the request.</p>\n<h2>Language</h2>\n<p>Cassandra comes with its own language: The Cassandra Query Language (or CQL). It’s pretty close to SQL with some adaptations to support Cassandra features not present in SQL (collection and user-defined types, TTL, …).</p>\n<pre class=\"brush: sql; title: ; notranslate\" title=\"\">&#13;\nINSERT INTO cycling.cyclist_name (id, lastname, firstname)&#13;\nVALUES (6ab09bec-e68e-48d9-a5f8-97e6fb4c9b47, 'KRUIKSWIJK','Steven')&#13;\nUSING TTL 86400 AND TIMESTAMP 123456789;&#13;\n</pre>\n<p>DynamoDB relies on a specific JSON-based interface with variables replacement. The AWS CLI (Command Line Interface) makes it slightly easier but I still find using CQL much more natural.</p>\n<pre class=\"brush: jscript; title: ; notranslate\" title=\"\">&#13;\n{&#13;\n    \"ForumName\": {\"S\": \"Amazon DynamoDB\"},&#13;\n    \"Subject\": {\"S\": \"New discussion thread\"},&#13;\n    \"Message\": {\"S\": \"First post in this thread\"},&#13;\n    \"LastPostedBy\": {\"S\": \"fred@example.com\"},&#13;\n    \"LastPostDateTime\": {\"S\": \"201603190422\"}&#13;\n}&#13;\n</pre>\n<p>The <code>S</code> in the snippet above indicates that the attributes are of type String. It’s also possible to use variable substitution by using preceding the variable name with a <code>:</code></p>\n<pre class=\"brush: jscript; title: ; notranslate\" title=\"\">&#13;\n{&#13;\n  \"TableName\": \"Thread\",&#13;\n  \"Key\": {&#13;\n    \"ForumName\": {&#13;\n      \"S\": \"Amazon DynamoDB\"&#13;\n    },&#13;\n    \"Subject\": {&#13;\n      \"S\": \"A question about updates\"&#13;\n    }&#13;\n  },&#13;\n  \"UpdateExpression\": \"set Replies = Replies + :num\",&#13;\n  \"ExpressionAttributeValues\": { &#13;\n    \":num\": {\"N\": \"1\"}&#13;\n  },&#13;\n  \"ReturnValues\" : \"NONE\"&#13;\n}&#13;\n</pre>\n<h3>Multiple Updates</h3>\n<p>One note on updating all records stored under the same partition key. Cassandra fully support this operation by specifying only the partition key:</p>\n<pre class=\"brush: sql; title: ; notranslate\" title=\"\">&#13;\nUPDATE my_table SET some_field = \"some value\" WHERE my_partition_key = \"my_key\";&#13;\n</pre>\n<p>With DynamoDB you have to specify the entire primary key (i.e. both the hash and sort keys).</p>\n<h2>Protocol</h2>\n<p>Like all Amazon services DynamoDB offers a JSON/HTTP interface. The JSON syntax is specific to Dynamo as you need to indicate the type of the fields inside the JSON structure.</p>\n<p>To exchange data with DynamoDB you have to marshall to/from JSON which impacts performance (sometimes in a substantial way).</p>\n<p>The Cassandra client relies on a binary format to communicate with the database which makes the serialisation process more efficient (both in terms of CPU and network bandwidth). It is even more efficient than Thrift which was deprecated in favour of the CQL native protocol. Parts of its efficiency comes from the possibility to have several on-going requests at the same time.</p>\n<h3>Drivers</h3>\n<p>Both Cassandra and DynamoDB provide a set of drivers supporting most of the mainstream languages. In this section I discuss in more details the drivers available on the JVM as it is the platform I use the most.</p>\n<p>The java driver for Cassandra is pretty smart as it tries to optimise your query as best as it could (e.g. send the query to the node managing the hash of the partition key). It is also fully async and non-blocking as it can be used to send multiple requests simultaneously. The main caveat is the lack of type-safety as CQL queries are just written in plain text.</p>\n<p>There are a number of alternatives for the Scala language (<a href=\"https://github.com/outworkers/phantom\">Phantom</a>, <a href=\"https://github.com/getquill/quill\">Quill</a> and more recently <a href=\"https://github.com/schemasafe/troy\">Troy</a>).</p>\n<p>The java driver for DynamoDB is obviously not as good. The implementation is based on java future which only provides blocking calls to access the value. This really is a bummer to build reactive applications. There is a so-called async version of the client but all it does is delegate the blocking to a dedicated thread pool.</p>\n<p>The good news is that Amazon is working on a new version of the java driver that will be truly async but as the time of writing is still under developer-preview (not yet stable).</p>\n<p>There are a few Scala drivers developed by the community like <a href=\"https://github.com/guardian/scanamo\">Scanamo</a> which provides nice marshalers and a Free monad based implementation. However it relies on the AWS java client under the hood. (Using the Free monad makes it easy to plug in another client though).</p>\n<p>There is also an akka-stream connector available as part of the <a href=\"https://github.com/akka/alpakka\">Alpakka</a> project. To my knowledge this is the only non-blocking client available at the time of writing.</p>\n<h3>Data replication</h3>\n<p>In my opinion this is the key differentiating factor! Cassandra is fully tuneable and let’s you configure every aspect of the data replication. You can configure the number of replicas inside each datacenter and even enable replication across datacenter (making cross-region replication seamless – in case you’re hosting your Cassandra cluster on EC2).</p>\n<p>Note that the number of replicas doesn’t change automatically. You have to manually enable more replicas when your data or traffic outgrows the available resources.</p>\n<p>With DynamoDB it’s the opposite approach! You have (almost) no control over the number of replicas involved. Everything is performed automatically by AWS. You only provision the required throughput and DynamoDB makes sure you have enough partitions to handle the load.</p>\n<p>As your data grow AWS automatically add more partition. However it doesn’t change the provisioned throughput which means less throughput per partition. If your data is uniformly distributed that’s not an issue. If not you can quickly run into problem! This can become tricky when you store time-series into DynamoDB. (There is even a whole section dedicated to this topic in the DynamoDB documentation).</p>\n<p>Basically with DynamoDB you need to make sure your data is uniformly distributed! DynamoDB documentation does a pretty good job at explaining the rules on when partitions are created and how it impacts the provision throughput per partition.</p>\n<p>AWS has recently added support for Dynamo global tables: multi-region/multi-master data replication. It uses dynamo streams to replicate the data and resolves conflicts using a LastWriteWins strategy. There is also a new table backup/restore functionality allowing to backup a whole table at once without consuming any provisioned throughput. Restore can only be made into a new table and doesn’t consume any throughput. However it doesn’t play well with the multi-region support as backups can’t be exported into another region and restoring a local replica inside a global table doesn’t generate the corresponding events on the stream (which makes it impossible to sync the other region with this table). Basically global tables are a great step-forward but it is currently difficult to import existing data into a global table. More information here: <a href=\"https://aws.amazon.com/dynamodb/global-tables/\">https://aws.amazon.com/dynamodb/global-tables</a></p>\n<h3>Costs</h3>\n<p>DynamoDB offers a “plug-and-play” approach. You set your expected throughput and you’re ready to go. Amazon manages everything for you. The costs are based on the provisioned throughput (0.47$/WCU and 0.09$/RCU) and storage used (0.25$/Gb). Of course you’d better check <a href=\"https://aws.amazon.com/dynamodb/pricing/\">the official pricing documentation</a> for up-to-date information.</p>\n<p>On the other hand Cassandra is free open-source software so you don’t have to pay for it. However you have to run it somewhere and you have to pay for the machine you’re going to use (most likely EC2 instances or something equivalent on GoogleCloud or Microsoft Azure). Cassandra is designed to run on cheap commodity hardware but you will need several instances (3, 5 or 7, … instances for each datacenter). You should also consider the amount of time you need to setup the cluster … </p>\n<p>Note that Datastax (the company behind Apache Cassandra) now offers <a href=\"https://www.datastax.com/products/datastax-managed-cloud\">Datastax-Managed-Cloud</a> where they deploy and administrate a Cassandra cluster for you on AWS.</p>\n<p>AWS now offers a caching layer (most likely based on ElastiCache) on top of DynamoDB called <a href=\"http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DAX.concepts.html\">DAX</a>. DAX allows you to improve performances (reduced latency due to in-memory caching) and save your provisioned throughput because requests will hit the cache instead of your DynamoDB tables. DAX supports caching both for items and queries.</p>\n<h2>Conclusion</h2>\n<p>As though Cassandra and DynamoDB seem very close at first sight there is a number of key differences such as</p>\n<ul><li>The replication strategy</li>\n<li>The service ownership (Database managed by you or AWS)</li>\n<li>The pricing model</li>\n</ul><p>DynamoDB is easy to get started with however you might keep an eye on the cost involved. It is also not a good choice to store more and more rarely-accessed data in Dynamo as it increases your storage costs and impacts your provisioned throughput. You’d better move this data into a dedicated table with a different throughput or even outside of Dynamo.</p>\n<p>I tried to cover the main aspects worth to consider when making a decision. However it’s quite difficult to cover everything so don’t hesitate to leave a comment if you find something missing.</p>"}}]}},"pageContext":{"alternative_id":9380}}