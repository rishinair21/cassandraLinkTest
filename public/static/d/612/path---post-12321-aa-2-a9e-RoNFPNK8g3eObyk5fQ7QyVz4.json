{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Basic Time Series with Cassandra","alternative_id":12321,"content":"RubyScale — Basic Time Series with Cassandra<div class=\"app-nag\"><p>&#13;\n                &#13;\n                <a class=\"app-nag-large-button app-nag-app-store-link button blue\">Sounds perfect</a>&#13;\n                <a class=\"app-nag-large-button app-nag-app-store-deny\">Wahhhh, I don’t wanna</a>&#13;</p></div>&#13;\n&#13;\n        <section id=\"page\"><section id=\"posts\" class=\"content clearfix   avatar-hidden show-nav\"><div class=\"container\"><div class=\"main\"><article class=\"text not-page post-143067470585  active exposed\" data-post-id=\"143067470585\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><pre><em>editors note: as of 7 Mar 2012, this info is still current and correct.</em></pre><br />One of the most common use cases for Cassandra is tracking time-series data. Server log files, usage, sensor data, SIP packets, stuff that changes over time. For the most part this is a straight forward process but given that Cassandra has real-world limitations on how much data can or should be in a row, there are a few details to consider.<strong>Basic Inserts and Queries</strong>The most basic and intuitive way to go about storing time-series data is to use a column family that has TimeUUID columns (or Long if you know that no two entries willhappen at the same timestamp), use the name of the thing you are monitoring as the row_key (server1-load for example), column_name as the timestamp, and the column_value would be the actual value of the thing (0.75 for example):<ul><li>Inserting data – {:key =&gt; ‘server1-load’, :column_name =&gt; TimeUUID(now), :column_value =&gt; 0.75}</li></ul>Using this method, one uses a column_slice to get the data in question:<ul><li>Load at Time X –  {:key =&gt; 'server1-load’, :start =&gt; TimeUUID(X), :count =&gt; 1}</li><li>Load between X and Y – {:key =&gt; 'server1-load’, :start =&gt; TimeUUID(X), :end =&gt; TimeUUID(Y)}</li></ul>This works well enough for a while, but over time, this row will get very large. If you are storing sensor data that updates hundreds of times per second, that row will quickly become gigantic and unusable. The answer to that is to shard the data up in some way. To accomplish this, the application has to have a little more intelligence about how to store and query the information.\nFor this example, we’ll pick a day as our shard interval (details on picking the right shard interval later). The only change we make when we insert our data is to add a day to the row-key:<ul><li>Inserting data – {:key =&gt; 'server1-load-20110306’, :column_name =&gt; TimeUUID(now), :column_value =&gt; 0.75}</li></ul>Using this method, one still uses a column slice, but you have to then also specify a different row_key depending on what you are querying:<ul><li>Load at Time X – {:key =&gt; 'server1-load-&lt;X.strftime&gt;’, :start =&gt; TimeUUID(X), :count =&gt; 1}</li><li>Load between Time X and Y (if X and Y are on the same day) – {:key =&gt; 'server1-load-&lt;X.strftime&gt;’, :start =&gt; TimeUUID(X), :end =&gt; TimeUUID(Y)}</li></ul>Now what to do if X and Y are not on the same day? No worries! You can use a multi-get to fetch more than one key at a time (or issue parallel gets for maximum performance). If your X and Y span two days, you just need to generate keys for those two days and issue them in a multiget:<ul><li>Load between Time X and Y – {:key =&gt; ['server1-load-&lt;X.strftime&gt;’, 'server1-load-&lt;Y.strftime&gt;’], :start =&gt; TimeUUID(X), :end =&gt; TimeUUID(Y)}</li></ul>Then in your application, you will need to aggregate/concatenate/iterate those two rows however you see fit. If your data spans 3 or more days, you’ll need to also generate every key in between. Don’t be tempted to use the Order-Preserving Partitioner here, it won’t save you that much typing and it’ll will make managing your cluster much more difficult.<strong>Calculating Shard Size</strong>Now on the topic of determining your shard interval .. that’s a complicated topic that is often application dependent but the single biggest issue is to make sure your rows don’t get too big. The better you are at the ops side of Cassandra, the larger you can let your rows get but if I have to tell you that, you should keep them small. A quick ballpark formula for determining shard size is as follows (yes rcoli, it ignores overhead):<ul><li>shard_size_in_seconds / update_frequency * avg_data_size_in_bytes == row_size_in_bytes</li></ul>Set your shard size so that the row_size doesn’t get much larger than 10MB (this number can move around for many reasons but I’d consider it safe). For example, if you are storing hits on a website that gets 10 hits/sec and each entry is about 200B, then we have:<ul><li>Daily – 86400 / (1 / 10) * 200 = 172800000 (165MB)</li><li>Hourly – 3600 / (1 / 10) * 200 = 7200000 (6.9MB)</li></ul>Looks like sharding this up on hours hits our target row size. Of course you can use any shard size you want, 6 hours, 2 hours, seconds, months, whatever. If you code up your application properly, it should be easy to adjust. Even if you decide to change your shard partway through the life if your application, you just have to know that before a certain point, use keys with one format, and after a certain point, use another, it’s that simple.<strong>Indexing and Aggregation</strong>Indexing and aggregation of time-series data is a more complicated topic as they are highly application dependent. Various new and upcoming features of Cassandra also change the best practices for how things like aggregation are done so I won’t go into that. For more details, hit #cassandra on irc.freenode and ask around. There is usually somebody there to help.</div></div></section><section class=\"panel\"></section></div></article><section class=\"related-posts-wrapper\"><div class=\"related-posts\"><article class=\"text not-page post-143067473000  active exposed\" data-post-id=\"143067473000\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><p>Cassandra-cql has been updated for the latest version of cassandra. It supports all of the datatypes and has proper encoding support for ruby 1.9. It is also now published as a gem so a simple ‘gem install cassandra-cql’ should get you ready to roll with Ruby and Cassandra.</p><p>The official location for the code is now <a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fcode.google.com%2Fa%2Fapache-extras.org%2Fp%2Fcassandra-ruby%2F&amp;t=NjcyMGI3NDQ3OTI2NGM2OTlkM2U2MTIzNjA4MzA2NTUwNzI5ZDYyMyx6cDFhZkhoUQ%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067473000%2Fcassandra-cql-ruby-gem-for-cassandra-10&amp;m=1\" title=\"Google Code\" target=\"_blank\">Google Code</a> but I also use the <a href=\"https://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fkreynolds%2Fcassandra-cql&amp;t=YjdiMzVhZWE1NzZiNWU0YTkyYWE0YjFlYTljYWE5ZjVjZmY3YWY5Nix6cDFhZkhoUQ%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067473000%2Fcassandra-cql-ruby-gem-for-cassandra-10&amp;m=1\" title=\"Cassandra-CQL github repo\" target=\"_blank\">Cassandra-CQL github repo</a> if you want to participate that way. For a quick introduction on usage, check out the <a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fcode.google.com%2Fa%2Fapache-extras.org%2Fp%2Fcassandra-ruby%2Fwiki%2FGettingStarted&amp;t=NTFlYzgwNWEwNWY3YzkwMGExYjFiMjgyOGMzYjVjZmQ4MmRkOTliMCx6cDFhZkhoUQ%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067473000%2Fcassandra-cql-ruby-gem-for-cassandra-10&amp;m=1\" title=\"Google Code Wiki\" target=\"_blank\">Google Code Wiki</a>.</p><p>Enjoy!</p></div></div></section><section class=\"panel\"></section></div></article><article class=\"text not-page post-143067472090  active exposed\" data-post-id=\"143067472090\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><p>Our recently-released <a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fblog.insidesystems.net%2Fusing-cassandra-with-paperclip-on-rails&amp;t=NGM3YjQxYzdjYzkyZGM4NWIyMDExMTczMzFmYTc1ZTY5ZmY4MWJiYiwxd3h1dUV5Mg%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067472090%2Fpaperclip-cassandra-gets-consistent&amp;m=1\" target=\"_self\">Cassandra storage plugin for paperclip</a> was lacking one thing: the ability to specify read/write consistency levels. Well, now you can just by adding the following options to your has_attachment specification (these are the defaults, btw).</p><div class=\"CodeRay\"><div class=\"code\"><pre>:read_consistency =&gt; Cassandra::Consistency::ONE\n:write_consistency =&gt; Cassandra::Consistency::QUORUM</pre></div></div><p>Enjoy!</p></div></div></section><section class=\"panel\"></section></div></article><article class=\"text not-page post-143067472270  active exposed\" data-post-id=\"143067472270\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><p>If you come from the SQL world, sometimes it can be difficult to understand the <a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fwiki.apache.org%2Fcassandra%2FDataModel&amp;t=ZDgyZTBmNzNjMDQzZDJmNmFlOGY2YmJhMzkxOTBiNzJlNjQyMTJjMyxPUDZGYU03eA%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067472270%2Funderstanding-the-cassandra-data-model-from-a-sql&amp;m=1\" target=\"_blank\">Cassandra Data Model</a> and all that it implies in terms of management and scalability. For this post, we’re going to go backwards. Instead of writing an example application using Cassandra to understand it, I’ll describe implementing Cassandra on a traditional SQL database and what that would look like.</p><p><strong>1. Mapping a Column Family to SQL Tables</strong></p><p>In Cassandra, a Column Family has any number of rows, and each row has N column names and values. For this example, let’s assume that in Cassandra we have a Users Column Family with uuids as the row key and column name/value pairs as attributes such as username, password, email, etc. If we had 10000 such users, then in SQL we’d have 10000 tables that looked like the following where 91b56770-bf40-11df-969c-b2b36bca998e was the actual uuid of a user:</p><p><code>CREATE TABLE users-91b56770-bf40-11df-969c-b2b36bca998e (column_name varchar, column_value varchar) UNIQUE column_name PRIMARY KEY column_name;</code></p><p><code>INSERT INTO </code><code>users-91b56770-bf40-11df-969c-b2b36bca998e VALUES ('username', 'joe'), ('password', 'weak'), ('email', 'joe@example.com');</code></p><ul><li><strong>10000 tables!</strong> That’s right, 10000 tables. In SQL, that many tables would be absurd but Cassandra is designed to scale that way and lots of rows are encouraged as it helps load balancing and scalability. In fact, millions and billions of rows are the norm. You can think of Cassandra as a system that distributes these tables over many nodes with some consistency and replication guarantees.</li><li><strong>You said N rows, but then said a table is on a single node. You don’t really mean N do you?</strong> No, not really. A row has to fit on a single node just like a table has to fit on a single machine for most SQL implementations. For older versions of Cassandra, a row also had to fit in RAM.</li><li><strong>It looks like I can only query one user at a time and I already have to know his UUID. Is that true?</strong> In SQL terms, Cassandra can perform table ranges and row slices on table ranges. In Cassandra terms, you can get a slice of keys and a slice of columns within those keys. This is what is meant by ‘column-oriented key-value store’. One thing you don’t get to do is join. Cassandra does not join. <em>Cassandra does not join.</em> If you want to join, you do it in your application.</li><li><strong>What is a Column Family for then? Just a table prefix?</strong> A Column Family has a number of settings that go with it that alter it’s behavior. There are cache settings for the keys (the UUIDs in this example), cache settings for the entire rows (the entire table in this example), and most importantly, sorting. In Cassandra there is no OFFSET, only LIMIT and the equivalent of BETWEEN. In this example, the column names are just strings but they could also be integers or timestamps and they are always stored in sort order. One Column Family might have timestamp-sorted data where you query things by time slice and another might be address book data where you query things in alphabetical order. The only sorting you get to do after the fact is reversing a particular slice. </li><li><strong>What if I want to sort by column value and by column name?</strong> Then you have two Column Families, one sorted by whatever datatype your column names are, and one sorted by whatever your column values are.</li><li><strong>So if I wanted to find the user who had a particular email address, how would I do that? I don’t know what table to query!</strong> Exactly! If you want to answer that question, you’ll have to make another Column Family that keys on e-mail address and points to the UUID of the user that has it, then you can query the relevant users table. Think about it this way .. in SQL, you can CREATE INDEX for things you want to query and in Cassandra, you have to manually maintain that index. (Secondary indexes are present in 0.7+, but I’ll cover that another time.)</li><li><strong>In SQL, I can still do a full table scan to pull out the information I’m looking for. Why can’t Cassandra do that?</strong> You can iterate with Cassandra and functionally get the same result, but I wouldn’t if I were you.</li><li><strong>But if I have two Column Families with the same data sorted differently, that’s denormalized. I heard that was bad.</strong> Denormalization is the norm with Cassandra. This is a complicated topic but in short, denormalization is a requirement for linear horizontal scaling and many people were already doing this in their SQL databases to avoid joins anyway.</li><li><strong>Wait, there is no OFFSET? How do I paginate with cassandra? </strong>Awkwardly. You have to start at the beginning, get N items, then on the next page you’d have to start at the last of the previous items and get N+1, throwing away the first one, etc. Alternately, you can create another Column Family which caches pages but in general, pagination is not what Cassandra was designed for.</li></ul><p><strong>2. Mapping a Super Column Family to SQL tables</strong></p><p>A Super Column Family is exactly like a Column Family, except you get one more column in your table. For this example, we’ll make an address book.</p><p><code>CREATE TABLE addressbooks-91b56770-bf40-11df-969c-b2b36bca998e (super_column_name, column_name varchar, column_value varchar) UNIQUE (super_column_name, column_name) PRIMARY KEY super_column_name;</code></p><p><code>INSERT INTO </code><code>addressbooks-91b56770-bf40-11df-969c-b2b36bca998e VALUES ('bob', 'street', '1313 Mockingbird Lane'), ('bob', 'city', 'Chicago'), ('bob', 'state', 'IL');</code></p><p><code>INSERT INTO </code><code>addressbooks-91b56770-bf40-11df-969c-b2b36bca998e VALUES ('alice', 'street', '123 Foo St.'), ('alice', 'city', 'Kona'), ('alice', 'state', 'HI');</code></p><ul><li><strong>Do the column_names have to be the same for each Super Column?</strong> No.</li><li><strong>Can the super_column_name and column_name be sorted differently?</strong> Yes.</li><li><strong>Does the entire table still  have to fit on one node or does it split out the Super Columns?</strong> The entire row still has to fit on one node.</li><li><strong>Is there a limit to how many Columns can be in a Super Column?</strong> Other than the space limitation already mentioned, theoretically, no. There is one gigantic caveat: <em>Accessing a single Column in a Column Family is efficient and fast. Accessing a single Column in a Super Column ('city’ or 'state’ in this case) requires deserialization of the entire Super Column.</em> For this example, this means that to get alice -&gt; state, Cassandra has to load everything in the alice super column. For an addressbook, this doesn’t really matter but if you had 1000 columns and a read-heavy load, it could heavily impact performance since you’d have to deserialize all 1000 columns just to get one of them.</li><li><strong>It sounds like Super Column Families can be dangerous if I’m not careful.</strong> Exactly! They were designed specifically for inverted indexing. If you aren’t doing that or don’t know what that is, don’t use them.</li></ul><p><strong>3. Transactions and/or Rollbacks</strong></p><p>Cassandra does neither transactions nor rollbacks. I you want those, some other thing such as <a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fcode.google.com%2Fp%2Fcages%2F&amp;t=NmNhNjg1ZTYyNGQxOWZhNjhmY2VlNWFjYzQxMzJjNWFmYTliNWFiYSxPUDZGYU03eA%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067472270%2Funderstanding-the-cassandra-data-model-from-a-sql&amp;m=1\" target=\"_blank\">Cages/ZooKeeper</a> has to do that.</p><p><strong>Next Post</strong></p><p>To learn more about how these tables would be replicated and queried, continue on to the next post, <a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fblog.insidesystems.net%2Fcassandra-data-model-from-an-sql-perspective&amp;t=MDIzNDU5YjQ1MGQxZTYxZTBiNjA5ODM3MjQwOThjYjdiYjZmY2Y5NCxPUDZGYU03eA%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067472270%2Funderstanding-the-cassandra-data-model-from-a-sql&amp;m=1\" target=\"_self\">Replication Factor and Consistency Levels</a>.</p></div></div></section><section class=\"panel\"></section></div></article><article class=\"text not-page post-143067472805  active exposed\" data-post-id=\"143067472805\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><h3>Cassandra Query Language (CQL)</h3><a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fcassandra.apache.org&amp;t=OWIxNjZhMjUzYTc5OWMzNmJlOTE0ZTc3ZDVhN2E5NjM2NmExNmQ5MixtUFpnbXlCTA%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067472805%2Fcassandra-cql-a-ruby-cql-client-for-cassandra&amp;m=1\" target=\"_blank\"><img class=\"alignright\" title=\"Apache Cassandra Project\" src=\"http://cassandra.apache.org/media/img/cassandra_logo.png\" alt=\"\" width=\"350\" height=\"70\" /></a>Cassandra originally went with a Thrift RPC-based API as a way to provide a common denominator that more idiomatic clients could build upon independently. However, this worked poorly in practice: raw Thrift is too low-level to use productively, and keeping pace with new API methods to support (for example) indexes in 0.7 or distributed counters in 0.8 is too much for many maintainers.\nCQL, the Cassandra Query Language, addresses this by pushing all implementation details to the server; all the client has to know for any operation is how to interpret “resultset” objects. So adding a feature like counters just requires teaching the CQL parser to understand “column + N” notation; no client-side changes are necessary.\n(CQL Specification: <a title=\"CQL Reference\" href=\"https://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fapache%2Fcassandra%2Fblob%2Ftrunk%2Fdoc%2Fcql%2FCQL.textile&amp;t=ZmI4YTRhNWZmZTVkZGJmNDZmZWM5MDM0Y2Q4Y2Q3MTk4ZDg5NWE0ZixtUFpnbXlCTA%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067472805%2Fcassandra-cql-a-ruby-cql-client-for-cassandra&amp;m=1\" target=\"_blank\">github.com/apache/cassandra/blob/trunk/doc/cql/CQL.textile</a>)<h3>Cassandra-CQL For Ruby</h3>Cassandra-CQL implements a DBI-like interface on top of CQL in Ruby that should be familiar to anybody who has worked with a traditional RDBMS before. It is not yet released as a gem as it will shortly be included in Apache Extras and distributed from there. To get started developing with it now, just clone it from Github and build/install the gem locally with ‘rake install’.\n(Github:<a title=\"Cassandra-CQL\" href=\"https://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fkreynolds%2Fcassandra-cql&amp;t=OTk0ZjI0NDU4NTlmZmIyODc0MTlkOTM5ZmU4NzlhNTMzZGJjN2RhMixtUFpnbXlCTA%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067472805%2Fcassandra-cql-a-ruby-cql-client-for-cassandra&amp;m=1\" target=\"_blank\">http://github.com/kreynolds/cassandra-cql\n</a></div></div></section><section class=\"panel\"></section></div></article><article class=\"text not-page post-143067474645  active exposed\" data-post-id=\"143067474645\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><p>It’s been a while since the last release of the <a title=\"Cassandra-CQL\" href=\"https://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fkreynolds%2Fcassandra-cql&amp;t=YWM2YTJkYzBhN2JjNWRkZThkMDRiNDMwN2ViMDk4MWRmYjg2NTU1MCxLWkV3MVdoNg%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067474645%2Fcassandra-cql-110&amp;m=1\" target=\"_blank\">cassandra-cql gem</a>, and this version fixes a few long-standing encoding and data-access bugs as well as support for <a title=\"Datastax CQL Reference\" href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fwww.datastax.com%2Fdocs%2F1.1%2Freferences%2Fcql%2Findex&amp;t=NDc5NTczOGFhMGQ3YjBmNDAwYjNhOGYxYjJjNjE1NGNmYjIxYjUxZSxLWkV3MVdoNg%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067474645%2Fcassandra-cql-110&amp;m=1\" target=\"_blank\">CQL3</a>. The driver now also uses <a title=\"Cassandra-CQL in Travis\" href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Ftravis-ci.org%2F%23%21%2Fkreynolds%2Fcassandra-cql&amp;t=OTgzY2M0MzVlYzRlMGMxYjE4MjgwZTdhYTM5MTdkMTAxNDBjMWRmYyxLWkV3MVdoNg%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067474645%2Fcassandra-cql-110&amp;m=1\" target=\"_blank\">Travis</a> for continuous integration.</p><p>The largest improvement is the ability to cast single columns at a time. One of the major pain points previously was that if a column in Cassandra had existing data and it’s validation changed to make that data invalid (empty string in an Integer-validated column for instance), none of the data in that row would be accessible as the entire row was casted at once. Each column is now individually casted and cached and if there is invalid data in a validated column, it will raise a CastException that contains a useful description of the problem as well as the bytes that raised the exception.</p><p>Another important bug fix is for character encoding in Ruby 1.9. The previous version incorrectly used ASCII-8BIT on data retrieved from ASCII-validated columns which when stored back into Cassandra, would encode it as binary. A simple change to US-ASCII in the casting has fixed that.</p><p><code>gem install cassandra-cql</code></p><p>Enjoy!</p></div></div></section><section class=\"panel\"></section></div></article><article class=\"text not-page post-143067472490  active exposed\" data-post-id=\"143067472490\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><p>If you read the last post, <a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fblog.insidesystems.net%2Funderstanding-the-cassandra-data-model-from-a&amp;t=YzIwN2MxNjEzZTQ1YzE4YzU5NGUxNjcxMDk3Yjk0NjBkZTlmZDY4YyxKVWVkQW91VQ%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067472490%2Fcassandra-data-model-from-an-sql-perspective&amp;m=1\" target=\"_blank\">Understanding the Cassandra Data Model from a SQL Perspective</a>, then you already have a decent handle on what a column-oriented key/value store is. The next thing that tends to confuse new users of Cassandra is the notion of <strong>Consistency Level</strong> and <strong>Replication Factor</strong>. This post doesn’t really have a lot to do with SQL in particular, it’s more of a discussion about how tables would be replicated across multiple servers and how you read/write from those tables.</p><p><strong>1. Replication Factor</strong></p><p>In the previous post, we described how every single Cassandra Row would be a separate table in SQL with an arbitrary number of rows. The <strong>Replication Factor</strong> (aka ‘RF’) determines <em>how many nodes have a copy of that table</em>. If you have 10 nodes and your RF=3, then every single table will exist on 3 nodes. Table users-91b56770-bf40-11df-969c-b2b36bca998e might exist on nodes 2 through 4 and users-28b56770-b410-15ef-968c-b2c36d511e78 might exist on nodes 6 through 8.</p><ul><li><strong>Can the RF be any number?</strong> Anything one or higher works but make sure it’s not higher than the actual number of nodes you have. This may be fixed by now but it used to be handled ungracefully. In general it should also be an odd number &gt;=3 so that quorum is a useful consistency level (for more details on this, keep reading).</li><li><strong>How do I know which node to query to get my data if it could be anywhere? Do I have to know where to write it?</strong> Each node acts as a storage proxy for every other node. If you query node 5 for data that is on nodes 8-10, it knows to ask one or more of those nodes for the answer. This is also true of writes.</li><li><strong>What if a node goes down? How do I synchronize them? What if they have different values?</strong> This will be covered in the next section, <strong>Consistency Levels</strong>.</li></ul><p><strong>2. Consistency Level</strong></p><p>Consistency in Cassandra is Eventual, which is to say that the N nodes responsible for a particular table could have a slightly different opinion of what it’s contents are. That’s ok! When reading from or writing to a Cassandra cluster, you can tune the tolerance for that sort of tomfoolery by reading or writing at a varying <strong>Consistency Level</strong> (aka 'CL’). Remember that each node acts as a proxy for every other node so you don’t have to worry about which node you are interacting with (unless you are really trying to optimize network activity but in general, this is unnecessary).</p><p>CL::ALL will not return success unless it has successfully written the same value to every node responsible for holding whatever you are writing. Using CL::ALL, you can guarantee that whatever you are writing is the same on all nodes when success is returned. There is of course a performance penalty for this, but in return you get very strong Consistency. Reading at CL::ALL functions in a similar way .. if one of the nodes does not respond, it will return an error since it cannot guarantee that all of the nodes are consistent for the value in question.</p><p>CL::QUORUM only requires a majority of the nodes responsible for a table to respond instead of all of them. This allows for one or more nodes to be down or otherwise unavailable and still have your read/write return. If your RF=3, then only 2 nodes responsible for a table need to be online in order to reliably manipulate the data in that table. Note that if RF=1 or RF=2 then there is no meaningful difference between CL::ALL and CL::QUORUM so if you want the benefits of CL::QUORUM, make sure your RF&gt;=3.</p><p>CL::ONE requires that only one of the nodes responsible for a table respond. This makes reads and writes fast, but it also means that depending on what else is reading and writing, it’s possible that they could briefly give conflicting answers. This is a fine tradeoff for speed in many applications, but not all. For example, recording votes or website hits where the outside possibility of a few going missing on machine failure is probably fine. Recording a financial transaction of some sort, probably not so much.</p><p>CL::ANY is only used for writing, not reading. CL::ANY means that as soon as a write is received by <em>any</em> node, the call returns success. This occurs when your client might be connecting to node 5 but the nodes responsible for it are 6-8. The difference between CL::ONE and CL::ANY is that with CL::ANY, as soon as node 5 receives the write, it returns success (but nodes 6-8 could be down or whatever). CL::ONE means that if you write to node 5, either 6, 7, or 8 have to return success before node 5 returns success.</p><ul><li><strong>OK .. so if I use CL::ALL and it fails, does that mean that my write failed?</strong> Not necessarily! It may have succeeded on two nodes and failed on the third which means that <em>eventually</em> it will be propagated to the third, but the <em>required guarantee</em> was not met.</li><li><strong>Uh .. ok. So if that happens, how do I know that any of my writes succeeded?</strong> You don’t! At least not yet. The error doesn’t indicate percentage of success, just failure. Not great, I know.</li><li><strong>I have multiple datacenters. How do I tell Cassandra to put some data in each?</strong> There are various strategies and snitches that tell Cassandra where to put things and they are constantly in flux. You can also write your own if you have specific requirements. For more information, see the <a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fwiki.apache.org%2Fcassandra%2F&amp;t=N2QyNjI0YzA3Nzk3ZmExMDZkZTM1MTU0MGNmZjVkYjZmYzgwNjNhNSxKVWVkQW91VQ%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067472490%2Fcassandra-data-model-from-an-sql-perspective&amp;m=1\" target=\"_blank\">Cassandra Wiki</a>.</li><li><strong>What happens if I write at CL::ANY and that node explodes before it can send data to where it belongs?</strong> Congratulations, you just lost data. If you can’t tolerate that, don’t use CL::ANY.</li><li><strong>What happens if all 3 nodes are up, but have different values for something for some reason and I read at CL::ALL. Does it give me the finger or what?</strong> Cassandra performs 'read repair’. That is, upon reading, if you are using a CL that requires more than one node and they disagree on the value, Cassandra will compare the values and use whichever one has the latest timestamp. It will also write that value back to the node which had an outdated value hence 'repairing it’.</li><li><strong>What if a node goes offline for a whole day, then comes back and has all sorts of wonky outdated data. Is there a way to fix it all at once instead of on read? That sounds expensive and slow to do all ad-hoc.</strong> Indeed it is! You can initiate a complete 'repair’ of a node after a failure like that using nodetool.</li></ul></div></div></section><section class=\"panel\"></section></div></article><article class=\"text not-page post-143067471930  active exposed\" data-post-id=\"143067471930\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><p>These have already been sent to the port maintainers so they should find their way into the ports collection soon enough but if you can’t wait, here are some scripts for pfstat (pfstatd in particular) and cassandra.</p><p>/usr/local/etc/rc.d/pfstatd</p><div class=\"CodeRay\"><div class=\"code\"><pre>#!/bin/sh\n# PROVIDE: pfstatd\n# REQUIRE: LOGIN\n# BEFORE:  securelevel\n# KEYWORD: shutdown\n# Add the following lines to /etc/rc.conf to enable `pfstatd':\n#\n# pfstatd_enable=\"YES\"\n# pfstatd_flags=\"\"\n#\n# See pfstat(1) for pfstatd_flags\n#\n. /etc/rc.subr\nname=\"pfstatd\"\nrcvar=`set_rcvar`\ncommand=\"/usr/local/bin/pfstatd\"\n# read configuration and set defaults\nload_rc_config \"$name\"\n: ${pfstatd_enable=\"NO\"}\nrun_rc_command \"$1\"</pre></div></div><p>/usr/local/etc/rc.d/cassandra</p><div class=\"CodeRay\"><div class=\"code\"><pre>#!/bin/sh\n# PROVIDE: cassandra\n# REQUIRE: LOGIN\n# BEFORE:  securelevel\n# KEYWORD: shutdown\n# Add the following lines to /etc/rc.conf to enable `cassandra':\n#\n# cassandra_enable=\"YES\"\n# cassandra_flags=\"\"\n#\n# See cassandra(1) for cassandra_flags\n#\n. /etc/rc.subr\nname=\"cassandra\"\nprocname=\"java\"\nrcvar=`set_rcvar`\ncommand=\"/usr/local/share/cassandra/bin/cassandra\"\npidfile=\"/var/run/$name.pid\"\ncommand_args=\"-p ${pidfile}\"\n# read configuration and set defaults\nload_rc_config \"$name\"\n: ${cassandra_enable=\"NO\"}\nrun_rc_command \"$1\"</pre></div></div></div></div></section><section class=\"panel\"></section></div></article><article class=\"text not-page post-143067472625  active exposed\" data-post-id=\"143067472625\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><p>I’m sure you were expecting another post with a brief topical analysis of why Facebook chose HBase instead of Cassandra with some similarly topical and mostly incorrect summary of how those two systems work and why one is better than the other one.</p><p>Sorry to disappoint, but rather than pour more fuel on what is already a pointless fire, I’m going to suggest instead that you look at what your <strong>application</strong> and your <strong>business</strong> requires for success and can operationally support. That might mean that you need transactional rollback so Cassandra won’t work straight up, or that you already have HDFS for other jobs so HBase is easier to support than adding on an entirely new technology.</p><p>Regardless, please take the time to <strong>understand the systems</strong> and realize that the choices one company makes aren’t necessarily the same choices you should make for many reasons, technical and otherwise.</p></div></div></section><section class=\"panel\"></section></div></article><article class=\"text not-page post-143067473965  active exposed\" data-post-id=\"143067473965\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><p>I recently had a conversation in #cassandra about the Data Model that I thought might be useful to try to distill into a few lines. These few lines ignore all of the implementation details to make it work in practice but it gives you the starting point. It looks a little something like this …\n</p><ol><li><strong><em>Keyspace</em></strong> - What method should I use to turn my application key into a <em>Row Key</em>?</li><li><strong><em>Row Key</em></strong> - Which <em>Node</em> is my value on?</li><li><strong><em>Column Family</em></strong> - Which file on the <em>node</em> is my value in?</li><li><strong><em>Column Name</em></strong> - Which piece of the file on the <em>node</em> contains my value?</li><li><strong><em>Column Value</em></strong> - My value!</li></ol><p>Since the columns are already sorted in the file, getting a slice of them is very efficient, and this is what makes Cassandra a column-oriented database. It’s worth noting that with most Cassandra clients, the <em>Row Key</em> and the <em>Column Family</em> are almost always conceptually swapped because it’s more common to access multiple keys in the same column family than to access multiple column families with the same key. Given the above, let’s revisit some of the other concepts that are required to make it work in practice.</p><p><strong>Partitioner</strong></p><p>The partitioner determines how your application keys get turned into <em>Row Keys</em>. <em>RandomPartitioner</em> (which should be called HashedPartitioner in my opinion) takes an MD5 of the key and uses that as the <em>Row Key </em>and <em>ByteOrderedPartitioner</em> uses the key unmodified.</p><p><strong>Replication Factor and Replica Placement Strategy</strong></p><p><em>ReplicationFactor</em> determines how many nodes get a copy of a particular key. There is no master/slave thing going on here, it’s just how many nodes get a copy of a key. The <em>Strategy</em> determines which exact nodes get a copy of your key based on network topology or ring placement.</p><p><strong>Consistency Levels</strong></p><p>Most relevant when the <em>ReplicationFactor</em> &gt; 1, the <em>ConsistencyLevel</em> determines how many nodes have to successfully record a write or agree on the value of a read for the operation to be considered successful. There are tables of consistency levels and what exactly they mean in multiple places so I won’t repeat them here.</p><p><strong>Memtables, Commitlog, SSTables, and Compaction</strong></p><p>As writes come in to a <em>ColumnFamily</em>, they are simultaneously (don’t argue) stored in memory in a <em>memtable</em> and written out to disk in a <em>commitlog</em>. The <em>memtable</em> is periodically written out to disk in in column-order as an <em>sstable</em> for efficient slicing later. Over time, a column could exist in a <em>memtable</em> and/or multiple <em>sstables</em> at once so a timestamp is used to determine which one to use, highest one wins. The timestamp is supplied by the client and can be any integer. Over time, you get a number of <em>sstables</em> and a process called <em>compaction</em> combines them all and throws away the out of date stuff to save space. Back to the <em>commitlog</em>, that’s there so that if the node explodes while some things are only in a <em>memtable</em>, they get replayed when the node starts back up so no data is lost (durability). Since the <em>commitlog</em> is serial write-only, if you put it on a separate disk, you can accept writes really fast.</p><p><strong>Miscellaneous</strong></p><div><ul><li>You can ask any node anything, they all act as proxies for one another.</li><li>If your <em>ReplicationFactor</em> &gt; 1, then <em>ReadRepair</em> will propagate the most recent column value to the nodes responsible or it.</li><li>There are various operations in <em>nodetool</em> that let you move nodes, add nodes, clean out old data/keys, manually compact things, repair everything at once, get statistics about each node, etc.</li><li><em>Gossip</em> is used to propagate node status and information to other nodes.</li></ul><p>Cassandra works in a complicated problem space and there are many subtle operational and technical details that aren’t covered her, but this is the gist of it.</p></div></div></div></section><section class=\"panel\"></section></div></article><article class=\"text not-page post-143067475055  active exposed\" data-post-id=\"143067475055\"><div class=\"post-wrapper clearfix\"><section class=\"post\"><div class=\"post-content\"><div class=\"body-text\"><a href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Frubyscale.com%2F%3Fattachment_id%3D446&amp;t=Mjg2ODQwNzc2MDE2ZjVmY2RlNzE0YjNmZjk0MjZlM2RmM2JjOGE3NywwMzlLTURCTg%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067475055%2Fusing-ruby-with-mios-from-mi-casa-verde&amp;m=1\" rel=\"attachment wp-att-446\"><img class=\"alignright size-medium wp-image-446\" alt=\"Vera Lite\" src=\"http://rubyscale.com/wp-content/uploads/2013/01/Vera-Lite1-300x236.png\" width=\"300\" height=\"236\" /></a>Mi Casa Verde. You can read the specifications of the devices for yourself but I like them because they are inexpensive, have low-power requirements, are capable of interfacing with a number of different kind of home automation systems, and most importantly, have a documented JSON/XML API. Coincidentally, they also have a<a title=\"Developer Special Program\" href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fwww.micasaverde.com%2Fdevelop-an-app.php&amp;t=YTE3NDg5NzRlZmNlYWUzMDNiN2Y3ZmMyNTdhZGQ0ZTQ5MWZiZGFlNiwwMzlLTURCTg%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067475055%2Fusing-ruby-with-mios-from-mi-casa-verde&amp;m=1\" target=\"_blank\">developer special program</a>and lack a ruby gem, so another rainy day project is born!\nThe operating system these devices run is called MiOS which is essentially Linux/ARM and lots of glue. Mi Casa Verde operates a free VPN service that allows you to operate them remotely, and there are a number of free/paid smartphone apps available (though none struck me as particularly special). All of the interactions with MiOS work on a job queue basis. When a job is submitted, it’s status must be polled for success/failure. The Ruby library embraces this and allows jobs to be run synchronously or asynchronously.\nSome snippets from the github page:<pre>mios = MiOS::Interface.new('http://192.168.15.1:3480')\nswitch = mios.devices[0]\nswitch.off! { |obj|\n  puts \"The #{obj.name} is now off\"\n}\nputs \"This will get printed once the switch is off and the block has been executed\"\nswitch.on!(true) { |obj|\n  puts \"The #{obj.name} is now on\"\n}\nputs \"This will output immediately\"\nsleep(5) # Sleep to wait for the thread to finish\n</pre>Every device is supported by manually issuing commands as listed<a title=\"Mi Casa Verde Luup variables and actions\" href=\"https://t.umblr.com/redirect?z=http%3A%2F%2Fwiki.micasaverde.com%2Findex.php%2FLuup_UPnP_Variables_and_Actions&amp;t=YzlhZGZiNTJlY2ZkYTkzN2U2ZDZkN2E2NWE3ODZlODZhMmQ2YTE5NiwwMzlLTURCTg%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067475055%2Fusing-ruby-with-mios-from-mi-casa-verde&amp;m=1\" target=\"_blank\">in the wiki</a> and the devices that I currently use have nice wrappers around those for idiomatic usage (<a title=\"Example of Door Lock API\" href=\"https://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fkreynolds%2Fruby-mios%2Fblob%2Fmaster%2Flib%2Fmios%2Fservices%2Fdoor_lock1.rb&amp;t=OGFmZmQ4OWI0MjUyZGE2MDZjOTY0NjAwZGE5MmNhMGU2YzcxNjNjNywwMzlLTURCTg%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067475055%2Fusing-ruby-with-mios-from-mi-casa-verde&amp;m=1\" target=\"_blank\">example</a>).\nInstallation instructions and additional usage examples can be found on github under the<a title=\"Ruby MiOS\" href=\"https://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fkreynolds%2Fruby-mios&amp;t=YjQ0NTU4MjEzOGVhYTdjYWIwNTcyZDY0NTZmMTUzYTFhYjg3YjI5NSwwMzlLTURCTg%3D%3D&amp;b=t%3A2q2t0Z-Cm5Q6MebxUd5EmA&amp;p=http%3A%2F%2Fwww.rubyscale.com%2Fpost%2F143067475055%2Fusing-ruby-with-mios-from-mi-casa-verde&amp;m=1\" target=\"_blank\">ruby-mios project</a>.\nEnjoy!</div></div></section><section class=\"panel\"></section></div></article></div><p>&#13;\n                                        &#13;\n                                        <a class=\"related-post-cta button bordered open-in-app\">See this in the app</a>&#13;\n                                        <a class=\"related-post-cta see-more button bordered\" href=\"http://www.rubyscale.com/\">Show more</a>&#13;</p></section></div></div></section><footer id=\"footer\" class=\"content clearfix\"></footer></section><noscript><noscript><noscript id=\"bootloader\" data-bootstrap=\"{&quot;Components&quot;:{&quot;PostActivity&quot;:[],&quot;NotificationPoller&quot;:{&quot;messaging_keys&quot;:[],&quot;token&quot;:&quot;c86f8a500596474a7ef5034081f694bd&quot;,&quot;inbox_unread&quot;:0},&quot;DesktopDashboardLogo&quot;:{&quot;animations&quot;:[[&quot;http:\\/\\/assets.tumblr.com\\/images\\/logo\\/hover-animations\\/1.png?_v=161861acded461bb6e995593a3bae835&quot;,&quot;http:\\/\\/assets.tumblr.com\\/images\\/logo\\/hover-animations\\/1@2x.png?_v=496a774637302a598c851381d00009b0&quot;]]},&quot;TumblelogIframe&quot;:{&quot;unified&quot;:true,&quot;variant&quot;:null,&quot;isCompact&quot;:false,&quot;tumblelogBundleSrc&quot;:&quot;http:\\/\\/assets.tumblr.com\\/client\\/prod\\/standalone\\/tumblelog\\/index.build.js?_v=d31f5c6ecc27fedacb700eee8f83161f&quot;,&quot;tumblelogName&quot;:&quot;rubyscalecom&quot;,&quot;isLoggedIn&quot;:false,&quot;isFriend&quot;:false,&quot;formKey&quot;:&quot;&quot;,&quot;canSubscribe&quot;:false,&quot;isSubscribed&quot;:false,&quot;tumblelogTitle&quot;:&quot;RubyScale&quot;,&quot;tumblelogAvatar&quot;:&quot;https:\\/\\/assets.tumblr.com\\/images\\/default_avatar\\/octahedron_closed_40.png&quot;,&quot;tumblelogHost&quot;:&quot;http:\\/\\/www.rubyscale.com&quot;,&quot;isOptica&quot;:true,&quot;isCustomTheme&quot;:false,&quot;themeHeaderImage&quot;:&quot;https:\\/\\/assets.tumblr.com\\/images\\/default_header\\/optica_pattern_07.png?_v=c52eb3e7fd4be5c98b8970b4c330d172&quot;,&quot;themeBackgroundColor&quot;:&quot;#FAFAFA&quot;,&quot;themeTitleColor&quot;:&quot;#444444&quot;,&quot;themeAccentColor&quot;:&quot;#529ECC&quot;,&quot;brag&quot;:false,&quot;adsEnabled&quot;:true,&quot;canShowAd&quot;:false,&quot;isPremium&quot;:false,&quot;showLrecAds&quot;:false,&quot;showStickyLrecBackfill&quot;:false,&quot;showGeminiAds&quot;:false,&quot;geminiSectionCodeDesktop&quot;:&quot;a10bca9c-0c5d-4a02-ab13-14ab8513d81d&quot;,&quot;geminiSectionCodeMobile&quot;:&quot;ced63809-b609-4aca-96a0-abc099acba6b&quot;,&quot;currentPageType&quot;:&quot;single_post&quot;,&quot;currentPage&quot;:&quot;1&quot;,&quot;searchQuery&quot;:&quot;&quot;,&quot;tag&quot;:&quot;&quot;,&quot;query&quot;:&quot;&quot;,&quot;chrono&quot;:false,&quot;postId&quot;:&quot;143067470585&quot;,&quot;src&quot;:&quot;http:\\/\\/www.rubyscale.com\\/post\\/143067470585\\/basic-time-series-with-cassandra&quot;,&quot;postUrl&quot;:&quot;&quot;,&quot;isBlocked&quot;:null,&quot;isAdmin&quot;:false,&quot;lookupButtonUrl&quot;:&quot;&quot;,&quot;showSpamButton&quot;:false,&quot;showRootPostButton&quot;:false,&quot;rootPostUrl&quot;:&quot;&quot;,&quot;showRadarPostButton&quot;:false,&quot;radarKeys&quot;:&quot;&quot;,&quot;isUniblocked&quot;:false,&quot;isNsfw&quot;:false,&quot;isAdult&quot;:false,&quot;isSpam&quot;:false,&quot;isPrimaryBlog&quot;:false,&quot;canEdit&quot;:false,&quot;canReblogSelf&quot;:false,&quot;showLikeButton&quot;:false,&quot;showReblogButton&quot;:false,&quot;reblogUrl&quot;:&quot;&quot;,&quot;showFanMailButton&quot;:false,&quot;showMessagingButton&quot;:false,&quot;loginCheckIframeSrc&quot;:&quot;http:\\/\\/assets.tumblr.com\\/assets\\/html\\/iframe\\/login_check.html?_v=3de94a184d600617102ddd5b48fb36e9&quot;,&quot;appInstallUrls&quot;:{&quot;android&quot;:&quot;https:\\/\\/play.google.com\\/store\\/apps\\/details?id=com.tumblr\\u0026referrer=utm_source%3Dtumblr%26utm_medium%3Diframe%26utm_campaign%3Dblog_network_floating_cta&quot;,&quot;ios&quot;:&quot;https:\\/\\/itunes.apple.com\\/app\\/apple-store\\/id305343404?pt=9029\\u0026ct=blog_network_floating_cta\\u0026mt=8&quot;},&quot;appOpenReferrer&quot;:&quot;tumblr_new_iframe&quot;,&quot;isShowSearch&quot;:true,&quot;supplyLogging&quot;:[],&quot;secondsSinceLastActivity&quot;:-1}},&quot;Flags&quot;:{&quot;doods&quot;:&quot;eyJmaWx0ZXJfbnNmdyI6dHJ1ZSwic2FmZV9tb2RlIjp0cnVlLCJzYWZlX21vZGVfZW5hYmxlZCI6dHJ1ZSwia2V5Y29tbWFuZF9hdXRvX3BhZ2luYXRlIjp0cnVlLCJsb2dnZWRfb3V0X3NlYXJjaCI6dHJ1ZSwia3Jha2VuX3dlYl9sb2dnaW5nX2xpYnJhcnkiOnRydWUsInNlY3VyZV9mb3JtX2tleSI6dHJ1ZSwic2VjdXJlX2Zvcm1fa2V5X2Z1bGx5X29uIjp0cnVlLCJ0dW1ibGVsb2dfcG9wb3ZlciI6dHJ1ZSwiY2Fub25pY2FsX3VybF93cml0ZXMiOnRydWUsImVuYWJsZV9jYXB0dXJlX2pzIjp0cnVlLCJwcmltYV9wb3N0X2Zvcm1zIjp0cnVlLCJsb2NrZWRfcmVibG9nX3VpIjp0cnVlLCJ0YWJsZXRfYmFubmVyX2FjdGl2ZSI6dHJ1ZSwibW9iaWxlX2Jhbm5lcl9hY3RpdmUiOnRydWUsImxvZ19zZWFyY2hfYm94Ijp0cnVlLCJ1c2VyX21lbnRpb25zIjp0cnVlLCJodG1sNV9hdWRpb19wbGF5ZXIiOnRydWUsInBvcG92ZXJfcmVjb21tZW5kYXRpb25zIjp0cnVlLCJpbmRhc2hfcmVjb21tZW5kYXRpb25zIjp0cnVlLCJwb3B0aWNhX3R1bWJsZWxvZ19wb3BvdmVycyI6dHJ1ZSwidHVtYmxyX3R2Ijp0cnVlLCJkZXByZWNhdGVfZmVhdHVyZWRfdGFncyI6dHJ1ZSwicmVibG9nX3VpX3JlZnJlc2giOnRydWUsInRhYl9zd2l0Y2hlciI6dHJ1ZSwiZmFzdF9jb21wb3NlIjp0cnVlLCJkYXNoYm9hcmRfcmVmcmVzaCI6dHJ1ZSwibW9iaWxlX3dlYl9waG90b3NldHMiOnRydWUsIm1vYmlsZV93ZWJfZ2F0ZSI6dHJ1ZSwibW9iaWxlX3dlYl9wYWdlX3RpdGxlcyI6dHJ1ZSwibW9iaWxlX3dlYl9hYnVzZV9mb3JtIjp0cnVlLCJkb250X2Nhc3RfanNfZm9sbG93cyI6dHJ1ZSwiYWRzX25ld192ZW5kb3JfYnV0dG9ucyI6dHJ1ZSwicmVhY3RpdmF0aW9uX2Zsb3ciOnRydWUsImd1bHBqc19hZG1pbiI6dHJ1ZSwiZW5hYmxlX2pzX2Vycm9yc19sb2ciOnRydWUsImVuYWJsZV9qc19lcGhlbWVyYWxfbG9nIjp0cnVlLCJqc19lcnJvcnNfYiI6dHJ1ZSwibG9nX2xhZHkiOnRydWUsImNzbG9nZ2VyX2pzIjp0cnVlLCJkaXNjb3ZlcnlfaHViX2FjY2VzcyI6dHJ1ZSwiaGVhZGVyX2FjY291bnRfbWVudSI6dHJ1ZSwiZW5hYmxlX3NoYXJlX2VtYmVkX2NvZGUiOnRydWUsInJlZGRpdF9zaGFyaW5nIjp0cnVlLCJwb3N0X2l0X2ZvcndhcmQiOnRydWUsInBlZXByX3NlYXJjaF9hbmRfZmlsdGVyIjp0cnVlLCJpbnRlcm5zX3BhZ2UiOnRydWUsImZvbGxvd2VkX3NlYXJjaGVzX2JpZ193ZWIiOnRydWUsImxpdmVwaG90b3Nfd2ViIjp0cnVlLCJzYWZlX21vZGVfb3duX3Bvc3QiOnRydWUsImhpZGVfZGVmYXVsdF9oZWFkZXJzX2Jsb2dfY2FyZHMiOnRydWUsInR5cGluZ19pbmRpY2F0b3Jfd3JpdGUiOnRydWUsImdkcHJfZ3VjZV9pc19yZXF1aXJlZCI6dHJ1ZSwiYXJjaGl2ZS1wbHVzIjp0cnVlLCJkYXJsYV9hZF9mZWVkYmFjayI6dHJ1ZSwic3RhdHVzX2luZGljYXRvciI6dHJ1ZSwiY29udmVyc2F0aW9uYWxfbm90aWZpY2F0aW9ucyI6dHJ1ZSwiZGlzYWJsZV95YWhvb19iX2Nvb2tpZSI6dHJ1ZSwibGl2ZXBob3RvcyI6dHJ1ZX0=&quot;},&quot;Context&quot;:{&quot;name&quot;:&quot;default&quot;,&quot;time&quot;:1538737946000,&quot;userinfo&quot;:{&quot;primary&quot;:&quot;&quot;,&quot;name&quot;:&quot;&quot;,&quot;channels&quot;:[]},&quot;hosts&quot;:{&quot;assets_host&quot;:&quot;http:\\/\\/assets.tumblr.com&quot;,&quot;secure_assets_host&quot;:&quot;https:\\/\\/assets.tumblr.com&quot;,&quot;www_host&quot;:&quot;http:\\/\\/www.tumblr.com&quot;,&quot;secure_www_host&quot;:&quot;https:\\/\\/www.tumblr.com&quot;,&quot;embed_host&quot;:&quot;https:\\/\\/embed.tumblr.com&quot;,&quot;safe_host&quot;:&quot;http:\\/\\/safe.txmblr.com&quot;,&quot;platform_host&quot;:&quot;http:\\/\\/platform.tumblr.com&quot;},&quot;language&quot;:&quot;en_US&quot;,&quot;language_simple&quot;:&quot;en&quot;,&quot;assets&quot;:&quot;http:\\/\\/assets.tumblr.com\\/client\\/prod\\/&quot;},&quot;Translations&quot;:{&quot;%1$sReport %2$s's post?%3$sIf it violates our community guidelines, we'll remove it.%4$s&quot;:&quot;%1$sReport %2$s's reblog?%3$sIf it violates our community guidelines, we'll remove it.%4$s&quot;,&quot;%1$sReport %2$s's reply?%3$sIf it violates our community guidelines, we'll remove it.%4$s&quot;:&quot;%1$sReport %2$s's reblog?%3$sIf it violates our community guidelines, we'll remove it.%4$s&quot;}}\"></noscript></noscript></noscript>"}}]}},"pageContext":{"alternative_id":12321}}