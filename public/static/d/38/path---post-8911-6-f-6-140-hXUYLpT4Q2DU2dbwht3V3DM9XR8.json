{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"LoyaltyOne/cassandra-aws","alternative_id":8911,"content":"<h3>\n      \n      README.md\n    </h3><article class=\"markdown-body entry-content\" itemprop=\"text\">\n<p>This CloudFormation template deploys 3 node Cassandra cluster in a single AWS region\nacross multiple Availability Zones.</p>\n<p>Cassandra storage is backed by AWS Elastic File System. Each cassandra node maintains its own data folder on a single File System.\nThis file system spans across multiple availability zones for redundancy.</p>\n<h3><a href=\"#why-efs\" aria-hidden=\"true\" class=\"anchor\" id=\"user-content-why-efs\"></a>Why EFS?</h3>\n<ul><li>No need to resize volumes when data increases (automatically handled)</li>\n<li>Backups of volumes are less crucial since EFS is replicated across Availability Zones</li>\n<li>Performance is good enough for non-prod environments</li>\n</ul><p><strong>Note</strong> Using EFS to back a cassandra cluster is only suitable for development purposes.\nConsider using EBS volumes or instance storage for production grade setups.</p>\n<p>TODO</p>\n<p>To generate a keystore and truststore for use by cassandra for encryption use\nthe <code>truststore-setup</code> script.</p>\n<p><code>truststore-setup</code> does the following:</p>\n<ul><li>Generates a keystore with a user supplied password which contains a private key used by Cassandra to establish secure\ncommunication amongst nodes in the cluster</li>\n<li>Generates a truststore which contains the public cert (corresponding to the private key in the keystore) for the cluster</li>\n<li>Generates a client PEM file containing the public cert for the cluster intended to be used with <strong>cqlsh</strong> for secure client-to-node communication</li>\n<li>Updates cassandra.yaml with the user supplied password for the keystore and truststore</li>\n</ul><p>Run the truststore-setup script and specify the password and cluster name.</p>\n<div class=\"highlight highlight-source-shell\"><pre>$ ./truststore-setup &lt;password&gt; &lt;clustername&gt;</pre></div>\n<p>This will generate the keystore and the truststore in <code>cassandra-config</code>:</p>\n<pre>cassandra-config/\n├── conf\n│   └── certs\n│       ├── cassandra.keystore\n│       └── cassandra.truststore\n...\n</pre>\n<p>For clients connecting to the cluster, the cassandra.truststore can be used to establish secure communication. This is a JKS based truststore.</p>\n<p>It will also generate the client pem in the root folder. This file can be used with <strong>cqlsh</strong></p>\n<pre>cluster-ca-certificate.pem\n</pre>\n<p>Sync the s3 bucket holding the Cassandra configuration and certs.</p>\n<div class=\"highlight highlight-source-shell\"><pre>$ aws s3 sync cassandra-config s3://cassandra-configuration/&lt;clustername&gt;</pre></div>\n<p><strong>Note:</strong> You must name the CloudFormation stack exactly the same as <code>&lt;clustername&gt;</code> defined above in order for\nencryption to work correctly.</p>\n<p>For example, we have named our bucket <code>sandbox-cassandra-configuration</code> and the name of the cluster is <code>sandbox-cassandra</code>:\n<a href=\"https://user-images.githubusercontent.com/14280155/33042220-03f05ef0-ce0f-11e7-8729-e4a9798079f2.png\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/14280155/33042220-03f05ef0-ce0f-11e7-8729-e4a9798079f2.png\" alt=\"image\" /></a></p>\n</article>"}}]}},"pageContext":{"alternative_id":8911}}