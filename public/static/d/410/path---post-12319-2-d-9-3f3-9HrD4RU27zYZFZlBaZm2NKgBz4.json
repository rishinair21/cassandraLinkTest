{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Optimizing Cassandra Performance: Sometimes Two Writes Are Better Than One | SignalFx","alternative_id":12319,"content":"<p>SignalFx is a <a href=\"https://www.signalfx.com/infrastructure-monitoring/\" target=\"_blank\">modern monitoring</a> service that ingests, stores and performs <a href=\"https://www.signalfx.com/why-signalfx/analytics/\" target=\"_blank\">real-time streaming analytics</a> on high-volume, high-resolution metric data from companies all over the world.</p><p>Providing real-time streaming analytics means that we ingest tens of billions of points of time series data per day, and we give our <a href=\"https://www.signalfx.com/customers/\" target=\"_blank\">customers</a> the capability to send data at one second resolution. All of this data ends up in <a href=\"https://www.signalfx.com/cassandra-monitoring\" target=\"_blank\">Cassandra</a>, which we use as the backend of our time series database (or TSDB).</p><p>We chose Cassandra for scalability and read and write performance at extremely high load. For operational efficiency, we’ve gone through multiple stages of performance optimization. And we came to the counterintuitive conclusion: sometimes two writes perform better than one.</p><h3>Measuring Overall Performance</h3><p>We built a test environment with a load simulator to measure the difference in Cassandra performance as we moved through each optimization stage. For a constant simulated load measured in data points per second, we monitored and measured:</p><ul><li>Write volume per second</li>\n<li>Write latency in milliseconds</li>\n<li>Host CPU load utilization</li>\n<li>Host disk writes in bytes per second</li>\n</ul><p>We compared Cassandra performance across these metrics as we transitioned from one stage to the next and show these comparisons in a handful of key charts.</p><h3>Stage 1: Vertical Writes</h3><p>Our Cassandra schema is what you would expect. Each data point consists of a key name (or a time series ID key), a timestamp and a value for that timestamp. Each time series has its own row in the table, and we create tables representing distinct time ranges.</p><div style=\"text-align: center;\">\n<table><tbody><tr><td>\n<h6>TSDB Schema</h6>\n</td>\n</tr><tr><td>\n<pre>CREATE TABLE table_0 (&#13;\n  timeseries text&#13;\n  time timestamp,&#13;\n  value blob,&#13;\n  PRIMARY KEY (timeseries, time)&#13;\n) WITH COMPACT STORAGE;&#13;\n</pre>\n</td>\n</tr></tbody></table></div><p>As each datapoint comes in, we write it to the appropriate row and column for that time series.</p><p><img class=\"aligncenter wp-image-6618 size-full\" src=\"https://www.signalfx.com/wp-content/uploads/Cassandra-1.gif\" alt=\"Cassandra 1\" width=\"480\" height=\"268\" /></p><p>It turns out that writing each data point individually is very expensive. In other words, touching every row, every second is a very expensive load pattern. So we decided to buffer data in memory and write multiple points for each time series in a single batch statement.</p><h3>Stage 2: Buffered Writes</h3><p>In this version of the ingest system, we will write new data into a memory-tier. A migrator process will periodically read data from the memory-tier, write it to Cassandra, and, once it’s safely in Cassandra, remove it from the memory-tier. In other words, the migrator picks up a time range of data and moves it as a batch into Cassandra.</p><p>The TSDB is now effectively two-tiered. The memory-tier is essentially a higher performance backend for the most recent data. It knows whether data for a specific time range belongs in the memory-tier or on Cassandra, and therefore routes reads and writes appropriately.</p><p><img class=\"aligncenter wp-image-6620 size-full\" src=\"https://www.signalfx.com/wp-content/uploads/Cassandra-2.gif\" alt=\"Cassandra 2\" width=\"480\" height=\"266\" /></p><p>There are two independent operations here:</p><ol><li>New points are being ingested on the right side (same as the non-buffered Cassandra case)</li>\n<li>Batches of points are being written to Cassandra on the left side</li>\n</ol><p>The buffered writes performance shows improvements in efficiency for Cassandra compared to vertical writes. While the write pattern is choppier, Cassandra is doing many fewer writes as the previous stage. These writes are larger, but the host CPU utilization decreases significantly.</p><p><img class=\"aligncenter wp-image-6621\" src=\"https://www.signalfx.com/wp-content/uploads/Cassandra-stage-1-to-2.png\" alt=\"Cassandra stage 1 to 2\" width=\"750\" height=\"354\" srcset=\"https://www.signalfx.com/wp-content/uploads/Cassandra-stage-1-to-2.png 975w, https://www.signalfx.com/wp-content/uploads/Cassandra-stage-1-to-2-300x142.png 300w, https://www.signalfx.com/wp-content/uploads/Cassandra-stage-1-to-2-500x236.png 500w, https://www.signalfx.com/wp-content/uploads/Cassandra-stage-1-to-2-552x260.png 552w\" /></p><p>So buffering was an improvement to performance, although there was more that we can do. In this stage, writing data point-by-point means that a column is created for each data point and this has implications for storage overhead in Cassandra.</p><h3>Stage 3: Packed Writes</h3><p>The next optimization stage is to have the migrator pack the contents of each batch of points into a single block which it writes to Cassandra. This reduces the number of columns and write operations in each row, which has a larger benefit for storage than CPU.</p><p><img class=\"aligncenter wp-image-6622 size-full\" src=\"https://www.signalfx.com/wp-content/uploads/Cassandra-3.gif\" alt=\"Cassandra 3\" width=\"480\" height=\"266\" /></p><p>This packed write operation is essentially the same as the previous, buffered case. However, we are writing fewer, bigger objects to Cassandra and the write rate has dropped tremendously. Latency also improves with fewer writes while data writes per disk also drops as blocks are more compact.</p><p><img class=\"aligncenter wp-image-6680\" src=\"https://www.signalfx.com/wp-content/uploads/Cassandra-2-to-3-1-300x142.png\" alt=\"\" width=\"750\" height=\"354\" srcset=\"https://www.signalfx.com/wp-content/uploads/Cassandra-2-to-3-1-300x142.png 300w, https://www.signalfx.com/wp-content/uploads/Cassandra-2-to-3-1-500x236.png 500w, https://www.signalfx.com/wp-content/uploads/Cassandra-2-to-3-1-552x260.png 552w, https://www.signalfx.com/wp-content/uploads/Cassandra-2-to-3-1.png 975w\" /></p><h3>Stage 4: Persistent Logs</h3><p>While the above changes represent significant performance improvements, they introduce a big problem: if a memory-tier server crashes, we lose all of the buffered data. Obviously that is not acceptable. We’ll solve that by writing data to Cassandra as we receive it. Why is that a good idea now when it performed so poorly before?</p><p>The answer is that we use a more favorable write pattern for Cassandra. The schema has row for each timestamp. Data points arriving at the same time for different time series typically have similar timestamps. Therefore, we can write these data points across a small number of rows in Cassandra instead of a row per time series as we did originally.</p><div style=\"text-align: center;\">\n<table><tbody><tr><td>\n<h6>TSDB Schema</h6>\n</td>\n<td>                         </td>\n<td>\n<h6>Log Schema</h6>\n</td>\n</tr><tr><td>\n<pre>CREATE TABLE table_0 (&#13;\n  timeseries text&#13;\n  time timestamp,&#13;\n  value blob,&#13;\n  PRIMARY KEY (timeseries, time)&#13;\n) WITH COMPACT STORAGE;&#13;\n</pre>\n</td>\n<td> </td>\n<td>\n<pre>CREATE TABLE table_0 (&#13;\n  stamp text,&#13;\n  sequence bigint,&#13;\n  value blob,&#13;\n  PRIMARY KEY (stamp, sequence)&#13;\n) WITH COMPACT STORAGE;&#13;\n</pre>\n</td>\n</tr></tbody></table></div><p>We write data points for different time series in the order they arrive so that we can get them onto persistent storage as quickly as possible. Because this order of arrival is effectively non-deterministic, there’s no efficient way to retrieve a datapoint for a specific time series.</p><p>This is not a problem as we only read this data when we need to construct the memory-tier of the ingest server; we do random reads from the memory-tier.</p><p><img class=\"aligncenter wp-image-6629 size-full\" src=\"https://www.signalfx.com/wp-content/uploads/Cassandra-4.gif\" alt=\"Cassandra 4\" width=\"480\" height=\"266\" /></p><p>The data is migrated from the memory-tier just as before. Once it’s been migrated, we can also remove the log data from Cassandra simply by truncating the table in which we store it.</p><p><img class=\"aligncenter wp-image-6630\" src=\"https://www.signalfx.com/wp-content/uploads/Cassandra-3-to-4.png\" alt=\"Cassandra 3 to 4\" width=\"750\" height=\"354\" srcset=\"https://www.signalfx.com/wp-content/uploads/Cassandra-3-to-4.png 975w, https://www.signalfx.com/wp-content/uploads/Cassandra-3-to-4-300x142.png 300w, https://www.signalfx.com/wp-content/uploads/Cassandra-3-to-4-500x236.png 500w, https://www.signalfx.com/wp-content/uploads/Cassandra-3-to-4-552x260.png 552w\" /></p><p>With this process, there are clearly more write operations and an increase in disk I/O. However there are no adverse effects on write latency or on CPU load and, of course, our data is protected from a crash.</p><h3>Ongoing Optimizations</h3><p>We’ve learned a lot about how to incrementally improve Cassandra performance based on these optimization stages. Our analysis shows that CPU load utilization is much more dependent on the rate of writes than on the volume of data being written. For our very write-heavy workload, we saw a very large efficiency improvement by doing fewer, larger writes. This lets us get much better utilization from our Cassandra cluster.</p><hr /><hr />"}}]}},"pageContext":{"alternative_id":12319}}