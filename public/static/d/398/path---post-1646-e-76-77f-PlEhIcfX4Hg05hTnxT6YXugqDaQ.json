{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"A Guide to Cassandra with Java","alternative_id":1646,"content":"<div class=\"short_box short_start\">\n<h3><b>I usually post about Persistence on Twitter - you can follow me there: </b></h3>\n<p><a class=\"twitter-follow-button\" href=\"https://twitter.com/baeldung\" data-show-count=\"true\" data-size=\"large\" data-dnt=\"true\">Follow @baeldung</a></p>\n</div><h2 id=\"Overview\"><strong>1. Overview</strong></h2>\n<p class=\"lead\">This tutorial is an introductory guide to the <a href=\"http://cassandra.apache.org/\">Apache Cassandra</a> database using Java.</p>\n<p>You will find key concepts explained, along with a working example that covers the basic steps to connect to and start working with this NoSQL database from Java.</p>\n<h2 id=\"Cassandra\"><strong>2. Cassandra</strong></h2>\n<p>Cassandra is a scalable NoSQL database that provides continuous availability with no single point of failure and gives the ability to handle large amounts of data with exceptional performance.</p>\n<p>This database uses a ring design instead of using a master-slave architecture. In the ring design, there is no master node – all participating nodes are identical and communicate with each other as peers.</p>\n<p>This makes Cassandra a horizontally scalable system by allowing for the incremental addition of nodes without needing reconfiguration.</p>\n<h3><strong>2.1. Key Concepts</strong></h3>\n<p>Let’s start with a short survey of some of the key concepts of Cassandra:</p>\n<ul><li><strong>Cluster </strong>– a collection of nodes or Data Centers arranged in a ring architecture. A name must be assigned to every cluster, which will subsequently be used by the participating nodes</li>\n<li><strong>Keyspace </strong>– If you are coming from a relational database, then the schema is the respective keyspace in Cassandra. The keyspace is the outermost container for data in Cassandra. The main attributes to set per keyspace are the <em>Replication Factor</em>, the <em>Replica Placement Strategy</em> and the <em>Column Families</em></li>\n<li><strong>Column Family </strong>–<strong> </strong>Column Families in Cassandra are like tables in Relational Databases. Each Column Family contains a collection of rows which are represented by a <em>Map&lt;RowKey, SortedMap&lt;ColumnKey, ColumnValue&gt;&gt;</em>. The key gives the ability to access related data together</li>\n<li><strong>Column</strong> – A column in Cassandra is a data structure which contains a column name, a value and a timestamp. The columns and the number of columns in each row may vary in contrast with a relational database where data are well structured</li>\n</ul><h2 id=\"Java\"><strong>3. Using the Java Client</strong></h2>\n<h3><strong>3.1. Maven Dependency</strong></h3>\n<p>We need to define the following Cassandra dependency in the <em>pom.xml</em>, the latest version of which can be found <a href=\"http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.datastax.cassandra%22\">here</a>:</p>\n<pre class=\"brush: xml; gutter: true\">&lt;dependency&gt;&#13;\n    &lt;groupId&gt;com.datastax.cassandra&lt;/groupId&gt;&#13;\n    &lt;artifactId&gt;cassandra-driver-core&lt;/artifactId&gt;&#13;\n    &lt;version&gt;3.1.0&lt;/version&gt;&#13;\n&lt;/dependency&gt;</pre>\n<p>In order to test the code with an embedded database server we should also add the <em>cassandra-unit</em> dependency, the latest version of which can be found <a href=\"http://search.maven.org/#search%7Cga%7C1%7Ccassandra-unit\">here</a>:</p>\n<pre class=\"brush: xml; gutter: true\">&lt;dependency&gt;&#13;\n    &lt;groupId&gt;org.cassandraunit&lt;/groupId&gt;&#13;\n    &lt;artifactId&gt;cassandra-unit&lt;/artifactId&gt;&#13;\n    &lt;version&gt;3.0.0.1&lt;/version&gt;&#13;\n&lt;/dependency&gt;</pre>\n<h3><strong>3.2. Connecting to Cassandra</strong></h3>\n<p>In order to connect to Cassandra from Java, we need to build a <em>Cluster</em> object.</p>\n<p>An address of a node needs to be provided as a contact point. If we don’t provide a port number, the default port (9042) will be used.</p>\n<p>These settings allow the driver to discover the current topology of a cluster.</p>\n<pre class=\"brush: java; gutter: true\">public class CassandraConnector {&#13;\n&#13;\n    private Cluster cluster;&#13;\n&#13;\n    private Session session;&#13;\n&#13;\n    public void connect(String node, Integer port) {&#13;\n        Builder b = Cluster.builder().addContactPoint(node);&#13;\n        if (port != null) {&#13;\n            b.withPort(port);&#13;\n        }&#13;\n        cluster = b.build();&#13;\n&#13;\n        session = cluster.connect();&#13;\n    }&#13;\n&#13;\n    public Session getSession() {&#13;\n        return this.session;&#13;\n    }&#13;\n&#13;\n    public void close() {&#13;\n        session.close();&#13;\n        cluster.close();&#13;\n    }&#13;\n}</pre>\n<h3><strong>3.3. Creating the Keyspace</strong></h3>\n<p>Let’s create our “<em>library</em>” keyspace:</p>\n<pre class=\"brush: java; gutter: true\">public void createKeyspace(&#13;\n  String keyspaceName, String replicationStrategy, int replicationFactor) {&#13;\n  StringBuilder sb = &#13;\n    new StringBuilder(\"CREATE KEYSPACE IF NOT EXISTS \")&#13;\n      .append(keyspaceName).append(\" WITH replication = {\")&#13;\n      .append(\"'class':'\").append(replicationStrategy)&#13;\n      .append(\"','replication_factor':\").append(replicationFactor)&#13;\n      .append(\"};\");&#13;\n        &#13;\n    String query = sb.toString();&#13;\n    session.execute(query);&#13;\n}</pre>\n<p>Except from the <em>keyspaceName</em> we need to define two more parameters, the <em>replicationFactor </em>and the <em>replicationStrategy</em>. These parameters determine the number of replicas and how the replicas will be distributed across the ring, respectively.</p>\n<p>With replication Cassandra ensures reliability and fault tolerance by storing copies of data in multiple nodes.</p>\n<p>At this point we may test that our keyspace has successfully been created:</p>\n<pre class=\"brush: actionscript3; gutter: true\">private KeyspaceRepository schemaRepository;&#13;\nprivate Session session;&#13;\n&#13;\n@Before&#13;\npublic void connect() {&#13;\n    CassandraConnector client = new CassandraConnector();&#13;\n    client.connect(\"127.0.0.1\", 9142);&#13;\n    this.session = client.getSession();&#13;\n    schemaRepository = new KeyspaceRepository(session);&#13;\n}</pre>\n<pre class=\"brush: java; gutter: true\">@Test&#13;\npublic void whenCreatingAKeyspace_thenCreated() {&#13;\n    String keyspaceName = \"library\";&#13;\n    schemaRepository.createKeyspace(keyspaceName, \"SimpleStrategy\", 1);&#13;\n&#13;\n    ResultSet result = &#13;\n      session.execute(\"SELECT * FROM system_schema.keyspaces;\");&#13;\n&#13;\n    List&lt;String&gt; matchedKeyspaces = result.all()&#13;\n      .stream()&#13;\n      .filter(r -&gt; r.getString(0).equals(keyspaceName.toLowerCase()))&#13;\n      .map(r -&gt; r.getString(0))&#13;\n      .collect(Collectors.toList());&#13;\n&#13;\n    assertEquals(matchedKeyspaces.size(), 1);&#13;\n    assertTrue(matchedKeyspaces.get(0).equals(keyspaceName.toLowerCase()));&#13;\n}</pre>\n<h3><strong>3.4. Creating a Column Family</strong></h3>\n<p>Now, we can add the first Column Family “books” to the existing keyspace:</p>\n<pre class=\"brush: java; gutter: true\">private static final String TABLE_NAME = \"books\";&#13;\nprivate Session session;&#13;\n&#13;\npublic void createTable() {&#13;\n    StringBuilder sb = new StringBuilder(\"CREATE TABLE IF NOT EXISTS \")&#13;\n      .append(TABLE_NAME).append(\"(\")&#13;\n      .append(\"id uuid PRIMARY KEY, \")&#13;\n      .append(\"title text,\")&#13;\n      .append(\"subject text);\");&#13;\n&#13;\n    String query = sb.toString();&#13;\n    session.execute(query);&#13;\n}</pre>\n<p>The code to test that the Column Family has been created, is provided below:</p>\n<pre class=\"brush: actionscript3; gutter: true\">private BookRepository bookRepository;&#13;\nprivate Session session;&#13;\n&#13;\n@Before&#13;\npublic void connect() {&#13;\n    CassandraConnector client = new CassandraConnector();&#13;\n    client.connect(\"127.0.0.1\", 9142);&#13;\n    this.session = client.getSession();&#13;\n    bookRepository = new BookRepository(session);&#13;\n}</pre>\n<pre class=\"brush: java; gutter: true\">@Test&#13;\npublic void whenCreatingATable_thenCreatedCorrectly() {&#13;\n    bookRepository.createTable();&#13;\n&#13;\n    ResultSet result = session.execute(&#13;\n      \"SELECT * FROM \" + KEYSPACE_NAME + \".books;\");&#13;\n&#13;\n    List&lt;String&gt; columnNames = &#13;\n      result.getColumnDefinitions().asList().stream()&#13;\n      .map(cl -&gt; cl.getName())&#13;\n      .collect(Collectors.toList());&#13;\n        &#13;\n    assertEquals(columnNames.size(), 3);&#13;\n    assertTrue(columnNames.contains(\"id\"));&#13;\n    assertTrue(columnNames.contains(\"title\"));&#13;\n    assertTrue(columnNames.contains(\"subject\"));&#13;\n}</pre>\n<h3><strong>3.5. Altering the Column Family</strong></h3>\n<p>A book has also a publisher, but no such column can be found in the created table. We can use the following code to alter the table and add a new column:</p>\n<pre class=\"brush: java; gutter: true\">public void alterTablebooks(String columnName, String columnType) {&#13;\n    StringBuilder sb = new StringBuilder(\"ALTER TABLE \")&#13;\n      .append(TABLE_NAME).append(\" ADD \")&#13;\n      .append(columnName).append(\" \")&#13;\n      .append(columnType).append(\";\");&#13;\n&#13;\n    String query = sb.toString();&#13;\n    session.execute(query);&#13;\n}</pre>\n<p>Let’s make sure that the new column <em>publisher</em> has been added:</p>\n<pre class=\"brush: java; gutter: true\">@Test&#13;\npublic void whenAlteringTable_thenAddedColumnExists() {&#13;\n    bookRepository.createTable();&#13;\n&#13;\n    bookRepository.alterTablebooks(\"publisher\", \"text\");&#13;\n&#13;\n    ResultSet result = session.execute(&#13;\n      \"SELECT * FROM \" + KEYSPACE_NAME + \".\" + \"books\" + \";\");&#13;\n&#13;\n    boolean columnExists = result.getColumnDefinitions().asList().stream()&#13;\n      .anyMatch(cl -&gt; cl.getName().equals(\"publisher\"));&#13;\n        &#13;\n    assertTrue(columnExists);&#13;\n}</pre>\n<h3><strong>3.6. Inserting data in the Column Family</strong></h3>\n<p>Now that the <em>books</em> table has been created, we are ready to start adding data to the table:</p>\n<pre class=\"brush: java; gutter: true\">public void insertbookByTitle(Book book) {&#13;\n    StringBuilder sb = new StringBuilder(\"INSERT INTO \")&#13;\n      .append(TABLE_NAME_BY_TITLE).append(\"(id, title) \")&#13;\n      .append(\"VALUES (\").append(book.getId())&#13;\n      .append(\", '\").append(book.getTitle()).append(\"');\");&#13;\n&#13;\n    String query = sb.toString();&#13;\n    session.execute(query);&#13;\n}</pre>\n<p>A new row has been added in the ‘books’ table, so we can test if the row exists:</p>\n<pre class=\"brush: java; gutter: true\">@Test&#13;\npublic void whenAddingANewBook_thenBookExists() {&#13;\n    bookRepository.createTableBooksByTitle();&#13;\n&#13;\n    String title = \"Effective Java\";&#13;\n    Book book = new Book(UUIDs.timeBased(), title, \"Programming\");&#13;\n    bookRepository.insertbookByTitle(book);&#13;\n        &#13;\n    Book savedBook = bookRepository.selectByTitle(title);&#13;\n    assertEquals(book.getTitle(), savedBook.getTitle());&#13;\n}</pre>\n<p>In the test code above we have used a different method to create a table named <em>booksByTitle:</em></p>\n<pre class=\"brush: java; gutter: true\">public void createTableBooksByTitle() {&#13;\n    StringBuilder sb = new StringBuilder(\"CREATE TABLE IF NOT EXISTS \")&#13;\n      .append(\"booksByTitle\").append(\"(\")&#13;\n      .append(\"id uuid, \")&#13;\n      .append(\"title text,\")&#13;\n      .append(\"PRIMARY KEY (title, id));\");&#13;\n&#13;\n    String query = sb.toString();&#13;\n    session.execute(query);&#13;\n}</pre>\n<p>In Cassandra one of the best practices is to use one-table-per-query pattern. This means, for a different query a different table is needed.</p>\n<p>In our example, we have chosen to select a book by its title. In order to satisfy the <em>selectByTitle</em> query, we have created a table with a compound <em>PRIMARY KEY</em> using the columns, <em>title</em> and <em>id</em>. The column <em>title</em> is the partitioning key while the <em>id</em> column is the clustering key.</p>\n<p>This way, many of the tables in your data model contain duplicate data. This is not a downside of this database. On the contrary, this practice optimizes the performance of the reads.</p>\n<p>Let’s see the data that are currently saved in our table:</p>\n<pre class=\"brush: java; gutter: true\">public List&lt;Book&gt; selectAll() {&#13;\n    StringBuilder sb = &#13;\n      new StringBuilder(\"SELECT * FROM \").append(TABLE_NAME);&#13;\n&#13;\n    String query = sb.toString();&#13;\n    ResultSet rs = session.execute(query);&#13;\n&#13;\n    List&lt;Book&gt; books = new ArrayList&lt;Book&gt;();&#13;\n&#13;\n    rs.forEach(r -&gt; {&#13;\n        books.add(new Book(&#13;\n          r.getUUID(\"id\"), &#13;\n          r.getString(\"title\"),  &#13;\n          r.getString(\"subject\")));&#13;\n    });&#13;\n    return books;&#13;\n}</pre>\n<p>A test for query returning expected results:</p>\n<pre class=\"brush: java; gutter: true\">@Test&#13;\npublic void whenSelectingAll_thenReturnAllRecords() {&#13;\n    bookRepository.createTable();&#13;\n        &#13;\n    Book book = new Book(&#13;\n      UUIDs.timeBased(), \"Effective Java\", \"Programming\");&#13;\n    bookRepository.insertbook(book);&#13;\n      &#13;\n    book = new Book(&#13;\n      UUIDs.timeBased(), \"Clean Code\", \"Programming\");&#13;\n    bookRepository.insertbook(book);&#13;\n        &#13;\n    List&lt;Book&gt; books = bookRepository.selectAll(); &#13;\n        &#13;\n    assertEquals(2, books.size());&#13;\n    assertTrue(books.stream().anyMatch(b -&gt; b.getTitle()&#13;\n      .equals(\"Effective Java\")));&#13;\n    assertTrue(books.stream().anyMatch(b -&gt; b.getTitle()&#13;\n      .equals(\"Clean Code\")));&#13;\n}</pre>\n<p>Everything is fine till now, but one thing has to be realized. We started working with table <em>books,</em> but in the meantime, in order to satisfy the <em>select</em> query by <em>title</em> column, we had to create another table named <em>booksByTitle.</em></p>\n<p>The two tables are identical containing duplicated columns, but we have only inserted data in the <em>booksByTitle</em> table. As a consequence, data in two tables is currently inconsistent.</p>\n<p>We can solve this using a <em>batch</em> query, which comprises two insert statements, one for each table. A <em>batch</em> query executes multiple DML statements as a single operation.</p>\n<p>An example of such query is provided:</p>\n<pre class=\"brush: java; gutter: true\">public void insertBookBatch(Book book) {&#13;\n    StringBuilder sb = new StringBuilder(\"BEGIN BATCH \")&#13;\n      .append(\"INSERT INTO \").append(TABLE_NAME)&#13;\n      .append(\"(id, title, subject) \")&#13;\n      .append(\"VALUES (\").append(book.getId()).append(\", '\")&#13;\n      .append(book.getTitle()).append(\"', '\")&#13;\n      .append(book.getSubject()).append(\"');\")&#13;\n      .append(\"INSERT INTO \")&#13;\n      .append(TABLE_NAME_BY_TITLE).append(\"(id, title) \")&#13;\n      .append(\"VALUES (\").append(book.getId()).append(\", '\")&#13;\n      .append(book.getTitle()).append(\"');\")&#13;\n      .append(\"APPLY BATCH;\");&#13;\n&#13;\n    String query = sb.toString();&#13;\n    session.execute(query);&#13;\n}</pre>\n<p>Again we test the batch query results like so:</p>\n<pre class=\"brush: java; gutter: true\">@Test&#13;\npublic void whenAddingANewBookBatch_ThenBookAddedInAllTables() {&#13;\n    bookRepository.createTable();&#13;\n        &#13;\n    bookRepository.createTableBooksByTitle();&#13;\n    &#13;\n    String title = \"Effective Java\";&#13;\n    Book book = new Book(UUIDs.timeBased(), title, \"Programming\");&#13;\n    bookRepository.insertBookBatch(book);&#13;\n    &#13;\n    List&lt;Book&gt; books = bookRepository.selectAll();&#13;\n    &#13;\n    assertEquals(1, books.size());&#13;\n    assertTrue(&#13;\n      books.stream().anyMatch(&#13;\n        b -&gt; b.getTitle().equals(\"Effective Java\")));&#13;\n        &#13;\n    List&lt;Book&gt; booksByTitle = bookRepository.selectAllBookByTitle();&#13;\n    &#13;\n    assertEquals(1, booksByTitle.size());&#13;\n    assertTrue(&#13;\n      booksByTitle.stream().anyMatch(&#13;\n        b -&gt; b.getTitle().equals(\"Effective Java\")));&#13;\n}</pre>\n<p>Note: As of version 3.0, a new feature called “Materialized Views” is available , which we may use instead of <em>batch</em> queries. A well-documented example for “Materialized Views” is available <a href=\"http://www.datastax.com/dev/blog/new-in-cassandra-3-0-materialized-views\">here</a>.</p>\n<h3><strong>3.7. Deleting the Column Family</strong></h3>\n<p>The code below shows how to delete a table:</p>\n<pre class=\"brush: java; gutter: true\">public void deleteTable() {&#13;\n    StringBuilder sb = &#13;\n      new StringBuilder(\"DROP TABLE IF EXISTS \").append(TABLE_NAME);&#13;\n&#13;\n    String query = sb.toString();&#13;\n    session.execute(query);&#13;\n}</pre>\n<p>Selecting a table that does not exist in the keyspace results in an <em>InvalidQueryException: unconfigured table books</em>:</p>\n<pre class=\"brush: java; gutter: true\">@Test(expected = InvalidQueryException.class)&#13;\npublic void whenDeletingATable_thenUnconfiguredTable() {&#13;\n    bookRepository.createTable();&#13;\n    bookRepository.deleteTable(\"books\");&#13;\n       &#13;\n    session.execute(\"SELECT * FROM \" + KEYSPACE_NAME + \".books;\");&#13;\n}</pre>\n<h3><strong>3.8. Deleting the Keyspace</strong></h3>\n<p>Finally, let’s delete the keyspace:</p>\n<pre class=\"brush: java; gutter: true\">public void deleteKeyspace(String keyspaceName) {&#13;\n    StringBuilder sb = &#13;\n      new StringBuilder(\"DROP KEYSPACE \").append(keyspaceName);&#13;\n&#13;\n    String query = sb.toString();&#13;\n    session.execute(query);&#13;\n}</pre>\n<p>And test that the keyspace has been deleted:</p>\n<pre class=\"brush: java; gutter: true\">@Test&#13;\npublic void whenDeletingAKeyspace_thenDoesNotExist() {&#13;\n    String keyspaceName = \"library\";&#13;\n    schemaRepository.deleteKeyspace(keyspaceName);&#13;\n&#13;\n    ResultSet result = &#13;\n      session.execute(\"SELECT * FROM system_schema.keyspaces;\");&#13;\n    boolean isKeyspaceCreated = result.all().stream()&#13;\n      .anyMatch(r -&gt; r.getString(0).equals(keyspaceName.toLowerCase()));&#13;\n        &#13;\n    assertFalse(isKeyspaceCreated);&#13;\n}</pre>\n<h2 id=\"Conclusion\"><strong>4. Conclusion</strong></h2>\n<p>This tutorial covered the basic steps of connecting to and using the Cassandra database with Java. Some of the key concepts of this database have also been discussed in order to help you kick start.</p>\n<p>The full implementation of this tutorial can be found in the <a href=\"https://github.com/eugenp/tutorials/tree/master/java-cassandra\">Github project</a>.</p>\n<div class=\"short_box short_end\">\n<h3><b>I usually post about Persistence on Twitter - you can follow me there: </b></h3>\n<p><a class=\"twitter-follow-button\" href=\"https://twitter.com/baeldung\" data-show-count=\"true\" data-size=\"large\" data-dnt=\"true\">Follow @baeldung</a><br/></p>\n</div>\n<div class=\"tve-leads-post-footer tve-tl-anim tve-leads-track-post_footer-114 tl-anim-instant\"><div class=\"tl-style\" id=\"tve_blank_set\" data-state=\"114\"><div class=\"tve-leads-conversion-object\" data-tl-type=\"post_footer\"><div class=\"tve_flt\"><div id=\"tve_editor\" class=\"tve_shortcode_editor\"><div class=\"thrv-leads-form-box tve_no_drag tve_no_icons tve_element_hover thrv_wrapper tve_editor_main_content tve_blank_set tve_white tve_brdr_none tve_clearfix tve_empty_dropzone\" data-tve-custom-colour=\"16400006\">\n<div class=\"thrv_wrapper tve_image_caption\">\n<img class=\"tve_image\" alt=\"\" src=\"http://cdn2.baeldung.netdna-cdn.com/wp-content/uploads/2016/05/baeldung-persistence-post-footer-main-1.2.0.jpg\" width=\"800\" height=\"360\"/></div><div class=\"thrv_wrapper thrv_content_container_shortcode jacksonGray\">\n<div class=\"tve_content_inner tve_center tve_empty_dropzone\">\n<div class=\"thrv_wrapper thrv_columns tve_clearfix\">\n<div class=\"tve_colm tve_foc tve_df tve_ofo  tve_empty_dropzone\">\n<div class=\"thrv_wrapper tve_image_caption aligncenter\">\n<img class=\"tve_image postFooterIcon\" alt=\"\" src=\"http://cdn2.baeldung.netdna-cdn.com/wp-content/uploads/2016/05/baeldung-persistence-post-footer-icn-1.0.0.png\" width=\"120\" height=\"100\"/></div></div>\n<div class=\"tve_colm tve_tfo tve_df tve_lst tve_empty_dropzone\"><p class=\"rft tve_p_left\" data-unit=\"px\">An intro SPRING data, JPA and<br/>Transaction Semantics Details with JPA</p><p class=\"rft\" data-unit=\"px\">Get Persistence right with Spring</p>\n</div>\n</div>\n</div>\n</div>\n</div></div></div></div></div></div>"}}]}},"pageContext":{"alternative_id":1646}}