{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Jon Haddad: Cassandra Summit Recap - Diagnosing Problems in Production","alternative_id":9193,"content":"<p>Last week at the Cassandra Summit I gave a talk with <a href=\"https://twitter.com/rustyrazorblade/status/511932312515526656\">Blake Eggleston</a> on diagnosing performance problems in production.  We spoke to about 300 people for about 25 minutes followed by a healthy Q&amp;A session.  I've expanded on our presentation to include a few extra tools, screenshots, and more clarity on our talking points.</p><p>There's finally a lot of material available for someone looking to get started with Cassandra.  There's several introductory videos on YouTube by both <a href=\"https://www.youtube.com/watch?v=W45Ysb9b6oE\">me</a> and <a href=\"https://www.youtube.com/watch?v=B-bTPSwhsDY\">Patrick McFadin</a> as well as videos on <a href=\"https://www.youtube.com/watch?v=Vv3QJxAdjic\">time series data modeling</a>.  I've posted videos for my own project, cqlengine, (<a href=\"https://www.youtube.com/watch?v=zrbQcPNMbB0\">intro</a> &amp; <a href=\"https://www.youtube.com/watch?v=clXN9pnakvI\">advanced</a>), and plenty more on the <a href=\"https://www.youtube.com/channel/UCvP-AXuCr-naAeEccCfKwUA\">PlanetCassandra channel</a>.  There's also a boatload of <a href=\"http://planetcassandra.org/client-drivers-tools/\">getting started</a> material on PlanetCassandra written by <a href=\"https://twitter.com/rebccamills\">Rebecca Mills</a>.</p>\n<p>This is the guide for what to do once you've built your application and you're ready to put Cassandra in production.  Whether you've been in operations for years or you are first getting started, this post should give you a good sense of what you need in order to address any issues you encounter.</p>\n<p>The original slides are available via <a href=\"http://www.slideshare.net/JonHaddad/diagnosing-problems-in-production-cassandra-summit-2014\">Slideshare</a>.</p>\n<p>Update: the presentation is now <a href=\"https://www.youtube.com/watch?v=QOwVDcLZd0A\">available on YouTube</a>!</p>\n<iframe width=\"560\" height=\"315\" src=\"http://www.youtube.com/embed/QOwVDcLZd0A\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\">[embedded content]</iframe>\n<p>Before you even put your cluster under load, there's a few things you can set up that will help you diagnose problems if they pop up.</p>\n<ol><li>\n<p>Ops center</p>\n<p>This is the standard management tool for Cassandra clusters.  This is recommended for every cluster.  While not open source, the community version is free.  It gives you a high level overview of your cluster and provides historical metrics for the most important information.  It comes with a variety of graphs that handle about 90% of what you need on a day to day basis.</p>\n<p><img src=\"http://www.datastax.com/wp-content/themes/datastax-2013/images/opscenter/opsc4-ring-view-c-hadoop-solr.jpg\" alt=\"image\" /></p>\n</li>\n<li>\n<p>Metrics plugins</p>\n<p>Cassandra has since version 1.1 included the <a href=\"https://dropwizard.github.io/metrics/3.1.0/\">metrics library</a>.  In every release it tracks more metrics using it.  <strong>Why is this awesome?</strong>  In previous persons of Cassandra, the standard way to access what was going on in the internals was over JMX, a very Java centric communications protocol.  That meant writing a Java Agent, setting up mx4j, or Jolokia, then digging through JMX, which can be a little hairy.  Not everyone wants to do this much work.</p>\n<p>The metrics library allows you to tell Cassandra to report its internal, table level metrics out to a whole slew of different places.  Out to CSV, Ganglia, Graphite, and STDOUT, and it's pluggable to push metrics to anywhere you want.</p>\n<p><img src=\"http://www.datastax.com/wp-content/uploads/2013/11/client-vs-cf.png\" alt=\"image\" /></p>\n<p><a href=\"http://www.datastax.com/dev/blog/pluggable-metrics-reporting-in-cassandra-2-0-2\">Read more about the metrics library integration.</a></p>\n</li>\n<li>\n<p>Munin, Nagios, Icinga (or other system metrics monitoring)</p>\n<p>I've found these tools to be incredibly useful at graphing system metrics as well as custom application metrics.  There are many options.  If you're already familiar with one tool, you can probably keep using it.  There are hosted solutions as well (server density, data dog, etc)</p>\n<p><img alt=\"munin\" src=\"http://rustyrazorblade.com/images/cassandra_writes.png\" /></p>\n</li>\n<li>\n<p>Statsd, Graphite, Grafana</p>\n<p>Your application should be tracking internal metrics.  Timing queries, frequently called functions, etc.  These tools let you get a profile of what's going on with your code in production.  Statsd collects raw stats and aggregates them together, then kicks them to graphite.  Grafana is an optional (better) front end to Graphite.</p>\n<p>There was a great post by etsy, <a href=\"http://codeascraft.com/2011/02/15/measure-anything-measure-everything/\">Measure Anything, Measure Everything</a>, that introduced statsd and outlined its usage with Graphite.  </p>\n<p><img alt=\"graphite\" src=\"http://rustyrazorblade.com/images/cassandra-graphite2.png\" /></p>\n</li>\n<li>\n<p>Logstash</p>\n<p>We didn't mention <a href=\"http://logstash.net/\">Logstash</a> in our presentation, but we've found it to be incredibly useful in correlating application issues with other failures.  This is useful for application logging aggregation.  If you don't want to host your own log analysis tool, there are hosted services for this as well.</p>\n<p><img alt=\"logstash\" src=\"http://rustyrazorblade.com/images/logstash_blog-1024x514.png\" /></p>\n</li>\n</ol><p>There's a bunch of system tools that are useful if you're logged onto a machine and want to see real time information.  </p>\n<ol><li>\n<p>iostat</p>\n<p>iostat is useful for seeing what's happening with each disk on your machine.  If you're hitting I/O issues, you'll see it here.  Specifically, you're looking for high read &amp; write rates and a big avgqu-sz (disk queue), or a high svctm (service time) there's a good chance you're bottlenecked on your disk.  You either want to use more disks or faster disks.  Cassandra loves SSDs.</p>\n<p><img alt=\"iostat\" src=\"http://rustyrazorblade.com/images/iostat.png\" /></p>\n</li>\n<li>\n<p>htop</p>\n<p>Htop is a better version of top, which is useful for getting a quick glance at your system.  It shows load, running processes, memory usage, and a bunch of other information at a quick glance.</p>\n<p><img alt=\"htop\" src=\"http://rustyrazorblade.com/images/htop.png\" /></p>\n</li>\n<li>\n<p>iftop &amp; netstat</p>\n<p>iftop is like top, but shows you active connections and the transfer rates between your server and whoever is at the other end.  </p>\n<p><img alt=\"iftop\" src=\"http://rustyrazorblade.com/images/iftop.png\" /></p>\n<p>Netstat is more of a networking swiss army knife.  You can see network connections, routing tables, interface statistics, and a variety of other network information.</p>\n<p><img alt=\"netstat\" src=\"http://rustyrazorblade.com/images/netstat.png\" /></p>\n</li>\n<li>\n<p>dstat</p>\n<p>I prefer to use dstat over iostat now since it includes all of its functionality and much of the functionality of other tools as well.</p>\n<p><img alt=\"dstat\" src=\"http://rustyrazorblade.com/images/dstat.png\" /></p>\n</li>\n<li>\n<p>strace</p>\n<p>strace is useful when you want to know what system calls are happening for a given process.</p>\n<p><img alt=\"strace\" src=\"http://rustyrazorblade.com/images/strace.png\" /></p>\n</li>\n<li>\n<p>pcstat</p>\n<p>This tool, written by <a href=\"https://twitter.com/AlTobey\">Al Tobey</a>, allows you to examine a bunch of files and quickly determine how much of each file is in the buffer cache.  If you're trying to figure out why table access is slow, this tool can tell you if your data is in cache already or if you have to go out to disk.  <a href=\"http://www.linuxatemyram.com/\">Here's a good read</a> to get familiar with buffer cache.  <a href=\"https://github.com/tobert/pcstat\">Check out the repo</a>.</p>\n<p><img alt=\"pcstat\" src=\"http://rustyrazorblade.com/images/pcstat.png\" /></p>\n</li>\n</ol><p>There's a few issues that are easy to run into that I'd consider \"gotchas\", things that come up often enough that they're worth mentioning.</p>\n<h2>Clock skew</h2>\n<p>A important design decision in Cassandra is that it uses last write wins when there are two inserts, updates, or deletes to a cell.  To determine the last update, Cassandra uses the system clock (or the client can specify the time explicitly).  If server times are different, the last write may not actually win, it'll be the one that's the most skewed into the future.  </p>\n<p>To address this issue, always make sure your clocks are synced.  Ntpd will constantly correct for drift.  ntpdate will perform a hard adjustment to your system clock.  Ntpdate needs to be used if you clock is significantly off, and ntpd will keep it at the correct time.</p>\n<p><img alt=\"ntpdate\" src=\"http://rustyrazorblade.com/images/ntpdate.png\" /></p>\n<h2>Disk space not reclaimed</h2>\n<p>if you add new nodes to a cluster, each replica is responsible for less data.  it's streamed to the new nodes.  however, it is not removed from the old nodes.  If you're adding new nodes because you're running low on disk space, this is extremely important.  You are required to run <code>nodetool cleanup</code> in order to reclaim that disk space.  This is a good idea any time you change your database topology.</p>\n<h2>Issues adding nodes, or running repairs</h2>\n<p>There are two common problems that come up with repair.  The first is that repairs take forever in 2.0.  <a href=\"http://www.datastax.com/dev/blog/more-efficient-repairs\">This is solved in 2.1</a> which uses an incremental repair, and does not repair data which has already been repaired.  The second issue relates to trying to repair (or add nodes) to a cluster when the versions do not match.  It is, in general, not a good idea (yet) to stream data between servers which are of different versions.  It will appear to have started, but will just hang around doing nothing.</p>\n<p>Cassandra comes with several tools to help diagnose performance problems.  They are available via <code>nodetool</code>, Cassandra's multipurpose administration tool.</p>\n<h2>Compaction</h2>\n<p>Compaction is the process of merging SSTables together.  It reduces the number of seeks required to return a result.  It's a necessary part of Cassandra.  If not configured correctly, it can be problematic.  You can limit the I/O used by compaction by using <code>nodetool setcompactionthroughput</code>.</p>\n<p>There's 2 types of compaction available out of the box.  Size Tiered is the default and great for write heavy workloads.  Leveled compaction is good for read &amp; update heavy workloads, but since it uses much higher I/O it's recommended you use this only if you're on SSD.  I recommend reading through the <a href=\"http://datastax.com/documentation/cassandra/2.0/cassandra/operations/ops_configure_compaction_t.html\">documentation</a> to understand more about which is right for your workload.</p>\n<p><img src=\"http://www.datastax.com/documentation/cassandra/2.0/cassandra/images/dml_compaction.png\" alt=\"image\" /></p>\n<h2>Cfstats and Histograms</h2>\n<p>Histograms let you quickly understand at both a high level and table level what your performance looks like on a single node in your cluster.  The first histogram, <code>proxyhistograms</code>, give you a quick top level view of all your tables on a node.  This includes network latency.  Histogram output has changed between versions to be more user friendly.  The screenshot below is from Cassandra 2.1.</p>\n<p><img alt=\"proxyhistograms\" src=\"http://rustyrazorblade.com/images/proxyhistograms.png\" /></p>\n<p>If you'd like to find out if you've got a performance problem isolated to a particular table, I suggest first running <code>nodetool cfstats</code> on a keyspace.  You'll be able to scan the list of tables and see if there's any abnormalities.  You'll be able to quickly tell which tables are queried the most (both reads and writes).</p>\n<p><img alt=\"cfstats\" src=\"http://rustyrazorblade.com/images/cfstats.png\" /></p>\n<p><code>nodetool cfhistograms</code> lets you identify performance problems with a single table on a single node.  The statistics are more easily read in Cassandra 2.1.</p>\n<p><img alt=\"cfhistograms\" src=\"http://rustyrazorblade.com/images/cfhistograms.png\" /></p>\n<h2>Query Tracing</h2>\n<p>If you've narrowed down your problem to a particular table, you can start to trace the queries that you execute.  If you're coming from a something like MySQL, you're used to the command <code>explain</code>, which tells in in advance what the query plan is for a given query.  Tracing takes a different approach.  Instead of showing a query plan, query tracing keeps track of the events in the system whewn it actually executes.  Here's an example where we've created a whole bunch of tombstones on a partition.  Even on a SSD you still want to avoid a lot of tombstones - it's disk, CPU, and memory intensive.</p>\n<p><img alt=\"tracing\" src=\"http://rustyrazorblade.com/images/tracing.png\" /></p>\n<p>The JVM gets a reputation for being a bit of a beast.  It's a really impressive feat of engineering, but it shouldn't be regarded as black magic.  I strongly recommend reading through <a href=\"http://blakeeggleston.com/cassandra-tuning-the-jvm-for-read-heavy-workloads.html\">Blake Eggleston's post on the JVM</a>, it's well written and does a great job of explaining things. (Much better than I would here).  </p>\n<p>OK - we've got all these tools under our belt.  Now we can start to narrow down the problem.</p>\n<ul><li>\n<p>Are you seeing weird consistency issues, even on consistency level ALL?<br />It's possible you're dealing with a clock sync issue.  If you're sending queries really close to one another, they might also be getting the same millisecond level timestamp due to an async race condition in your code.  If you're sending lots of writes at the same time to the same row, you may have a problem in your application.  Try to rethink your data model to avoid this.</p>\n</li>\n<li>\n<p>Has query performance dropped?\n    Are you bottlenecked on disk, network, CPU, memory?  Use the tools above to figure out your bottleneck.  Did the number of queries to your cluster increase?  Are you seeing longer than normal garbage collection times?  Ops center has historical graphs that are useful here.  Is there a single table affected, or every table?  Use histograms and cfstats to dig into it.  </p>\n</li>\n<li>\n<p>Are nodes going up and down?\n    Use a combination of ops center and your system metrics to figure out which node it is.  If it's the same node, start investigating why.  Is there a hot partition?  Is it doing a lot of garbage collection?  Is your application opening more connections than before?  You should have system metrics that show these trends over time.  Maybe you just have additional load on the system - it may be necessary to add new nodes.  Don't forget to run cleanup.</p>\n</li>\n</ul><p>This started out as a small recap but has evolved into much more than that.  The tools above have helped me a wide variety of problems, not just Cassandra ones.  If you follow the above recommendations you should be in a great spot to diagnose most problems that come your way.  </p>\n<p>You can find me on <a href=\"https://twitter.com/rustyrazorblade\">Twitter</a> for any comments or suggestions.</p>"}}]}},"pageContext":{"alternative_id":9193}}