{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"More Efficient Repairs in 2.1","alternative_id":9304,"content":"<p dir=\"ltr\" style=\"text-align: justify;\">Repairs are important for every Cassandra cluster, especially when frequently deleting data. Running the <code>nodetool repair</code> command initiates the repair process on a specific node which in turn computes a Merkle tree for each range of data on that node. The <a title=\"Merkle Tree\" href=\"http://en.wikipedia.org/wiki/Merkle_tree\" target=\"_blank\">merkle tree</a> is a binary tree of hashes used by Cassandra for calculating the differences in datasets between nodes in a cluster. Every time a repair is carried out, the tree has to be calculated, each node that is involved in the repair has to construct its merkle tree from all the sstables it stores making the calculation very expensive. This allows for repairs to be network efficient as only targeted rows identified by the merkle tree as inconsistencies are sent across the network.</p><p dir=\"ltr\" style=\"text-align: justify;\">Scanning every sstable to allow for the creation of merkle trees is an expensive operation. To avoid the need for constant tree construction incremental repairs are being introduced in Cassandra 2.1. The idea is to persist already repaired data, and only calculate merkle trees for sstables that haven’t previously undergone repairs allowing the repair process to stay performant and lightweight even as datasets grow so long as repairs are run frequently.</p><p><img class=\"aligncenter\" src=\"https://www.datastax.com/wp-content/uploads/2014/02/inc-vs-regular-repair-trees1.png\" alt=\"Tree construction comparison between regular and incremental repairs\" /></p><p dir=\"ltr\" style=\"text-align: justify;\">Incremental repairs begin with the repair leader sending out a prepare message to its peers. Each node builds a merkle tree from the unrepaired sstables, which it can distinguish by the new <code>repairedAt</code> field in each sstable’s metadata. Once the leader receives a merkle tree from each node, it compares the trees and issues streaming requests, just as in the classic repair case. Finally, the leader issues an anticompaction command. Anticompaction is the process of segregating repaired and unrepaired ranges into separate sstables; repaired sstables are written with a new <code>repairedAt</code> field denoting the time of repair. Since sstable are not locked against compaction during the repair, they might get removed via compaction before the process completes. This costs us some efficiency, since they will be repaired again later, but does not harm correctness.</p><h2>Compaction with incremental repairs</h2><p dir=\"ltr\" style=\"text-align: justify;\">Maintaining separate pools of repaired and unrepaired sstables causes some extra complexity for compaction to deal with. For example, in the diagram below we repair a range covering half of the initial sstable. After repair, anticompaction splits it into a set of repaired and unrepaired sstables, at which point leveled and size-tiered compaction strategies handle segregation of the data differently.</p><p>Size-Tiered compaction takes a simple approach of splitting repaired and unrepaired sstables into separate pools, each of which is compacted independently. Leveled compaction simply performs size-tiered compaction on unrepaired data, moving into the proper levels after repair. This cuts down on write amplification compared to maintaining two leveling pools.</p><p><img class=\"aligncenter\" src=\"https://www.datastax.com/wp-content/uploads/2014/02/STCS-vs-Leveled-in-5351-repairs.png\" alt=\"SizeTiered Compaction vs Leveled compaction in incremental repairs\" /></p><h2>Migrating to incremental repairs</h2><p dir=\"ltr\" style=\"text-align: justify;\">Full repairs remain the default, largely so Cassandra doesn't have to guess the repaired state of existing sstables. Guessing that everything is fully repaired is obviously problematic; guessing that nothing is repaired is less obviously so: LCS would start size-tiering everything, since that is what it does now with unrepaired data! To avoid this, compaction remains unchanged until incremental repair is first performed and compaction detects sstables with the <code>repairedAt</code> flag.</p><p>Incremental repairs can be opted into via the <code>-inc</code> option to <code>nodetool repair</code>. This is compatible with both sequential and parallel (<code>-par</code>) repair, e.g., <code>bin/nodetool -par -inc &lt;ks&gt; &lt;cf&gt;</code>. When an sstable is fully covered by a repaired range, no anticompaction will occur, it will just rewrite the repairedAt field in sstable metadata. Recovering from missing data or corrupted sstables will require a non-incremental full repair.  (For more on anticompaction, see <a href=\"https://www.datastax.com/dev/blog/anticompaction-in-cassandra-2-1\">Marcus's post here</a>.)</p><h2>Effect of tools / commands on repair status</h2><p dir=\"ltr\" style=\"text-align: justify;\">Since the sstable’s repair status is now tracked via it’s metadata, understanding how the set of tools provided with open-source Cassandra can impact this repair status becomes important.</p><ul><li>Bulk Loading - even if repaired in a different cluster, loaded tables will be unrepaired.</li>\n<li>Scrubbing - if scrubbing results in dropping rows, new sstables will be become unrepaired, however if no bad rows are detected, the sstable will keep its original repairedAt field.</li>\n<li>Major compaction - STCS will combine each of its pools into a single sstable, one repaired and one not. Major compaction continues to have no effect under LCS.</li>\n<li>Setting Repaired Status - a new tool added in 2.1 beta 2 can be found in <code>tools/bin/sstablerepairedset</code> that allows users to mark an sstable as repaired manually allowing for an easy migration to using incremental repairs by using the <code>sstablerepairedset --is-repaired &lt;sstable&gt;</code> command. It's important to only use this tool on repaired sstables, the status of an sstable can be checked via the <code>/tools/bin/sstablemetadata</code> tool by looking at the repairedAt field.</li>\n</ul><hr /><p><a href=\"https://www.datastax.com/\">DataStax</a> has many ways for you to advance in your career and knowledge. \n</p><p>You can take <a href=\"https://academy.datastax.com/user/register?destination=home&amp;utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_DSA_register\" target=\"_self\" title=\"academy.datastax.com\">free classes</a>, <a href=\"https://academy.datastax.com/certifications?utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_DSA_certifications\" target=\"_self\" title=\"academy.datastax.com/certifications\">get certified</a>, or read <a href=\"https://www.datastax.com/dbas-guide-to-nosql\" target=\"_self\" title=\"dbas-guide-to-nosql\">one of our many white papers</a>.\n</p><p><a href=\"https://academy.datastax.com/user/register?destination=home&amp;utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_DSA_register\" target=\"_self\" class=\"dxAllButtons_v3Rad2_whiteNGrayOL\" title=\"academy.datastax.com\">register for classes</a>\n</p><p><a href=\"https://academy.datastax.com/certifications?utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_DSA_certifications\" target=\"_self\" class=\"dxAllButtons_v3Rad2_whiteNGrayOL\" title=\"academy.datastax.com/certifications\">get certified</a>\n</p><p><a href=\"http://www.datastax.com/dbas-guide-to-nosql?utm_campaign=DevBlog&amp;utm_medium=blog&amp;utm_source=devblog&amp;utm_term=DevBlogPosts_CTA1_dbasguidetonosql\" target=\"_self\" class=\"dxAllButtons_v3Rad2_whiteNGrayOL\" title=\"dbas-guide-to-nosql\">DBA's Guide to NoSQL</a>\n</p><br class=\"clear\" /><div id=\"mto_newsletter_121316_Css\"><p>Subscribe for newsletter:</p><br /></div>"}}]}},"pageContext":{"alternative_id":9304}}