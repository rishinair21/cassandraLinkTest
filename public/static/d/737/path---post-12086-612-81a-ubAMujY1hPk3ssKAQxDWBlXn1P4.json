{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Apache Cassandra, Part 3: Row vs Column Stores","alternative_id":12086,"content":"<h3 id=\"02b5\" class=\"graf graf--h3 graf--leading\">Row vs Column Stores</h3><p id=\"a5d7\" class=\"graf graf--p graf-after--h3\">When talking about data stores it is helpful to keep this image in mind.</p><figure id=\"78ef\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"0*dIMjUEiFROJa2Ydr.\" data-width=\"555\" data-height=\"258\" data-is-featured=\"true\" src=\"https://cdn-images-1.medium.com/max/1600/0*dIMjUEiFROJa2Ydr.\" alt=\"image\" /></div></figure><p id=\"7dda\" class=\"graf graf--p graf-after--figure\">A disk read is an expensive operation and should be used in minimum to ensure performance of a data system. With this image in mind, let’s take data shown below as an example to look at various types of storage engines and see for what scenario each engine is optimized for.</p><figure id=\"4f1a\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"0*sVKPtbTUfy13CHtN.\" data-width=\"670\" data-height=\"306\" src=\"https://cdn-images-1.medium.com/max/1600/0*sVKPtbTUfy13CHtN.\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://en.wikipedia.org/wiki/Column-oriented_DBMS\" data-href=\"https://en.wikipedia.org/wiki/Column-oriented_DBMS\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener\" target=\"_blank\">https://en.wikipedia.org/wiki/Column-oriented_DBMS</a></figcaption></figure><p id=\"7f0e\" class=\"graf graf--p graf-after--figure\">Here we have data of employees, their ids, first and last names, and salaries.</p><h4 id=\"5b17\" class=\"graf graf--h4 graf-after--p\">Row Oriented Stores</h4><p id=\"eced\" class=\"graf graf--p graf-after--h4\">A row oriented store persists this data under the hood like this:</p><figure id=\"e8c9\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"0*bccSzBhLqv7Xdag8.\" data-width=\"488\" data-height=\"194\" src=\"https://cdn-images-1.medium.com/max/1600/0*bccSzBhLqv7Xdag8.\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://en.wikipedia.org/wiki/Column-oriented_DBMS\" data-href=\"https://en.wikipedia.org/wiki/Column-oriented_DBMS\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener\" target=\"_blank\">https://en.wikipedia.org/wiki/Column-oriented_DBMS</a></figcaption></figure><p id=\"c592\" class=\"graf graf--p graf-after--figure\">Interesting thing to note here is the column values that belongs to a single row are stored together. This makes it easy and cheap in terms of IO cost to read a single row. You go to desired row in a single disk seek, thanks to primary index, and find all the data in that row. Row oriented stores are efficient in scenarios where you need to access fewer rows and intend to use most of the data available in rows. This data access pattern is very common in OLTP systems, for example a university management, a banking portal, etc. But imagine if you need to find out median salary. For that you will have to scan the complete table and that will involve a lot of disk reads.</p><h4 id=\"2318\" class=\"graf graf--h4 graf-after--p\">Column Oriented Stores</h4><p id=\"ea57\" class=\"graf graf--p graf-after--h4\">A column oriented store would save the same information like this</p><figure id=\"a302\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"0*hcPyoCogQV82-68G.\" data-width=\"744\" data-height=\"180\" data-action=\"zoom\" data-action-value=\"0*hcPyoCogQV82-68G.\" src=\"https://cdn-images-1.medium.com/max/1600/0*hcPyoCogQV82-68G.\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://en.wikipedia.org/wiki/Column-oriented_DBMS\" data-href=\"https://en.wikipedia.org/wiki/Column-oriented_DBMS\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener\" target=\"_blank\">https://en.wikipedia.org/wiki/Column-oriented_DBMS</a></figcaption></figure><p id=\"eefe\" class=\"graf graf--p graf-after--figure\">Here, unlike a row store, all column values from a particular column are stored together. Now, if we want to calculate median salary, it will be very fast because it involves only one disk seek. But, if we want to get complete information of a particular employee, we will end up doing a lot of IO operations.</p><p id=\"7e2f\" class=\"graf graf--p graf-after--p\">In a column oriented store, number of values in each row should be same. This allows joining rows using index, which would be impossible to do if number of values are unequal. Column oriented stores are useful in OLAP scenarios where generally specific columns are of interest and queries are centered around these columns.</p><p id=\"a653\" class=\"graf graf--p graf-after--p\">Cassandra is neither a row oriented store nor it is a column oriented store, rather is is column family store. To understand how it is different from a row store, lets consider a scenario where we want to store temperature values. In a row based store we typically create a table temperatures with two columns (1) timestamp (2) value. On data insertion temperatures table will grow vertically. But in Cassandra, it can be a very valid design to store data like this:</p><figure id=\"98af\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"0*N_ZIad4Lno6A29Vs.\" data-width=\"912\" data-height=\"72\" data-action=\"zoom\" data-action-value=\"0*N_ZIad4Lno6A29Vs.\" src=\"https://cdn-images-1.medium.com/max/1600/0*N_ZIad4Lno6A29Vs.\" alt=\"image\" /></div></figure><p id=\"2973\" class=\"graf graf--p graf-after--figure\">Here every new entry is creating a new column. (Cassandra supports up to 2 Billion columns).</p><p id=\"e94e\" class=\"graf graf--p graf-after--p\">Now consider another example where we need to store various attributes of fruits. Following is a perfectly valid data model in Cassandra</p><figure id=\"ebf9\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"0*23NaTvtAEhU9hdg1.\" data-width=\"588\" data-height=\"170\" src=\"https://cdn-images-1.medium.com/max/1600/0*23NaTvtAEhU9hdg1.\" alt=\"image\" /></div></figure><p id=\"781b\" class=\"graf graf--p graf-after--figure\">But you cannot do this in a column oriented store because, recall, you have to have same number of columns for each row.</p><p id=\"dd0a\" class=\"graf graf--p graf-after--p\">Hence, Cassandra is neither a row oriented store, nor it is a column oriented store because it does things differently than both of those. But the question remains: if Cassandra is a column family store then what exactly does it mean and how is it different ? Hang on, I cover this in future posts but first you need to understand a few core concepts of Cassandra.</p><p id=\"c1b3\" class=\"graf graf--p graf-after--p graf--trailing\"><a href=\"https://blog.emumba.com/apache-cassandra-part-4-data-flow-and-key-concepts-4dea799a3531\" data-href=\"https://blog.emumba.com/apache-cassandra-part-4-data-flow-and-key-concepts-4dea799a3531\" class=\"markup--anchor markup--p-anchor\" target=\"_blank\">Next: Apache Cassandra, Part 4: Data Flow and Key Concepts</a></p>"}}]}},"pageContext":{"alternative_id":12086}}