{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Streaming Recommender with Spark","alternative_id":9062,"content":"<div id=\"article-header\"><div><div><p><time class=\"article-date\" datetime=\"2015-11-16T00:00:00+01:00\" pubdate=\"\">Mon 16 November 2015</time>Â - 6 min read</p></div></div><p>In this article, I explain how I implemented a distributed streaming article recommender with Apache Spark, also using Akka, RabbitMQ and Cassandra.</p><p>Category: <a href=\"https://www.madewithtea.com/category/spark.html\">Spark</a></p></div><p>In this article, I explain how I implemented a distributed streaming article recommender in <strong>Scala</strong> with <strong>Akka</strong>, <strong>RabbitMQ</strong>, <strong>Cassandra</strong> and <strong>Spark</strong>. If you dont know the technologies it is difficult to understand the following explainations. Therefore I <strong>recommend</strong> to read the introductions on the linked sites first.</p><p><a href=\"http://akka.io\">Akka</a> is a framework for highly concurrent, distributed, and resilient message-driven applications. <a href=\"https://www.rabbitmq.com/\">RabbitMQ</a> is a message broker. <a href=\"https://cassandra.apache.org/\">Cassandra</a> is a distributed NoSQL database providing high availability. Last but not least, <a href=\"https://spark.apache.org/\">Spark</a> is a framework for distributed computation which can run on scalable and high availability cluster managers like <a href=\"https://mesos.apache.org/\">Mesos</a>.  </p><p><strong>I try to keep the article as short but informative as possible</strong>. The article is quite long, <strong>so let me start with an outline</strong>: First, I will explain the setting and give some numbers. Second, I will explain why the initial monolithic design failed. Afterwards, I will describe the <strong>current service-oriented design</strong>, including the functionality of all involved components. Furthermore, I will go into the details of the <strong>model storage</strong> and <strong>fault tolerancy</strong> in the system in general. In the end, I will conclude and present possible future efforts for further improving the system.  </p><h3>Production System Facts</h3><p>The recommender will <strong>recommend articles based on their similarity score of features extracted from the full text</strong>, for instance <a href=\"https://code.google.com/p/word2vec/\">word2vec</a> word vectors. The current architecture is running successfully in a production environment with thousands of items distributed among isolated sets. Also, about 6000 of similarities are calcuated each second. The recommender calcuates the similarities of all possible article pairs. While this approach runs well in production, the design has to continously improve since it has to cope with <strong>increasing throughput of item create and delete events</strong>. Which also implies a changing model size.  </p><h3>Prototype</h3><p>In the company where I work, we are doing the transition to Spark-based recommenders, but <strong>when we started we had no experience so far with Spark</strong> nor <strong>experts of the field</strong> in the team. Even though, there is a great documentation of the project, still, <strong>best practices for certain use cases have not yet been formed</strong>. So I began with an <strong>explorative prototype</strong>, to understand how I could use Spark to scale the computation process of the similarity calculation. I started with a <strong>monolithic prototype</strong>, a standalone Spark streaming driver application.</p><h3>A Better Approach</h3><p>The main and innovative idea of Spark is to do distributed computation of a processing flow graph. Without going too much into the details, the driver coordinates the processing tasks which are parallized and balanced among different executors. Building a model and maintaining it (for instance doing I/O with a database) would be possible in the Spark driver, but it is a <strong>very bad idea to do so</strong> for the following reasons: </p><p>Blocking due to e.g. I/O in the driver, <strong>would block the whole streaming process for an undetermined time</strong>. Furthermore, one has to tune the memory limit of the driver <strong>not only based on the computation tasks</strong> but also <strong>according to the I/O usage</strong>. Because of these reasons I decided to use Spark Streaming just for its intended use, <strong>streaming computation</strong> and implement another service for <strong>model maintainance</strong>. </p><h3>Components</h3><p>The main components of the architecture are (1) the model service, which is a Scala service which is implemented using Akka and (2) the Spark driver application. The first component is the <strong>entry point of incoming item create and delete events</strong>. It also does preprocessing like <strong>stop word filtering, language detection</strong> and so on. Its <strong>core functionality is the management</strong> of the model stored in the Cassandra cluster. The Spark driver application receives processing tasks from the model service, does the distributed calculation in the cluster, and sends the results back to the model service.</p><p>The components communicate over the message broker <strong>RabbitMQ</strong>. I chose it, because it was part of the existing infrastructure. Besides, it has a nifty UI and also <strong>has support for message acknowledgement</strong>, which is useful for fault tolerancy in the model service. For the ingestion of item events into the system the log of <a href=\"https://kafka.apache.org/\">Kafka</a> would <strong>be very beneficial to replay item events to retrain the recommender with past item events</strong>. </p><h3>Functionality of the Model Service</h3><p>In the situation of incoming item create events, it will (1) group new item create events of a domain within a certain time window, (2) fetch feature data of all articles of this domain from Cassandra and (3) send the processing task with all required data to the Spark driver application. Keep in mind that the article recommendations are calculated in <strong>isolated domains</strong>, so <strong>we can parallelize step one, two and three on a domain level</strong>. </p><p>At the point of sending the task to the Spark driver, the model services sets this domain to a waiting state. <strong>It has to wait until the model is updated</strong> with new information, before it can send another task request. Keep in mind, that <strong>only this domain is blocked for the time</strong> between publishing and finishing updating the model.</p><h3>Functionality of the Spark Driver</h3><p>The Spark driver runs on a cluster and receives the computation tasks via RabbitMQ. In the concrete implementation it does <strong>feature extraction</strong> as well as the <strong>computation of similarities</strong> based on the features of new articles and features of existing articles in the model (which were fetched from Cassandra in the model service). The result is send back to the model service via RabbitMQ. </p><h3>Model Storage</h3><p>In this paragraph, I want to get into the details of the model storage. Since the storage is only use to store data, a simple key-value store like Redis would be sufficient. But it was clear, that <strong>this solution does not scale</strong> in the future or further work would be necessary. </p><p>So, at this point, I decided to use the <a href=\"http://www.planetcassandra.org/apache-cassandra-use-cases/\">widely-used</a> Cassandra database for a couple of reasons: (1) A Cassandra cluster scales with new nodes and data is distributed equally, when the definition of the data model is right. (2) Cassandra has been designed to allow fast writes, and reads with the help of built-in caching. (3) It supports synchronous and asynchronous (not waiting for Cassandra to accept) queries. Important to mention: Scalability comes with the downside of <a href=\"https://en.wikipedia.org/wiki/Eventual_consistency\">eventual consistency</a> and last but not least: (4) High availability of the Cassandra cluster nodes.  </p><h3>Fault Tolerancy</h3><p>The model service is built upon the Akka framework which is a <strong>huge help</strong> when developing fault-tolerant applications. Akka is a framework for distributed and fault-tolerant Actor systems. If you are not familiar with Akka or actor-based systems, I like to refer to the official <a href=\"http://doc.akka.io/docs/akka/2.4.0/intro/what-is-akka.html\">introduction</a>. </p><p>Akka handles unexpected errors in the following way: If an exception is thrown in an actor, the actor is simply restarted, which means it will loose its state. If this actor is stateless, the message will just be discarded and it will continue working. If there was a state, you should handle this unexpected behaviour with a custom failure protocol or an escalation to a severe exception that will halt the whole application; Of course, the latter should be avoided.</p><h3>Restart, Replication and Timeouts</h3><p><strong>As a last resort</strong>, the cluster manager, e.g. Mesos, will restart the model service, or the Spark driver. Furthermore, a <strong>replication of the model service and the Spark driver is possible to handle hardware outtages</strong>. In this case, multiple instances balance the load (sharded dependend on the domain).  </p><p>In the concrete implementation, I also added a duration supervisor which acts a timeout observer of computation tasks sent to the Spark driver. Consequently, an <strong>outtage of the Spark driver, will not result into a blocked state because the model service waits for the results</strong>.   </p><h3>Conclusion and Future Efforts</h3><p>As I stated in the beginning, I wanted to keep the article as short but informative as possible. <strong>I hope that this article gave you some insights of how a streaming recommender with Spark can be deployed</strong>. Needless to say, there is much room for improvement, for instance: </p><p>Since the model service can easily keep up with the throughput of item events and model data for now, there is no need for scaling this part of the architecture yet. Nevertheless, two options are possible: (1) Sharding model services dependend on the domain groups, or (2) scaling the instances of remote Akka actors across the cluster. Both options can be seen as possible future efforts. If you have questions regarding the implementation <strong>feel free to write me an email</strong>.  </p>"}}]}},"pageContext":{"alternative_id":9062}}