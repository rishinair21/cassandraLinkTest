{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cherami","alternative_id":4879,"content":"<p>Cherami is a distributed, scalable, durable, and highly available message queue system we developed at <a href=\"https://eng.uber.com/seattle-team-profile/\" target=\"_blank\">Uber Engineering</a> to transport asynchronous tasks. We named our task queue after a heroic carrier pigeon with the hope that this system would be just as resilient and fault-tolerant, allowing Uber’s mission-critical business logic components to depend on it for message delivery.</p>\n<div id=\"attachment_785\" class=\"wp-caption aligncenter\"><img class=\"wp-image-785\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/Cher_Ami_bw_cropped.jpg\" alt=\"cher_ami_bw_cropped\" width=\"213\" height=\"253\" srcset=\"https://eng.uber.com/wp-content/uploads/2016/11/Cher_Ami_bw_cropped.jpg 259w, https://eng.uber.com/wp-content/uploads/2016/11/Cher_Ami_bw_cropped-253x300.jpg 253w\" /><p class=\"wp-caption-text\"><a href=\"http://www.homeofheroes.com/wings/part1/c_cherami_display.jpg\" target=\"_blank\">Cher Ami</a> was a <a href=\"http://www.allempires.com/article/index.php?q=Unconventional_Animals_in_the_History_of_Warf\" target=\"_blank\">US Army carrier pigeon in World War I</a>. Despite being shot in the leg, she successfully delivered a message that <a href=\"https://en.wikipedia.org/wiki/Cher_Ami\" target=\"_blank\">helped save 194 lives</a>.</p></div>\n<h3>Introduction</h3>\n<p>A task queue decouples components in a distributed system and allows them to communicate in an asynchronous manner. The two communicating parties can then scale separately, with the added features of load smoothing or throttling. In complex distributed systems, a task queue is essential. Cherami fills a role equivalent to <a href=\"https://aws.amazon.com/sqs/\" target=\"_blank\">Simple Queue Service (SQS)</a> in Uber’s infrastructure ecosystem. Building our own system achieves better integration with our existing infrastructure while addressing some unique product development needs, like support for multiple consumer groups and increased availability, especially during network partition.</p>\n<p>Cherami’s users are defined as either <i>producers </i>or<i> consumers</i>. <i>Producers</i> enqueue tasks. <i>Consumers</i> are worker processes that asynchronously pick up and process enqueued tasks. Cherami’s delivery model is the typical <a href=\"https://msdn.microsoft.com/en-us/library/dn568101.aspx\" target=\"_blank\">Competing Consumers</a> pattern, where consumers in the same consumer group receive disjoint sets of tasks (except in failure cases, which cause redelivery). Using this model, work fans out to many workers in parallel. The number of workers is independent of any partitioning or sharding mechanisms internal to Cherami and can scale up and down simply by adding or removing workers. If a worker fails to perform a task, another worker can redeliver and retry the task.</p>\n<p>Cherami also supports multiple consumer groups, where each consumer group receives all tasks in the queue. Each consumer group is associated with a <a href=\"https://en.wikipedia.org/wiki/Dead_letter_queue\" target=\"_blank\">dead letter queue</a>. Tasks that exceed the maximum retry count (for example, “poison pills”) land in this queue so that the consumer group can continue processing other messages. These consumer handling features both distinguish Cherami from the simple message buses that are typically used in big data ingestion and analytics (e.g. <a href=\"https://kafka.apache.org/\" target=\"_blank\">Apache Kafka</a>), and make Cherami advantageous in task queue use cases.</p>\n<div id=\"attachment_790\" class=\"wp-caption aligncenter\"><img class=\"wp-image-790\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_1.png\" width=\"600\" height=\"406\" srcset=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_1.png 612w, https://eng.uber.com/wp-content/uploads/2016/11/Cherami_1-300x203.png 300w\" alt=\"image\" /><p class=\"wp-caption-text\">Producers enqueue tasks into queues A and B. Queue A feeds to two consumers groups that both receive all tasks, distributed across consumers within the respective group. Queue B feeds to only one consumer group.</p></div>\n<p>Prior to Cherami, Uber used <a href=\"http://www.celeryproject.org/\" target=\"_blank\">Celery</a> queues backed by <a href=\"http://redis.io/\" target=\"_blank\">Redis</a> for all task-queue use-cases. The combo of Celery and Redis helped Uber scale quickly, up to a point. The drawbacks? Celery is Python-only, while we were increasingly relying on Go and Java to build higher performance backend services. Furthermore, Redis stores are memory-backed, which isn’t as durable or scalable as we needed. </p>\n<p>We needed a longer-term solution for Uber’s future, so we built Cherami to satisfy these requirements:</p>\n<ol><li>Durability, losslessness, and tolerance of hardware failures</li>\n<li>Flexibility between <a href=\"https://en.wikipedia.org/wiki/CAP_theorem\" target=\"_blank\">availability and consistency (AP vs CP)</a> during network partition</li>\n<li>Ability to scale the throughput of each queue up and down easily </li>\n<li>Complete support for the competing-consumers consumption model</li>\n<li>Language agnostic</li>\n</ol><p>To satisfy those requirements, Cherami’s design follows these design principles:</p>\n<ol><li>We choose eventual consistency as a core principle. This allows high availability and durability, with the tradeoff that we don’t provide ordering guarantees. However, that means that we can continue accepting requests during catastrophic failures or network partitions, and further improves availability by eliminating the need for a consistent metadata storage like <a href=\"http://zookeeper.apache.org/\" target=\"_blank\">Zookeeper</a>.</li>\n<li>We chose not to support the partitioned consumer pattern, and we don’t expose partitions to the user. This simplifies consumer worker management, as workers don’t need to coordinate which partition to consume from. It also simplifies provisioning, since both producers and consumers can scale independently.</li>\n</ol><p>In the following sections, we further elaborate on key design elements of Cherami and explain how we applied the design principles and tradeoffs.</p>\n<h3>Cherami’s Key Design Elements</h3>\n<h4>1. Failure recovery and replication</h4>\n<p>To be truly lossless and available, Cherami must tolerate hardware failures. In practice, this requires Cherami to replicate each message across different hardware so that messages can reliably be read, but Cherami must also be able to accept new messages when hardware fails either transiently or permanently.</p>\n<p>Cherami’s fault tolerance comes from leveraging the append-only property of messaging systems and using pipelining in message transfers. Each message in a message queue is a self-contained element that, once created, is never modified. In other words, message queues are append-only. If the storage host containing the queue fails, we can pick a different storage host and continue writing to it. The enqueue operation continues to be available.</p>\n<div id=\"attachment_791\" class=\"wp-caption aligncenter\"><img class=\"wp-image-791\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_1.gif\" width=\"600\" height=\"338\" alt=\"image\" /><p class=\"wp-caption-text\">The append-only property allows a queue to remain available for publishing during hardware failure.</p></div>\n<p>A Cherami queue consists of one or more <i>extents</i>, which are conceptual substreams within a queue that independently support appending messages. Extents are replicated to the storage layer by a role called <i>input host</i>. When an extent is created, its metadata contains an immutable host information tuple (input host and list of storage hosts). In each storage host, the replicated copy of the extent is called a <i>replica</i>, and a storage host can host many replicas of different extents. If a single storage host fails, we don’t lose messages because the extent is still readable from other replicas.</p>\n<div id=\"attachment_792\" class=\"wp-caption aligncenter\"><img class=\"wp-image-792\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_2.gif\" width=\"600\" height=\"338\" alt=\"image\" /><p class=\"wp-caption-text\">Cherami handles a storage host failure.</p></div>\n<p>Producers connect to the specific input host to publish to an extent belonging to some queue. Upon receiving messages from a producer, the input host <i>simultaneously</i> pipelines the messages into all extent replicas through a <a href=\"https://en.wikipedia.org/wiki/WebSocket\" target=\"_blank\">WebSocket</a> connection, and receives acknowledgements (<em>acks</em>) from the respective replicas in the same connection. </p>\n<p>Pipelining means the input host does not wait for an ack before writing the next message, and that there is no message reordering or message skipping between the input host and all replicas. This also applies to the acks that return from each replica; acks come in the order of corresponding writes. The input host tracks all acks. Only when all storage hosts ack receipt of the same message are received does the input host ack to the producer. This final ack implies that the message has been durably stored in all replicas.</p>\n<p>Within each extent, messages are ordered due to the pipelining property. This ensures messages across all replicas are consistent, except for the tails where a storage host has yet to persist the messages.</p>\n<div id=\"attachment_793\" class=\"wp-caption aligncenter\"><img class=\"wp-image-793\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_2.png\" width=\"600\" height=\"360\" srcset=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_2.png 630w, https://eng.uber.com/wp-content/uploads/2016/11/Cherami_2-300x180.png 300w\" alt=\"image\" /><p class=\"wp-caption-text\">Input host only receives acks for the first three messages from all storage hosts. It acks the first three messages to the producer, as those messages are guaranteed to be fully replicated.</p></div>\n<p>When any replica fails, the input host cannot receive acks from that replica for any further writes. Thus, this extent is no longer appendable. If the input host fails, we would lose the inflight acks from the storage hosts. In both cases, the tails of the replicas can be inconsistent: one or more messages are not replicated in all replicas. To recover from this inconsistency, instead of trying to scan and repair the tails, which is a complicated operation, we simply declare this extent “sealed” as-is; it’s readable, but no more writes are allowed.</p>\n<p>After sealing, Cherami creates a new extent for this queue, and a signaling channel notifies producers to reconnect and publish into the new extent. If a queue consists of only one open extent, sealing it would make the queue temporarily unavailable to publish for a short period of time before a new extent is created. To avoid publish latency spikes during failures, a queue normally sets a minimum number of extents so that publish can continue when one extent is being sealed and a new one created.</p>\n<p>We choose to use sealing as a recovery mechanism because it is simple to implement. The tradeoff here is that duplicates can occur. The reason for the duplicates is that after a failure, the replica tails will contain messages not acked to the publisher, and it is not possible to determine which messages are unacked, if the input host has failed. Thus, in the read path, we will have to deliver everything, including these unacked messages. Publishers generally retry when failed to enqueue a message, so some of these messages may be republished in a new extent, which causes consumers to receive duplicates.</p>\n<h4>2. Scaling of Writes</h4>\n<p>Extents within Cherami are shared-nothing substreams. Cherami observes the throughput on each extent. As write load to a particular queue increases and some extents exceed their throughput limit, Cherami creates additional extents for that queue automatically. The new extents receive part of the write load, alleviating the load on existing extents.</p>\n<p><img class=\"wp-image-794\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_3.gif\" width=\"600\" height=\"338\" alt=\"image\" /></p>\n<p>As write load decreases, Cherami seals some of the extents without replacing them with new ones. In this way Cherami reduces some overhead (memory, network connections, and other maintenance) required to maintain an open extent.</p>\n<p><img class=\"wp-image-795\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/autoscaling_up_and_down.png\" alt=\"autoscaling_up_and_down\" width=\"600\" height=\"338\" srcset=\"https://eng.uber.com/wp-content/uploads/2016/11/autoscaling_up_and_down.png 720w, https://eng.uber.com/wp-content/uploads/2016/11/autoscaling_up_and_down-300x169.png 300w\" /></p>\n<h4>3. Consumption handling</h4>\n<p>Consumers in the same consumer group receive tasks from the same queue, but may receive from one or more extents. When a consumer receives a message and successfully processes it, the consumer replies to Cherami with an ack. If Cherami doesn’t get an ack after some configured amount of time, it redelivers the message to retry. A consumer’s ack can be delayed or missing  when a consumer crashes, when a downstream dependency is unavailable, when a single task takes too long, or when processing gets stuck because of a deadlock. A consumer can also negatively acknowledge, or <i>nack</i>, a message, triggering immediate redelivery. Nacks allow consumer groups to process tasks that some members are incapable of processing (e.g. because of local failures, partial/rolling upgrade of a consumer group to a new task schema).</p>\n<p>Because different consumers can take varied amount of time to process messages, acks arrive at Cherami in a different order than the ordering provided by the replicas. Some messaging systems store the read/unread state (also known as the visibility state) per message. However, to do that we would need to update these states on disk (with random writes) and handle the complexity of doing this for each of multiple consumer groups. </p>\n<p>Cherami takes a different approach. In each consumer group, for each extent, we maintain an <i>ack offset</i>, which is a message sequence number below which all messages have been acked. We have a role called <i>output host</i> that consumers connect to in order to receive deliveries. The output host reads messages from storage hosts sequentially, keeping them cached in memory. It keeps tracks of in-flight messages (delivered to consumer, but not yet acked) and updates the ack offset when possible. Output host also keeps track of timing and nacks so that messages can be redelivered to another consumer as necessary. In Cherami, one extent can be consumed simultaneously by multiple consumer groups, so multiple output hosts might read from the same extent.</p>\n<div id=\"attachment_796\" class=\"wp-caption aligncenter\"><img class=\"wp-image-796\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_4.gif\" alt=\"cherami_4\" width=\"600\" height=\"338\" /><p class=\"wp-caption-text\">Output host handles out-of-order acks from workers.</p></div>\n<p>Further, the system is configured to redeliver each message a limited number of times. If the redelivery limit is reached, the message is published to a <a href=\"https://en.wikipedia.org/wiki/Dead_letter_queue\" target=\"_blank\">dead letter queue</a> and the message is marked as acked so that the ack offset can advance. This way, no “poison pill” messages block the processing of other messages in the queue. The consumer group owner can manually examine messages in the DLQ, and then handle them in one of two ways: purging them or merging them. Purging them deletes the messages, and is appropriate when they are invalid, or if the have no value (e.g. they were time-sensitive). The owner can otherwise merge them back to the consumer group, which is appropriate when the consumer software has been fixed to handle the messages that previously could not be handled, or when the transient failure condition has subsided.</p>\n<h4>4. Storage</h4>\n<p>Messages in Cherami are durably stored on disks. On the storage hosts, we chose <a href=\"http://rocksdb.org/\" target=\"_blank\">RocksDB</a> as our storage engine for performance and indexing features, and we use a separate RocksDB instance per extent with a shared <a href=\"https://en.wikipedia.org/wiki/Cache_Replacement_Policies\" target=\"_blank\">LRU</a> block cache. Messages are stored in the database with an increasing sequence number as the key, and the message itself as the value. Because the keys are always increasing, RocksDB optimizes its compaction so that we don’t suffer from write amplification. When <i>output host</i> reads messages from an extent, it simply seeks to the <i>ack offset</i> for the consumer group it’s serving, and iterates by the sequence number to read further messages.</p>\n<p>With RocksDB, we can also easily implement timer queues, which are queues where each message is associated with a delay time. In such a case, the message is only delivered after the specified delay. For timer queues, we construct the key to contain the delivery time in high order bits, and sequence number in low order bits. Since RocksDB provides a sorted iterator, the keys are iterated in order of delivery time, while the sequence number of the lower bits ensures uniqueness of the keys:</p>\n<p><img class=\"wp-image-797 aligncenter\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_5.gif\" alt=\"cherami_5\" width=\"600\" height=\"338\" /></p>\n<h3>System Architecture</h3>\n<p>Cherami consists of several different roles. In addition to the input, storage, and output roles we already introduced, there’s <i>controller</i>, and <i>frontend</i>. A typical Cherami deployment consists of several instances of each role:</p>\n<div id=\"attachment_798\" class=\"wp-caption aligncenter\"><img class=\"wp-image-798\" src=\"https://eng.uber.com/wp-content/uploads/2016/11/Cherami_6.gif\" width=\"600\" height=\"338\" alt=\"image\" /><p class=\"wp-caption-text\">Interaction of Cherami’s system components.</p></div>\n<p>Different roles can exist on the same physical host or even be linked into a single binary. At Uber, each role runs in an individual Docker container. Input, storage, and output form the data plane of the system. Controller and frontend handle control plane functions and metadata operations.</p>\n<h4>Controller</h4>\n<p>Controller is the grand coordinator, the intelligence that coordinates all of the other components. It primarily determines when to create and where to place (to which input and which storage hosts) an extent. It also determines which output hosts handle the consumption for a consumer group.</p>\n<p>All data plane roles report load information to Controller via RPC calls. With this information, controller makes the placement decision and balance load. There are several instances of this controller role, one of them weakly elected the leader using Uber’s <a href=\"https://eng.uber.com/intro-to-ringpop/\" target=\"_blank\">Ringpop</a> library for gossip and consistent hashing. Ringpop also performs distributed health check and membership functions.</p>\n<h4>Frontend</h4>\n<p>Frontend hosts expose <a href=\"https://github.com/uber/tchannel\" target=\"_blank\">TChannel</a>–<a href=\"https://thrift.apache.org/\" target=\"_blank\">Thrift</a> APIs that perform <a href=\"https://en.wikipedia.org/wiki/Create,_read,_update_and_delete\" target=\"_blank\">CRUD</a> operations of queues and consumer groups. They also expose APIs for data plane routing purposes. When a producer wants to publish messages into a queue, it invokes the routing API to discover which input hosts contain the extents of the queue. Next, the producer connects to those input hosts using WebSocket connections and publishes messages in the established streams.</p>\n<p>Similarly, when a consumer wants to consume messages from a queue, it first invokes the routing API to discover which output hosts manage the consumption of extents of the queue. Then, the producer connects to those output hosts using WebSocket connections and pulls messages. When new extents are created, Cherami sends back a notification to the producer and consumer so that they can connect to new extents. We developed client-side libraries to simplify these interactions.</p>\n<h4>Cassandra and Queueing</h4>\n<p>Finally, Cherami stores metadata on <a href=\"http://cassandra.apache.org/\" target=\"_blank\">Cassandra</a>, which is separately deployed. Metadata contains information about a queue, all its Extents, and all the Consumer Group information such as ACK offsets per Extent per Consumer Group. We chose Cassandra not only because Cassandra is a highly available data storage system, but also because of its tunable consistency model. Such flexibility allows us to offer queues that can be either partition tolerant while not order preserving (AP queues), or order preserving (CP queues) but not available in the minor partition during such a partition event. The main difference in the handling of two types of queues is whether Extent creation requires conditional update operation.</p>\n<h4>AP Queues</h4>\n<p>For AP queues, extent creation does not need Quorum-level consistency in Cassandra. When a network partition occurs, Extents can be created on both sides of the partition. Let’s call the partitions A and B. Producers in Partition A can publish into Extents in that partition, and Producers in Partition B can publish into Extents in Partition B. Therefore, writes are not blocked by network partition. For reads, Consumers in Partition A can only consume from Extents in that partition, and similar for Consumers in Partition B. However, when the network partition heals, Consumers are able to reach all Extents. The tradeoff here is that messages are eventually-consistent: it is not possible to establish a global ordering of messages because Extents can be created anytime, anywhere. In our implementation, we use Cassandra consistency level “ONE” when we write the Extent metadata.</p>\n<h4>CP Queues</h4>\n<p>For CP queues, Extent creation needs to be linearizable: in the case of a network partition, we must make sure that only one partition can create an Extent to succeed the previously sealed one. To ensure this, we use Cassandra’s lightweight transaction so that if at the same time more than one Extent is created for any reason, only one can be used for a CP queue.</p>\n<h3>Cherami, Summarized</h3>\n<p>Cherami is a competing-consumer messaging queue that is durable, fault-tolerant, highly available and scalable. We achieve durability and fault-tolerance by replicating messages across storage hosts, and high availability by leveraging the append-only property of messaging queues and choosing eventual consistency as our basic model. Cherami is also scalable, as the design does not have single bottleneck. </p>\n<p>Cherami was designed and built from the ground up in about six months in our <a href=\"https://www.uber.com/careers/list/?city=seattle&amp;country=united-states-of-america&amp;keywords=&amp;subteam=all&amp;team=engineering\" target=\"_blank\">Seattle engineering office</a>. Currently, Cherami transports many hundred millions of tasks durably per day among Uber Engineering’s <a href=\"https://eng.uber.com/building-tincup/\" target=\"_blank\">many microservices</a>, helping use cases such as post-trip processing, fraud detection, user notification, incentive campaigns, and many other use cases. </p>\n<p>Cherami is completely <a href=\"https://golang.org/\" target=\"_blank\">written in Go</a>, a language that makes building highly performant and concurrent system software a lot of fun. Additionally, Cherami uses several libraries that Uber has already open sourced: <a href=\"https://github.com/uber/tchannel-go/\" target=\"_blank\">TChannel</a> for RPC and <a href=\"https://github.com/uber/ringpop-go\" target=\"_blank\">Ringpop</a> for health checking and group membership. Cherami depends on several third-party open source technologies: <a href=\"http://cassandra.apache.org/\" target=\"_blank\">Cassandra</a> for metadata storage, RocksDB for message storage, and many other third-party Go packages that are available on GitHub. We plan to <a href=\"http://uber.github.io/\" target=\"_blank\">open source</a> Cherami in the near future.</p>\n<p><strong>Editor Update January 3 2017:</strong> Cherami is now open sourced at the following links: <strong><a href=\"https://github.com/uber/cherami-server\" target=\"_blank\" data-saferedirecturl=\"https://www.google.com/url?hl=en&amp;q=http://github.com/uber/cherami-server&amp;source=gmail&amp;ust=1483552631981000&amp;usg=AFQjCNGJ4_Z0oQWCl9c0X6Np8BtPECaz5g\">github.com/uber/cherami-server</a></strong> &amp; <strong><a href=\"https://github.com/uber/cherami-client-go\" target=\"_blank\">github.com/uber/cherami-client-go</a></strong>.</p>\n<p><i>Xu Ning is an </i><a href=\"https://www.uber.com/careers/list/?city=seattle&amp;country=united-states-of-america&amp;keywords=engineering+manager&amp;subteam=all&amp;team=engineering\" target=\"_blank\"><i>engineering manager</i></a><i> and co-wrote this article with Maxim Fateev, a staff </i><a href=\"https://www.uber.com/careers/list/?city=seattle&amp;country=united-states-of-america&amp;keywords=software+engineer&amp;subteam=all&amp;team=engineering\" target=\"_blank\"><i>software engineer</i></a><i>. Both are based in </i><a href=\"https://eng.uber.com/seattle-team-profile/\" target=\"_blank\"><i>Uber’s Seattle engineering office</i></a><i>.</i></p>\n<p><i>Photo Credits for Header: “</i><a href=\"https://www.flickr.com/photos/amigomac/5069325296/\"><i>Paloma</i></a><i>” by </i><a href=\"https://www.flickr.com/photos/amigomac/\" target=\"_blank\"><i>Pablo Ibañez</i></a><i>, licensed under </i><a href=\"https://creativecommons.org/licenses/by/2.0/\" target=\"_blank\"><i>CC-BY 2.0</i></a><i>. Image cropped for header dimensions and color corrected.</i></p>\n<p><i>Photo Credits for intro pigeon image: </i><a href=\"https://commons.wikimedia.org/wiki/File:Cher_Ami_cropped.jpg\" target=\"_blank\"><i>United States Signal Corps</i></a><i> via </i><a href=\"http://historywired.si.edu/enlarge.cfm?ID=522&amp;ShowEnlargement=1\" target=\"_blank\"><i>Smithsonian Institution</i></a><i>, public domain.</i></p>\n                                      <div style=\"text-align: center;\">\n                                    \n                  <h6>0 Comments</h6> \n</div>"}}]}},"pageContext":{"alternative_id":4879}}