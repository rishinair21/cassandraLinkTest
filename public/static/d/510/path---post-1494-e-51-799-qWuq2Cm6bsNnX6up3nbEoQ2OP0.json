{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Common Problems with Cassandra Tombstones","alternative_id":1494,"content":"<p>If there is one thing to understand about Cassandra, it is the fact that it is optimised for writes. In Cassandra everything is a write including logical deletion of data which results in tombstones – special deletion records. We have noticed that lack of understanding of tombstones is often the root cause of production issues our clients experience with Cassandra. We have decided to share a compilation of the most common problems with Cassandra tombstones and some practical advice on solving them.</p><p>Tombstones are a mechanism which allows Cassandra to write fast but it has an operational price to pay. First of all, tombstones are themselves records. They take up space and can substantially increase the amount of storage you require. Secondly, querying tables with a large number of tombstones causes performance problems explained below.</p>\n<h2>Large Number of Tombstones Causes Latency and Heap Pressure</h2>\n<p>The <code>cassandra.yaml</code> comments explain in perfectly: <em>“When executing a scan, within or across a partition, we need to keep the tombstones seen in memory so we can return them to the coordinator, which will use them to make sure other replicas also know about the deleted rows. With workloads that generate a lot of tombstones, this can cause performance problems and even exhaust the server heap.”</em></p>\n<p>For illustration purposes consider the following table with a composite partition key of 2 columns, 2 clustering columns and 2 text columns:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"11\"><div class=\"sql\" readability=\"19\"><pre class=\"de1\">CREATE TABLE sandbox.row_tests (\n\tfirst_key INT,\n\tsecond_key INT,\n\tfirst_cc INT,\n\tsecond_cc INT,\n\treal_col_1 text,\n\treal_col_2 text,\n\tPRIMARY KEY ((first_key, second_key), first_cc, second_cc)) \nWITH CLUSTERING ORDER BY (first_cc ASC, second_cc ASC);</pre></div></div></div></div></div></div></div>\n<p>A row with all values set in JSON representation is as follows:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"10\"><div class=\"javascript\" readability=\"16\"><pre class=\"de1\">{\"key\": \"499646:499646\",\n \"cells\": [[\"499646:499646:\",\"\",1471333048921002],\n           [\"499646:499646:real_col_1\",\"test_value_1\",1471333048921002],\n           [\"499646:499646:real_col_2\",\"test_value_2\",1471333048921002]]}</pre></div></div></div></div></div></div></div>\n<p>If you delete <code>real_col_1</code>, the row will have a server timestamp, client timestamp and <code>“d”</code> flag which marks the column deleted:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"10\"><div class=\"sql\" readability=\"17\"><pre class=\"de1\">{\"key\": \"499646:499646\",\n \"cells\": [[\"499646:499646:\",\"\",1471333933922005],\n           [\"499646:499646:real_col_1\",1471333933,1471333933922005,\"d\"],\n           [\"499646:499646:real_col_2\",\"test_value_2\",1471333933922005]]}</pre></div></div></div></div></div></div></div>\n<p>If you delete the entire row, the tombstone will be as follows:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"7\"><div class=\"sql\" readability=\"10\"><pre class=\"de1\">[\n{\"key\": \"499646:499646\",\n \"metadata\": {\"deletionInfo\": {\"markedForDeleteAt\":1471335025231530,\"localDeletionTime\":1471335025}},\n \"cells\": []}\n]</pre></div></div></div></div></div></div></div>\n<p>This gives you a rough estimate of how much extra data Cassandra loads into memory when reading tombstones along the way on executing a query. For a simple single partition query consider roughly a 1.5ms penalty for every 1000 tombstones encountered (performance may vary).</p>\n<h2>“How do we get tombstones without deleting anything?”</h2>\n<p>One common misconception is that tombstones only appear when the client issues <code>DELETE</code> statements to Cassandra. Some developers assume that it is safe to choose a way of operations which relies on Cassandra being completely tombstone free. In reality there are other many other things causing tombstones apart from issuing <code>DELETE</code> statements. Inserting <code>null</code> values, inserting collections and expiring data using <a href=\"http://docs.datastax.com/en/cql/3.3/cql/cql_using/useExpire.html\" target=\"_blank\">TTL</a> are common sources of tombstones. There is also a type of tombstones currently invisible to Cassandra tools and metrics – column range tombstones, so you may actually have a tombstone problem without realising you have tombstones at all.</p>\n<h3>Inserting null values</h3>\n<p>It is worth repeating that Cassandra is optimised for fast writes: it will not read data to check a condition before writing – that would slow writes down (<a href=\"http://docs.datastax.com/en/cql/3.3/cql/cql_using/useInsertLWT.html\" target=\"_blank\">Lightweight Transactions</a> are one exception – they will read before writing at a cost of a 4x latency). As a result, even if the first value you ever write to a column is <code>null</code>, Cassandra will not check to see if that value already exists; it will simply mark the column with a tombstone for deletion. The statement below will result in a tombstone for <code>value_2</code> even if it is the first insertion for <code>key=1</code>. The tombstone is highlighted in the JSON representation:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"7\"><div class=\"sql\" readability=\"10\"><pre class=\"de1\">INSERT INTO a_table (KEY, value_1, value_2) VALUES (1, 'some_value', NULL);</pre></div></div></div></div></div></div></div>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"10\"><div class=\"javascript\" readability=\"17\"><pre class=\"de1\">[\n{\"key\": \"1\",\n \"cells\": [[\"\",\"\",1470836653466124],\n           [\"value_1\",\"some_value\",1470836653466124],\n           [\"value_2\",1470836653,1470836653466124,\"d\"]]}\n]</pre></div></div></div></div></div></div></div>\n<p>To avoid this, do not insert <code>null</code> values, use unset columns instead. In the previous example, we can leave <code>col_2</code> <strong>unset</strong> instead of setting it to <code>null</code> in CQL. This is allowed as long as <code>col_2</code> is not part of the primary key.</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"6\"><div class=\"sql\" readability=\"8\"><pre class=\"de1\">INSERT INTO a_table (KEY, col_1) VALUES (1, 'some_value');</pre></div></div></div></div></div></div></div>\n<p>When using the Java driver, you can either omit the column name you are not setting when issuing an <code>INSERT</code> or <code>UPDATE</code> statement or use the <code>unset()</code> method (<a href=\"https://datastax.github.io/java-driver/manual/statements/prepared/\" target=\"_blank\">see documentation</a>) on bound statements to explicitly alter it:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"8\"><div class=\"java\" readability=\"11\"><pre class=\"de1\">PreparedStatement statement = session.prepare(\"INSERT INTO sandbox.a_table (key, col_2) values (?,?)\");\n \nBoundStatement bs = statement.bind(1, \"test_value_1\", \"test_value_2\");\nbs.unset(\"col_1\");</pre></div></div></div></div></div></div></div>\n<h3>Inserting values into collection columns</h3>\n<p>Using Cassandra collections inevitably results in tombstones even if you never delete a value. Again, this is the result of Cassandra being optimised for writes. Consider the following table with list, set and map columns:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"8\"><div class=\"sql\" readability=\"11\"><pre class=\"de1\">CREATE TABLE collection_table( \n\tKEY INT PRIMARY KEY, \n\tcol_1 list, \n\tcol_2 SET, \n\tcol_3 map&amp;lt;INT, text&amp;gt;\n);</pre></div></div></div></div></div></div></div>\n<p>When you insert the first row into this table with collection values set you will see three tombstones recorded in an SSTable for <code>collection_table</code>:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"10\"><div class=\"sql\" readability=\"16\"><pre class=\"de1\">INSERT INTO collection_table(KEY, col_1, col_2, col_3) \nVALUES \n(1, ['one', 'two'], {'three', 'four'}, {5 : 'five', 6 : 'six'});</pre></div></div></div></div></div></div></div>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"23\"><div class=\"javascript\" readability=\"45\"><pre class=\"de1\">[\n{\"key\": \"1\",\n \"cells\": [[\"\",\"\",1471340404406403],\n           [\"col_1:_\",\"col_1:!\",1471340404406402,\"t\",1471340404],\n           [\"col_1:68fd3380639511e6ae93f196435f2a32\",\"6f6e65\",1471340404406403],\n           [\"col_1:68fd3381639511e6ae93f196435f2a32\",\"74776f\",1471340404406403],\n           [\"col_2:_\",\"col_2:!\",1471340404406402,\"t\",1471340404],\n           [\"col_2:666f7572\",\"\",1471340404406403],\n           [\"col_2:7468726565\",\"\",1471340404406403],\n           [\"col_3:_\",\"col_3:!\",1471340404406402,\"t\",1471340404],\n           [\"col_3:00000005\",\"66697665\",1471340404406403],\n           [\"col_3:00000006\",\"736978\",1471340404406403]]}\n]</pre></div></div></div></div></div></div></div>\n<p>Cassandra optimises for writes and does not check if the list has changed (or even existed), instead, it immediately deletes its before inserting the new one. Be aware of this when choosing to use collections as column types.</p>\n<h3>Expiring Data with TTL</h3>\n<p>Expiring data by setting a <a href=\"http://docs.datastax.com/en/cql/3.3/cql/cql_using/useExpire.html\" target=\"_blank\">TTL (Time To Live)</a> is one an alternative to deleting data explicitly but technically results in the same tombstones recorded by Cassandra and requiring the same level of attention as other types of tombstones.</p>\n<h3>The Invisible Column Range Tombstones</h3>\n<p>Issuing an explicit delete statement for a range of rows will result in a <em>column range tombstone</em>. Consider the following table:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"8\"><div class=\"sql\" readability=\"11\"><pre class=\"de1\">CREATE TABLE sandbox.range_tests (\n    KEY INT,\n    c_column INT,\n    VALUE text,\n    PRIMARY KEY (KEY, c_column)\n) WITH CLUSTERING ORDER BY (c_column ASC);</pre></div></div></div></div></div></div></div>\n<p>Even with no data present, issuing the following delete statement will result in a corresponding range tombstone.</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"5\"><div class=\"sql\" readability=\"6\"><pre class=\"de1\">DELETE FROM range_tests WHERE KEY=1 AND c_column=2;</pre></div></div></div></div></div></div></div>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"8\"><div class=\"javascript\" readability=\"11\"><pre class=\"de1\">[\n{\"key\": \"1\",\n \"cells\": [[\"2:_\",\"2:!\",1471890568707244,\"t\",1471890568]]}\n]</pre></div></div></div></div></div></div></div>\n<p>This is a normal column range tombstone whose format tells you that a whole collection for partition key 1 and clustering column 2 has been deleted. The problem with tombstones like this is that they are not accounted for in Cassandra metrics or diagnostic tools. The will not contribute to the number of tombstones in a <a href=\"https://docs.datastax.com/en/cql/3.3/cql/cql_reference/tracing_r.html\" target=\"_blank\">tracing</a> summary or average numbers of tombstones in <a href=\"https://docs.datastax.com/en/cassandra/3.x/cassandra/tools/toolsTablestats.html\" target=\"_blank\">nodetool tablestats</a>. At the time of this writing it is a known problem and a <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-11166\" target=\"_blank\">ticket is raised for this in Cassandra JIRA</a>. For example, selecting by <code>key 1</code> and <code>c_column 2</code> with tracing enabled will not report any tombstones encountered even though we <strong>know</strong> there is one. Note that tombstone warning / failure alerts set in <code>cassandra.yaml</code> will not detect column range tombstones either; this is also a <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-8527\" target=\"_blank\">known issue</a>. For example, see the following tracing output:</p>\n<div id=\"attachment_28867\" class=\"wp-caption aligncenter\"><img src=\"https://opencredo.com/wp-content/uploads/2016/09/Screen-Shot-2016-09-27-at-13.51.42-1200x337.png\" alt=\"Cassandra Tracing\" width=\"800\" height=\"337\"/><p class=\"wp-caption-text\">Query Tracing</p></div>\n<p>Even though column range tombstones are not currently logged or reported in Cassandra, they have exactly the same implications as other types of tombstones and should be avoided where possible. We suggest using the following tools and approaches to detect problems caused by tombstones.</p>\n<h2>Look into “Raw” SSTable Content for Answers</h2>\n<p>When uncertain about performance issues and suspecting tombstones or not knowing what generates tombstones, a good starting point is to inspect the contents of SSTables for the offending table. Use <a href=\"https://docs.datastax.com/en/cassandra/2.2/cassandra/tools/toolsSSTable2Json.html\" target=\"_blank\">sstable2json</a> (Cassandra &lt; 3.0) or <a href=\"https://docs.datastax.com/en/cassandra/3.0/cassandra/tools/ToolsSSTabledump.html\" target=\"_blank\">sstabledump</a> (Cassandra &gt;= 3.0) to dump a JSON representation of an SSTable to console or file. For example:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"6\"><div class=\"bash\" readability=\"7\"><pre class=\"de1\">tools/bin/sstable2json data/data/sandbox/a_table-f79f7890639111e6ae93f196435f2a32/lb-1-big-Data.db &amp;gt; ~/Documents/a_table.txt</pre></div></div></div></div></div></div></div>\n<p>This is especially useful for distinguishing between <code>null</code> values for columns and columns which haven’t been set. For example, consider the following insert statements:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"7\"><div class=\"sql\" readability=\"10\"><pre class=\"de1\">INSERT INTO a_table(KEY, col_1, col_2) VALUES (444, 'some_value', NULL);</pre></div></div></div></div></div></div></div>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"6\"><div class=\"sql\" readability=\"8\"><pre class=\"de1\">INSERT INTO a_table(KEY, col_1) VALUES (555, 'some_value');</pre></div></div></div></div></div></div></div>\n<p>Statement 1 <strong>will</strong> generate a tombstone for <code>col_2</code>, statement 2 <strong>will not</strong>, it will not create column <code>col_2</code> for key 555 at all. You can see it in the JSON representation of the SSTable:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"14\"><div class=\"javascript\" readability=\"25\"><pre class=\"de1\">[\n{\"key\": \"444\",\n \"cells\": [[\"\",\"\",1471347746607634],\n           [\"col_1\",\"some_value\",1471347746607634],\n           [\"col_2\",1471347746,1471347746607634,\"d\"]]},\n{\"key\": \"555\",\n \"cells\": [[\"\",\"\",1471347765127626],\n           [\"col_1\",\"some_value\",1471347765127626]]}\n]</pre></div></div></div></div></div></div></div>\n<p>However, the data is displayed identically in CQL format, you will not be able to find tombstones caused by <code>null</code> values by looking at <code>SELECT</code> output:</p>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"5\"><div class=\"sql\" readability=\"6\"><pre class=\"de1\"> KEY | col_1      | col_2\n-----+------------+-------\n 444 | some_value |  NULL</pre></div></div></div></div></div></div></div>\n<div class=\"wp-geshi-highlight-wrap5\"><div class=\"wp-geshi-highlight-wrap4\"><div class=\"wp-geshi-highlight-wrap3\"><div class=\"wp-geshi-highlight-wrap2\"><div class=\"wp-geshi-highlight-wrap\"><div class=\"wp-geshi-highlight\" readability=\"5\"><div class=\"sql\" readability=\"6\"><pre class=\"de1\"> KEY | col_1      | col_2\n-----+------------+-------\n 555 | some_value |  NULL</pre></div></div></div></div></div></div></div>\n<p>It is also the only way to confirm existence of column range tombstones which are not logged by Cassandra and accordingly are not reported by any tools and metrics.</p>\n<h2>Set the appropriate <code>gc_grace_seconds</code> on tables</h2>\n<p>Routine repairs must be run on clusters where deletions occur (they may occur even if you don’t explicitly delete anything, see above) to avoid among other things deleted data becoming live again. You must run repairs more often than the <strong>minimum</strong> chosen <code>gc_grace_period</code> (<a href=\"https://docs.datastax.com/en/cassandra/2.2/cassandra/operations/opsRepairNodesWhen.html\" target=\"_blank\">see this article for more details</a>). Make sure you are capable of supporting repairs more frequent than the minimum <code>gc_grace_seconds</code> among all your tables.</p>\n<h2>Changing the tombstone warning / failure threshold</h2>\n<p>Invisible column range tombstones aside, there are two tombstone threshold settings in <code>cassandra.yaml</code> helpful for detecting a large number of tombstones affecting performance:<br/>– <code>tombstone_warn_threshold</code> (default: 1000): if the number of tombstones scanned by a query exceeds this number Cassandra will <strong>log a warning</strong> (which will likely be propagating to your monitoring system and send you an alert).<br/>– <code>tombstone_failure_threshold</code> (default: 10000): if the number of tombstones scanned by a query exceeds this number Cassandra will <strong>abort the query</strong>. The is a mechanism to prevent one or more nodes from running out of memory and crashing.</p>\n<p>These values should only be changed upwards if you are really confident about the memory use patterns in your cluster.</p>\n<h2>Conclusion</h2>\n<p>Tombstones are among the most misunderstood features of Cassandra and can cause significant performance problems if not investigated, monitored and dealt with in a timely manner. OpenCredo has acquired expertise in detecting and solving tombstone related problems on various projects by successfully using the tools shared above.</p>\n\n<h4>This is the fourth (and last) post in our blog series “Cassandra – What You May Learn The Hard Way.” Get the full overview <a href=\"https://opencredo.com/new-blog-cassandra-what-you-may-learn-the-hard-way/\" target=\"_blank\">here</a>.</h4>\n<h4>The associated webinar, “Cassandra – The Good, the Bad, and the Ugly” was broadcast on October 6th, 2016. View the recording <strong><a href=\"https://opencredo.com/cassandra-good-bad-ugly-webinar-recording/\"> here</a>.</strong></h4>\n\n<h4><a class=\"button\" href=\"https://opencredo.com/cassandra-tombstones-common-issues/#text_icl-6\">Sign up to receive updates via email</a></h4>\n<!--<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n\t\t\txmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n\t\t\txmlns:trackback=\"http://madskills.com/public/xml/rss/module/trackback/\">\n\t\t<rdf:Description rdf:about=\"https://opencredo.com/cassandra-tombstones-common-issues/\"\n    dc:identifier=\"https://opencredo.com/cassandra-tombstones-common-issues/\"\n    dc:title=\"Common Problems with Cassandra Tombstones\"\n    trackback:ping=\"https://opencredo.com/cassandra-tombstones-common-issues/trackback/\" />\n</rdf:RDF>-->"}}]}},"pageContext":{"alternative_id":1494}}