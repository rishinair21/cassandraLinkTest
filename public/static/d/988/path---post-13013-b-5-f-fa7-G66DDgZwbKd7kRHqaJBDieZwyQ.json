{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Querying Map-like Data in DSE Search","alternative_id":13013,"content":"<p>DSE search doesn’t yet support indexing frozen maps. When people have map-like data and would like to use Solr Query, how could we make it possible? In this blog, we demonstrate two approaches.</p><h3>Setup</h3><p dir=\"ltr\">Let’s create a single node cluster, workload as “Search”. The demo cluster uses DSE 5.1.1:</p><h4 dir=\"ltr\">Cluster</h4><pre>$ dsetool ring\nAddress          DC             Rack         Workload      Graph  Status    State          Load            Owns                 VNodes           \n10.200.177.142   DC1           rack1        Search           no     Up      Normal      393.99 MiB          ?                    16                                \nNote: you must specify a keyspace to get ownership information.</pre><h4 dir=\"ltr\">Table Schema With Map</h4><p dir=\"ltr\">We have an original table schema with a map collection, and we’d like to run a Solr query against it. This is a table of book metadata, the book id (an unique uuid), the book genre, type and the status of publication.</p><pre class=\"language-sql\">CREATE TABLE demodb.books_orig (book_id uuid PRIMARY KEY, tags map);</pre><p dir=\"ltr\">Let’s insert some sample data:</p><pre class=\"language-sql\">cqlsh:demodb&gt; INSERT INTO books_orig (book_id , tags ) VALUES ( uuid(), {'genre' :'Drama', 'type': 'fiction', 'is_published': 'true'});\ncqlsh:demodb&gt; INSERT INTO books_orig (book_id , tags ) VALUES ( uuid(), {'genre' :'Guide', 'type': 'non_fiction', 'is_published': 'true'});\ncqlsh:demodb&gt; INSERT INTO books_orig (book_id , tags ) VALUES ( uuid(), {'genre' :'Travel', 'type': 'non_fiction', 'is_published': 'true'});\ncqlsh:demodb&gt; INSERT INTO books_orig (book_id , tags ) VALUES ( uuid(), {'genre' :'Mystery', 'type': 'fiction', 'is_published': 'false'});</pre><p dir=\"ltr\">How do we proceed from here? According to the documentation, CQL map collections map to Search dynamic fields. What does it mean?  <img alt=\"\" height=\"25\" src=\"https://lh4.googleusercontent.com/OfmiipTBqrprbBugboO8AMCayIcelgzVP-PNr-tccMM7Nh4Gm_f00AWB45Vl9NyfJ1puk4EITtzsNVbCPLEAj1lV9YAIj5KLale3-9R45euPp8BTv0GTFyiuyPyHEajomDBMEkuY-mtJ_dxcUA\" width=\"25\" /></p><p>Let’s roughly describe what a dynamic field is in DSE Search. It is derived from Apache Solr dynamic field, which is named by using a prefix or suffix wildcard in schema.xml. In general, dynamic fields in Solr are used to index fields that are not defined explicitly by schema. DSE Search also uses it to index a CQL map collection. Using a dynamic field requires us to insert data into the map collection with keys that include its base name as a prefix or suffix, depending on the field. We have a demo below.</p><h3><em>Using dynamic fields</em></h3><p>Let’s modify the CQL schema slightly to align with the naming convention for dynamic fields:</p><pre class=\"language-sql\">CREATE TABLE demodb.books_dynamic_fld (book_id uuid PRIMARY KEY, tags_ map );</pre><p dir=\"ltr\">As described above, we must insert the data to include the map collection name as the base name, prefixing or suffixing in each map pair. We use prefix in this example:</p><pre class=\"language-sql\">cqlsh:demodb&gt; INSERT INTO demodb.books_dynamic_fld (book_id , tags_) VALUES ( 7fc4aab8-b469-4f0b-b7dd-bc9c922b9ef8, {'tags_genre':'Guide', 'tags_is_published': 'true', 'tags_type': 'non_fiction' });\ncqlsh:demodb&gt; INSERT INTO demodb.books_dynamic_fld (book_id , tags_) VALUES ( 6f5cbaa7-eec2-41bb-9668-d7e1ee6b0620, {'tags_genre':'Travel', 'tags_is_published': 'true', 'tags_type': 'non_fiction' });\ncqlsh:demodb&gt; INSERT INTO demodb.books_dynamic_fld (book_id , tags_) VALUES ( 2b6fa659-6912-45b3-afbf-69b1b97d75d0, {'tags_genre':'Drama', 'tags_is_published': 'true', 'tags_type': 'fiction' });\ncqlsh:demodb&gt; INSERT INTO demodb.books_dynamic_fld (book_id , tags_) VALUES ( 866b493c-78da-4550-afb6-cd6f16a6044e, {'tags_genre':'Mystery', 'tags_is_published': 'false', 'tags_type': 'fiction' });\n</pre><h4 dir=\"ltr\">Create solr core:</h4><p dir=\"ltr\">There are three ways to create Solr cores:</p><ul><li>The legacy “curl” http request for  CREATE_CORE;</li><li>“dsetool create_core”;</li><li>Since DSE 5.1, there is a new syntax, “CREATE SEARCH INDEX”, that supports Solr core creation over CQL.</li></ul><p>Note: It’s recommended to use dsetool or CQL statements over the legacy way of “curl/http” for core management including create, reload and unload, etc.</p><p dir=\"ltr\">We use the new syntax of “CREATE SEARCH INDEX”:</p><pre class=\"language-sql\">$ cqlsh&gt; CREATE SEARCH INDEX ON demodb.books_dynamic_fld;</pre><p dir=\"ltr\">When there are no existing resources, nor COLUMNS, PROFILES or CONFIG option provided in the CQL statement, new resources will be auto-generated with the default values. The above CQL statement has the same effect as “generateResources=true reindex=true” in dsetool create_core.</p><h4 dir=\"ltr\">Solr schema:</h4><pre class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt; \n&lt;schema name=\"autoSolrSchema\" version=\"1.5\"&gt;   \n  &lt;types&gt;     \n    &lt;fieldType class=\"org.apache.solr.schema.TextField\" name=\"TextField\"&gt;       \n     &lt;analyzer&gt;         \n      &lt;tokenizer class=\"solr.StandardTokenizerFactory\"/&gt;         \n      &lt;filter class=\"solr.LowerCaseFilterFactory\"/&gt;       \n     &lt;/analyzer&gt;     \n    &lt;/fieldType&gt;     \n    &lt;fieldType class=\"org.apache.solr.schema.UUIDField\" name=\"UUIDField\"/&gt;   \n  &lt;/types&gt;   \n&lt;fields&gt;     \n  &lt;dynamicField indexed=\"true\" multiValued=\"false\" name=\"tags_*\" stored=\"true\" type=\"TextField\"/&gt;     \n  &lt;field docValues=\"true\" indexed=\"true\" multiValued=\"false\" name=\"book_id\" stored=\"true\" type=\"UUIDField\"/&gt;   \n&lt;/fields&gt;   \n&lt;uniqueKey&gt;book_id&lt;/uniqueKey&gt; \n&lt;/schema&gt;</pre><p dir=\"ltr\">Notice that the CQL text field is mapped to a Solr TextField in the schema.xml, which is both tokenized and filtered before indexing, making token-based searching possible. If this is not necessary, and we're indexing simple strings, then the lower-overhead Solr type StrField would be preferable.</p><p dir=\"ltr\">Note: In the future DSE 6.0, a CQL text field will be mapped to a Solr StrField by default in auto-generated schema.xml.</p><p dir=\"ltr\">In this example, the text contents are a few single units without tokenizing. Let’s change them to StrField.</p><ul dir=\"ltr\"><li><p dir=\"ltr\">Add a new field type:</p></li></ul><pre class=\"language-sql\">cqlsh&gt; ALTER SEARCH INDEX SCHEMA ON demodb.books_dynamic_fld ADD types.fieldType[@name='StrField',@class='solr.StrField'];</pre><ul><li dir=\"ltr\"><p dir=\"ltr\">Set the dynamic field to use StrField:</p></li></ul><pre class=\"language-sql\">cqlsh&gt; ALTER SEARCH INDEX SCHEMA ON demodb.books_dynamic_fld SET dynamicField[@name='tags_*']@type = 'StrField';</pre><ul><li dir=\"ltr\"><p dir=\"ltr\">Since there is no any field referring to field type “TextField”, we drop it.</p></li></ul><pre class=\"language-sql\">cqlsh&gt; ALTER SEARCH INDEX SCHEMA ON demodb.books_dynamic_fld DROP fieldType[@name='TextField'];</pre><ul><li dir=\"ltr\"><p dir=\"ltr\">Reload the search index:</p></li></ul><pre class=\"language-sql\">cqlsh&gt; RELOAD SEARCH INDEX ON demodb.books_dynamic_fld;</pre><ul><li dir=\"ltr\"><p dir=\"ltr\">Rebuild the search index. Given that we change the field type, we use full reindex with “deleteAll:true” in this example:</p></li></ul><pre class=\"language-sql\">cqlsh&gt; REBUILD SEARCH INDEX ON demodb.books_dynamic_fld WITH OPTIONS { deleteAll:true };</pre><p dir=\"ltr\">New schema.xml:</p><pre class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt; \n&lt;schema name=\"autoSolrSchema\" version=\"1.5\"&gt;   \n  &lt;types&gt;     \n    &lt;fieldType class=\"org.apache.solr.schema.StrField\" name=\"StrField\" /&gt;       \n    &lt;fieldType class=\"org.apache.solr.schema.UUIDField\" name=\"UUIDField\"/&gt;   \n  &lt;/types&gt;   \n&lt;fields&gt;     \n  &lt;dynamicField indexed=\"true\" multiValued=\"false\" name=\"tags_*\" stored=\"true\" type=\"StrField\"/&gt;     \n  &lt;field docValues=\"true\" indexed=\"true\" multiValued=\"false\" name=\"book_id\" stored=\"true\" type=\"UUIDField\"/&gt;   \n&lt;/fields&gt;   \n&lt;uniqueKey&gt;book_id&lt;/uniqueKey&gt; \n&lt;/schema&gt;</pre><p dir=\"ltr\">Let’s search …</p><p dir=\"ltr\">“Find all fiction books”:</p><pre class=\"language-sql\">cqlsh:demodb&gt; select * from books_dynamic_fld  where solr_query = '{\"q\": \"tags_type:fiction\"}';   \nbook_id                              | solr_query |       tags_ -----------------------------------+------------+---------------------\n2b6fa659-6912-45b3-afbf-69b1b97d75d0 |       null |    {'tags_genre': 'Drama', 'tags_is_published': 'true', 'tags_type': 'fiction'}  \n866b493c-78da-4550-afb6-cd6f16a6044e |       null | {'tags_genre': 'Mystery', 'tags_is_published': 'false', 'tags_type': 'fiction'}\n(2 rows)\n</pre><h3 dir=\"ltr\"><em>Using UDT and Tuples</em></h3><p dir=\"ltr\">Beside using dynamic field, there is another way to index and query the map-like data. Let’s see the next example.</p><h4 dir=\"ltr\">We need to create an UDT for the tags we defined:</h4><pre class=\"language-sql\">CREATE TYPE demodb.tag (genre text, is_published boolean, type text);</pre><h4 dir=\"ltr\">CQL table schema:</h4><pre class=\"language-sql\">CREATE TABLE demodb.books_udt (book_id uuid PRIMARY KEY, tags frozen );</pre><p dir=\"ltr\">Note: Although the frozen type is used in this example, a non-frozen UDT is supported from DSE 5.1 onward.</p><h3 dir=\"ltr\">Inserting data as we did for the original table:</h3><pre class=\"language-sql\">cqlsh:demodb&gt; INSERT INTO books_udt (book_id , tags ) VALUES ( 7fc4aab8-b469-4f0b-b7dd-bc9c922b9ef8, {\"genre\": 'Guide', \"is_published\": true, \"type\": 'non_fiction'});\ncqlsh:demodb&gt; INSERT INTO books_udt (book_id , tags ) VALUES ( 6f5cbaa7-eec2-41bb-9668-d7e1ee6b0620, {\"genre\": 'Travel', \"is_published\": true, \"type\": 'non_fiction'});\ncqlsh:demodb&gt; INSERT INTO books_udt (book_id , tags ) VALUES ( 2b6fa659-6912-45b3-afbf-69b1b97d75d0, {\"genre\": 'Drama', \"is_published\": true, \"type\": 'fiction'});\ncqlsh:demodb&gt; INSERT INTO books_udt (book_id , tags ) VALUES ( 866b493c-78da-4550-afb6-cd6f16a6044e, {\"genre\": 'Mystery', \"is_published\": false, \"type\": 'fiction'});</pre><p dir=\"ltr\">Similar to the previous demo for dynamic field, we create the search index with auto-generated resources, and are going to use Solr StrField for CQL text field. To achieve that, let’s include the PROFILES in the CQL statement and apply the space saving options, “spaceSavingNoTextfield”, to use StrField on initial creation.</p><pre class=\"language-sql\">cqlsh:demodb&gt; CREATE SEARCH INDEX ON demodb.books_udt WITH PROFILES spaceSavingNoTextfield;</pre><p dir=\"ltr\">Let’s see the Solr schema.xml generated:</p><pre class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt; \n&lt;schema name=\"autoSolrSchema\" version=\"1.5\"&gt;   \n  &lt;types&gt;     \n    &lt;fieldType class=\"org.apache.solr.schema.UUIDField\" name=\"UUIDField\"/&gt;     \n    &lt;fieldType class=\"com.datastax.bdp.search.solr.core.types.TupleField\" name=\"TupleField\"/&gt;     \n    &lt;fieldType class=\"org.apache.solr.schema.StrField\" name=\"StrField\" /&gt;        \n    &lt;fieldType class=\"org.apache.solr.schema.BoolField\" name=\"BoolField\"/&gt; \n&lt;/types&gt;   \n&lt;fields&gt;     \n  &lt;field docValues=\"true\" indexed=\"true\" multiValued=\"false\" name=\"book_id\" stored=\"true\" type=\"UUIDField\"/&gt;     \n  &lt;field indexed=\"true\" multiValued=\"false\" name=\"tags\" stored=\"true\" type=\"TupleField\"/&gt;\n  &lt;field indexed=\"true\" multiValued=\"false\" name=\"tags.genre\" stored=\"true\" type=\"StrField\"/&gt;     \n  &lt;field indexed=\"true\" multiValued=\"false\" name=\"tags.is_published\" stored=\"true\" type=\"BoolField\"/&gt;     \n  &lt;field indexed=\"true\" multiValued=\"false\" name=\"tags.type\" stored=\"true\" type=\"StrField\"/&gt;   \n&lt;/fields&gt;   \n&lt;uniqueKey&gt;book_id&lt;/uniqueKey&gt; \n&lt;/schema&gt;\n</pre><p dir=\"ltr\">We will search again:</p><p dir=\"ltr\">“I would like to get all published books”:</p><pre class=\"language-sql\">cqlsh&gt; use demodb;\ncqlsh:demodb&gt; select * from books_udt where solr_query = '{\"q\":\"{!tuple}tags.is_published:true\"}';   \nbook_id                              | solr_query | tags --------------------------------------+------------+----------------------------\n7fc4aab8-b469-4f0b-b7dd-bc9c922b9ef8 |       null |  {genre: 'Guide', is_published: 'true', type: 'non_fiction'}  \n6f5cbaa7-eec2-41bb-9668-d7e1ee6b0620 |       null | {genre: 'Travel', is_published: 'true', type: 'non_fiction'}  \n2b6fa659-6912-45b3-afbf-69b1b97d75d0 |       null |      {genre: 'Drama', is_published: 'true', type: 'fiction'}  \n(3 rows)</pre><h3 dir=\"ltr\"><em>Which method should we choose?</em></h3><p dir=\"ltr\">Between these two methods, which one should be chosen? That depends on the data in your map collection.</p><ul dir=\"ltr\"><li>If this is a map with static set of keys, both ways work.</li><li>If the map contains large amount of elements or the size of the map is unknown, there could be schema overhead by using UDT. Please choose dynamic field instead.</li><li>Please note, if the size of map grows widely, for example, millions of keys, the sheer size of the Solr schema may put pressure on the heap. Neither method will work. Please reconsider your data model in this case.</li><li>Whatever you do, please test it, functionality-wise and performance-wise!</li></ul><p>Should you have any questions, please feel free to contact Datastax support.</p><p dir=\"ltr\"> </p>"}}]}},"pageContext":{"alternative_id":13013}}