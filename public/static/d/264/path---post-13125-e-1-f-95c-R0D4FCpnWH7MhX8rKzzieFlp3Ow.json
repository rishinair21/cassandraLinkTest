{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Everything you need to know about Cassandra Materialized Views - OpenCredo","alternative_id":13125,"content":"Everything you need to know about Cassandra Materialized Views - OpenCredo&#13;\n&#13;\n\t\t<header class=\"bg-white-90 text-blue fixed w-full z-9999 transition-slow\">&#13;\n</header><section class=\"breadcrumb\"><section><div class=\"wrapper justify-start sm:flex-row pt-0 sm:pt-90 pb-60 max-w-full-minus-60 lg:max-w-895 mb-120\"><div class=\"w-full sm:w-2/3 pr-0 sm:pr-20\"><p class=\"font-title mb-10 uppercase\">&#13;\n\t\tFebruary 16, 2017&#13;\n\t | <a href=\"https://opencredo.com/blogs/category/cassandra/\" class=\"text-blue\">Cassandra</a></p><p>One of the default Cassandra strategies to deal with more sophisticated queries is to create CQL tables that contain the data in a structure that matches the query itself (denormalization). Cassandra 3.0 introduces a new CQL feature, Materialized Views which captures this concept as a first-class construct.</p></div><div class=\"w-full sm:w-1/3 text-center first-on-sm mb-30\"><p class=\"font-title font-bold mt-30\">WRITTEN BY</p><img src=\"https://15rf562os5r61q4tvf2630fw-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/David-Borsos-_-No-Job-title.jpg\" alt=\"David Borsos\" class=\"circle mb-7.5 h-64 sm:h-auto w-64 sm:w-auto\" /><p class=\"font-title text-orange uppercase font-bold mb-0\"><a href=\"https://opencredo.com/authors/david-borsos/\" title=\"Posts by David Borsos\">David Borsos</a></p></div></div></section><section class=\"bg-light-grey\"><div class=\"wrapper max-w-full-minus-60 lg:max-w-895 mb-30\"><div class=\"max-w-full\"><img src=\"https://15rf562os5r61q4tvf2630fw-wpengine.netdna-ssl.com/wp-content/uploads/2018/10/banner-expertise-895x196.jpg\" alt=\"Everything you need to know about Cassandra Materialized Views\" class=\"-mt-120 mb-30 md:mb-60\" /><p>We decided to take a closer look.</p><p>Materialized Views are essentially standard CQL tables that are maintained automatically by the Cassandra server – as opposed to needing to manually write to many denormalized tables containing the same data, like in previous releases of Cassandra. At glance, this looks like a great feature: automating a process that was previously done by hand, and the server taking the responsibility for maintaining the various data structures.</p><p>For example, let’s suppose that we want to capture payment transaction information for a set of users. You can have the following structure as your base table which you would write the transactions to:</p><p>This table can be used to record transactions of users for each year, and is suitable for querying the transaction log of each of our users.</p><p>Let’s suppose there is a requirement for an administrative function allowing to see all the transactions for a given day.<br />CQL has been extended by the <code>CREATE MATERIALIZED VIEW</code> command, which can be used in the following manner:</p><p>Let’s insert some data:</p><p>As you would expect, you can then execute the following queries:</p><p>And:</p><p>The Materialized View is not a fundamentally special construct. Behind the scene, Cassandra will create “standard” table, and any mutation / access will go through the usual write and read paths.<br />If we look into the data directory for this keyspace, we should expect to find two separate subdirectories, containing SSTables for the base table and the Materialized View:</p><p>Let’s investigate the declaration of the Materialized View in a bit more detail:</p><p>Note the <code>PRIMARY KEY</code> clause at the end of this statement. This is much what you would expect from Cassandra data modeling: defining the partition key and clustering columns for the Materialized View’s backing table. As such it should always be chosen carefully and the usual best practices apply to it:</p><ul><li>Avoid unbounded partitions</li>\n<li>Avoid too large partitions</li>\n<li>Choose your partition key in a way that distributes the data correctly, avoiding cluster hotspots (the partition key chosen above is <strong>not a good one</strong> as it leads to temporal hotspots)</li>\n</ul><p>Also note the <code>NOT NULL</code> restrictions on all the columns declared as primary key. This is to ensure that no records in the Materialized View can exist with an incomplete primary key. This is currently a strict requirement when creating Materialized Views and trying to omit these checks will result in an error: <code>Primary key column 'year' is required to be filtered by 'IS NOT NULL'</code></p><p>In the current versions of Cassandra there are a number of limitations on the definition of Materialized Views.</p><h2>A primary key of a Materialized View must contain all columns from the primary key of the base table</h2><p>Any materialized view must map one CQL row from the base table to precisely one other row in the materialized view. This in practice means that all columns of the original primary key (partition key and clustering columns) <strong>must be</strong> represented in the materialized view, however they can appear in any order, and can define different partitioning compared to the base table.</p><p>Accustomed to relational database systems, this may feel like an odd restriction. It actually makes sense if you consider how Cassandra manages the data in the Materialized View. Since the View is nothing more under the hood than another Cassandra table, and is being updated via the usual mechanisms, when the base table is updated; an appropriate mutation is automatically generated and applied to the View.<br />In case a single CQL row in the Materialized View would be a result of potentially collapsing multiple base table rows, Cassandra would have no way of tracking the changes from all these base rows and appropriately represent them in the Materialized View (this is especially problematic on deletions of base rows).</p><p>As a result you are not allowed to define a Materialized View like this:</p><p>This attempt will result in the following error: <code>Cannot create Materialized View transactions_by_card without primary key columns from base cc_transactions (day,month,userid)</code></p><p>This may be somewhat surprising – the ID column is a unique transaction identifier after all. However this is additional knowledge that is due to the semantics of the data model, and Cassandra has no way of understanding (or verifying and enforcing) that it is actually true or not. <strong>As a developer you have additional knowledge of the data</strong> being manipulated than what is possible to declare in the CQL models.</p><h2>A primary key of a Materialized View can contain at most one other column</h2><p>As established already, the full base primary key must be part of the primary key of the Materialized View. It is possible to add another column from the original base table that was not part of the original primary key, but this is restricted in only a <strong>single additional column</strong>.</p><p>Again, this restriction feels rather odd. In this case the explanation is much more subtle: in certain concurrent update cases when both columns of the base table are manipulated at the same time; it is technically difficult to implement a solution on Cassandra’s side that guarantees no data (or deletions) are lost and the Materialized Views are consistent with the base table.</p><p>This restriction may be lifted in later releases, once the following tickets are resolved:<br /><a href=\"https://issues.apache.org/jira/browse/CASSANDRA-9928\">https://issues.apache.org/jira/browse/CASSANDRA-9928</a><br /><a href=\"https://issues.apache.org/jira/browse/CASSANDRA-10226\">https://issues.apache.org/jira/browse/CASSANDRA-10226</a></p><h2>Advanced WHERE filtering criteria on columns that are not part of the base table’s primary key are only supported in Cassandra 3.10</h2><p>Let’s suppose you want to create a View for “suspicious” transactions – those have too large of an amount associated with them. A possible way of implementing this is via a Materialized View with a more complex filter criteria:</p><p>This works on Cassandra 3.10 (the latest release at the time of writing this blog), and produces the results you would expect:<br />After executing:</p><p>When we query:</p><p>However on Cassandra 3.9 we get the error: <code>Non-primary key columns cannot be restricted in the SELECT statement used for materialized view creation (got restrictions on: amount)</code></p><p>Maintaining the consistency between the base table and the associated Materialized Views comes with a cost. Since a Materialized View is effectively a Cassandra table, there is the obvious cost of writing to these tables. There is more to it though. Writing to any base table that has associated Materialized Views will result in the following:</p><ol><li>Locking of the entire partition</li>\n<li>Reading the current partition contents</li>\n<li>Calculating all the view mutations</li>\n<li>Creating a batch of the base mutation + the view mutations</li>\n<li>Executing all the changes</li>\n</ol><p>The first two steps are to ensure that a consistent state of the data is persisted across all Materialized Views – no two updates on the based table are allowed to interleave, therefore we are certain to read a consistent state of the full row and generate any Materialized View updates based on it.</p><p>Creating a batch of the mutations is for atomicity – using Cassandra’s batching capabilities ensures that if the base table mutation is successful, all the views will eventually represent the correct state. In practice this adds a significant overhead to write operations. Especially considering a read operation is executed before the write this transforms the expected characteristics quite dramatically (writes in Cassandra normally don’t require random disk I/O but in this case they will).</p><p>A tracing session with on a standard write with Consistency Level ONE would look like this:</p><p>Executing the same insert with one Materialized View on the table results in the following trace:</p><p>As you can see from the traces, the additional cost on the writes is significant.</p><p>Bear in mind that this is not a fair comparison – we are comparing a single-table write with another one that is effectively writing to two tables. The reason for including is to demonstrate the the difference in executing the same CQL write with or without a Materialized View.</p><p>In a realistic situation you would execute two writes on the client side, one to the base table and another to the Materialized View, or more likely a batch of two writes to ensure atomicity. According to <a href=\"http://www.datastax.com/dev/blog/materialized-view-performance-in-cassandra-3-x\">DataStax performance tests</a>, in such cases the built-in Materialized Views perform better than the manual denormalization (with batching), especially for single-row partitions.</p><p>Deletes and updates generally work the way you would expect. Given the following state:</p><p>If we execute</p><p>Then</p><h2>Tombstones when updating</h2><p>There are some unexpected cases worth keeping in mind. When updating a column that is made part of a Materialized View’s primary key, <strong>Cassandra will execute a DELETE and an INSERT statement to get the View into the correct state</strong> – thus resulting in a tombstone.<br />To demonstrate this, let’s suppose we want to be able to query transactions for a user by status:</p><p>Truncating the base table and executing:</p><p>After nodetool flush and taking a look at the SSTable of transactions_by_status:</p><p>Notice the tombstoned row for partition <code>(“Bob”, “2017”, “PENDING”)</code> – this is a result of the initial insert and subsequent update. This is because by updating status in the base table, we have effectively created a new row in the Materialized View, deleting the old one.<br />This particular data structure is <strong>strongly discouraged</strong>: it will result in having a lot of tombstones in the <code>(“Bob”, “2017”, “PENDING”)</code> partition and is prone to hitting the tombstone warning and failure thresholds. Even worse – it is not immediately obvious that you are generating tombstones.<br />Instead of using a Materialized View, a SASI index is a much better choice for this particular case.</p><p>It is also possible to create a Materialized View over a table that already has data. In such cases Cassandra will create a View that has all the necessary data. As this might take a significant amount of time depending on the amount of data held in the base table, it is possible to track status via the system.built_views metadata table.</p><p>Materialized Views sounds like a great feature. Pushing the responsibility to maintain denormalizations for queries to the database is highly desirable and reduces the complexity of applications using Cassandra.</p><p>However the current implementation has many shortcomings that make it difficult to use in most cases. Most importantly the serious restrictions on the possible primary keys of the Materialized Views limit their usefulness a great deal. In addition any Views will have to have a well-chosen partition key and extra consideration needs to be given to unexpected tombstone generation in the Materialized Views.<br />And, there is a definite performance hit compared to simple writes. If an application is sensitive to write latency and throughput, consider the options carefully (Materialized Views, manual denormalisation) and do a proper performance testing exercise before making a choice.</p><p>To summarise – Materialized Views is an addition to CQL that is, in its current form suitable in a few use-cases: when write throughput is not a concern and the data model can be created within the functional limitations.</p></div></div></section><section class=\"bg-white text-blue pt-60 pb-60\"><div class=\"wrapper\"><p>&#13;\n\t\t\t\t\t</p><h2 class=\"mb-30 text-16 font-bold\">SIMILAR POSTS</h2>&#13;<div class=\"flex flex-wrap w-full lg:w-5/6 justify-center\"><div class=\"owl-carousel owl-carousel-insights flex items-stretch mb-30 md:mb-30 pl-0 sm:pl-30 pr-0 sm:pr-30 lg:pl-0 lg:pr-0\"><div class=\"bg-orange h-full\"><a href=\"https://opencredo.com/blogs/riak-the-dynamo-paper-and-life-beyond-basho/\" title=\"Read More\"><img src=\"https://15rf562os5r61q4tvf2630fw-wpengine.netdna-ssl.com/wp-content/uploads/2018/10/banner-case-studies-297x236.jpg\" alt=\"Riak, the Dynamo paper and life beyond Basho\" class=\"block w-full\" /></a><div class=\"text-white p-30\"><p class=\"text-18 mb-30\"><a href=\"https://opencredo.com/blogs/riak-the-dynamo-paper-and-life-beyond-basho/\" class=\"text-white no-underline font-bold\">Riak, the Dynamo paper and life beyond Basho</a></p>Recently, the sad news has emerged that Basho, which developed the Riak distributed database, has gone into receivership. This would appear to present a problem…<p><a href=\"https://opencredo.com/blogs/riak-the-dynamo-paper-and-life-beyond-basho/\" class=\"text-white no-underline font-bold\">Read More <img src=\"https://15rf562os5r61q4tvf2630fw-wpengine.netdna-ssl.com/wp-content/themes/wp-ocd/assets/img/arrow-white.png\" alt=\"Read More\" class=\"h-16 ml-7.5\" /></a></p></div></div><div class=\"bg-orange h-full\"><a href=\"https://opencredo.com/blogs/spark-testing/\" title=\"Read More\"><img src=\"https://15rf562os5r61q4tvf2630fw-wpengine.netdna-ssl.com/wp-content/uploads/2018/10/banner-expertise-297x236.jpg\" alt=\"Testing a Spark Application\" class=\"block w-full\" /></a><div class=\"text-white p-30\"><p class=\"text-18 mb-30\"><a href=\"https://opencredo.com/blogs/spark-testing/\" class=\"text-white no-underline font-bold\">Testing a Spark Application</a></p>Data analytics isn’t a field commonly associated with testing, but there’s no reason we can’t treat it like any other application. Data analytics services are…<p><a href=\"https://opencredo.com/blogs/spark-testing/\" class=\"text-white no-underline font-bold\">Read More <img src=\"https://15rf562os5r61q4tvf2630fw-wpengine.netdna-ssl.com/wp-content/themes/wp-ocd/assets/img/arrow-white.png\" alt=\"Read More\" class=\"h-16 ml-7.5\" /></a></p></div></div><div class=\"bg-orange h-full\"><a href=\"https://opencredo.com/blogs/deploy-spark-apache-cassandra/\" title=\"Read More\"><img src=\"https://15rf562os5r61q4tvf2630fw-wpengine.netdna-ssl.com/wp-content/uploads/2018/10/banner-services-297x236.jpg\" alt=\"Deploy Spark with an Apache Cassandra cluster\" class=\"block w-full\" /></a><div class=\"text-white p-30\"><p class=\"text-18 mb-30\"><a href=\"https://opencredo.com/blogs/deploy-spark-apache-cassandra/\" class=\"text-white no-underline font-bold\">Deploy Spark with an Apache Cassandra cluster</a></p>My recent blogpost I explored a few cases where using Cassandra and Spark together can be useful. My focus was on the functional behaviour of…<p><a href=\"https://opencredo.com/blogs/deploy-spark-apache-cassandra/\" class=\"text-white no-underline font-bold\">Read More <img src=\"https://15rf562os5r61q4tvf2630fw-wpengine.netdna-ssl.com/wp-content/themes/wp-ocd/assets/img/arrow-white.png\" alt=\"Read More\" class=\"h-16 ml-7.5\" /></a></p></div></div></div><a href=\"https://opencredo.com/blogs/\" class=\"btn hover-scale-105 text-18\">Blog</a></div></div></section><noscript>\n<div id=\"catapult-cookie-bar\" class=\"\"><p>This website uses cookies to maximise your experience and help us to understand how we can improve it. By continuing to browse this website or by clicking 'Accept', you consent to the use of cookies. If you would like to manage your cookie settings, you can control this in your internet browser. </p></div>\t</noscript></section>"}}]}},"pageContext":{"alternative_id":13125}}