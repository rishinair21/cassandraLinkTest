{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Data Modeling in Cassandra | Baeldung","alternative_id":10874,"content":"<div class=\"short_box short_start\">\n<h3><b>I just announced the new <em>Spring 5</em> modules in REST With Spring: </b></h3>\n<p><strong><a href=\"http://www.baeldung.com/rest-with-spring-course#new-modules\" id=\"announcement_CTA\">&gt;&gt; CHECK OUT THE COURSE</a></strong></p>\n</div><h2><strong>1. Overview</strong></h2>\n<p>Cassandra is a NoSQL database that provides high availability and horizontal scalability without compromising performance.</p>\n<p>To get the best performance out of Cassandra, we need to carefully design the schema around query patterns specific to the business problem at hand.</p>\n<p>In this article, we will review some of the key concepts around <strong>how to approach data modeling in Cassandra</strong>.</p>\n<p>Before proceeding, you can go through our <a href=\"http://www.baeldung.com/cassandra-with-java\">Cassandra with Java</a> article to understand the basics and how to connect to Cassandra using Java.</p>\n<h2><strong>2. Partition Key<br /></strong></h2>\n<p>Cassandra is a distributed database in which data is partitioned and stored across multiple nodes within a cluster.</p>\n<p>The partition key is made up of one or more data fields and is <strong>used by the partitioner to generate a token via hashing to distribute the data uniformly across a cluster</strong>.</p>\n<h2><strong>3. Clustering Key<br /></strong></h2>\n<p>A clustering key is made up of one or more fields and helps in clustering or grouping together rows with same partition key and storing them in sorted order.</p>\n<p>Let’s say that we are storing time-series data in Cassandra and we want to retrieve the data in chronological order. A clustering key that includes time-series data fields will be very helpful for efficient retrieval of data for this use case.</p>\n<p><strong>Note: The combination of partition key and clustering key makes up the primary key and uniquely identifies any record in the Cassandra cluster.</strong></p>\n<h2><strong>4. Guidelines Around Query Patterns<br /></strong></h2>\n<p>Before starting with data modeling in Cassandra, we should identify the query patterns and ensure that they adhere to the following guidelines:</p>\n<ol><li>Each query should fetch data from a single partition</li>\n<li>We should keep track of how much data is getting stored in a partition, as Cassandra has limits around the number of columns that can be stored in a single partition</li>\n<li>It is OK to denormalize and duplicate the data to support different kinds of query patterns over the same data</li>\n</ol><p>Based on the above guidelines, let’s look at some real-world use cases and how we would model the Cassandra data models for them.</p>\n<h2><strong>5. Real World Data Modeling Examples<br /></strong></h2>\n<h3><strong>5.1. Facebook Posts</strong></h3>\n<p>Suppose that we are storing Facebook posts of different users in Cassandra. One of the common query patterns will be fetching the top ‘<em>N</em>‘ posts made by a given user.</p>\n<p>Thus, <strong>we need to</strong> <strong>store all data for a particular user on a single partition</strong> as per the above guidelines.</p>\n<p>Also, using the post timestamp as the clustering key will be helpful for retrieving the top ‘<em>N</em>‘ posts more efficiently.</p>\n<p>Let’s define the Cassandra table schema for this use case:</p>\n<pre class=\"brush: sql; gutter: true\">CREATE TABLE posts_facebook (&#13;\n  user_id uuid,&#13;\n  post_id timeuuid, &#13;\n  content text,&#13;\n  PRIMARY KEY (user_id, post_id) )&#13;\nWITH CLUSTERING ORDER BY (post_id DESC);</pre>\n<p>Now, let’s write a query to find the top 20 posts for the user <em>Anna</em>:</p>\n<pre class=\"brush: sql; gutter: true\">SELECT content FROM posts_facebook WHERE user_id = \"Anna_id\" LIMIT 20</pre>\n<h3><strong>5.2. Gyms Across the Country</strong></h3>\n<p>Suppose that we are storing the details of different partner gyms across the different cities and states of many countries and we would like to fetch the gyms for a given city.</p>\n<p>Also, let’s say we need to return the results having gyms sorted by their opening date.</p>\n<p>Based on the above guidelines, we should store the gyms located in a given city of a specific state and country on a single partition and use the opening date and gym name as a clustering key.</p>\n<p>Let’s define the Cassandra table schema for this example:</p>\n<pre class=\"brush: sql; gutter: true\">CREATE TABLE gyms_by_city (&#13;\n country_code text,&#13;\n state text,&#13;\n city text,&#13;\n gym_name text,&#13;\n opening_date timestamp,&#13;\n PRIMARY KEY (&#13;\n   (country_code, state_province, city), &#13;\n   (opening_date, gym_name)) &#13;\n WITH CLUSTERING ORDER BY (opening_date ASC, gym_name ASC);</pre>\n<p>Now, let’s look at a query that fetches the first ten gyms by their opening date for the city of Phoenix within the U.S. state of Arizona:</p>\n<pre class=\"brush: sql; gutter: true\">SELECT * FROM gyms_by_city&#13;\n  WHERE country_code = \"us\" AND state = \"Arizona\" AND city = \"Phoenix\"&#13;\n  LIMIT 10</pre>\n<p class=\"brush: sql; gutter: true\">Next, let’s see a query that fetches the ten most recently-opened gyms in the city of Phoenix within the U.S. state of Arizona:</p>\n<pre class=\"brush: sql; gutter: true\">SELECT * FROM gyms_by_city&#13;\n  WHERE country_code = \"us\" and state = \"Arizona\" and city = \"Phoenix\"&#13;\n  ORDER BY opening_date DESC &#13;\n  LIMIT 10</pre>\n<p>Note: As the last query’s sort order is opposite of the sort order defined during the table creation, the query will run slower as Cassandra will first fetch the data and then sort it in memory.</p>\n<h3><strong>5.3. E-commerce Customers and Products</strong></h3>\n<p>Let’s say we are running an e-commerce store and that we are storing the <em>Customer</em> and <em>Product</em> information within Cassandra. Let’s look at some of the common query patterns around this use case:</p>\n<ol><li>Get <em>Customer</em> info</li>\n<li>Get <em>Product</em> info</li>\n<li>Get all <em>Customers</em> who like a given <em>Product</em></li>\n<li>Get all <em>Products</em> a given <em>Customer</em> likes</li>\n</ol><p>We will start by using separate tables for storing the <em>Customer</em> and <em>Product</em> information. However, we need to introduce a fair amount of denormalization to support the 3rd and 4th queries shown above.</p>\n<p>We will create two more tables to achieve this – “<em>Customer_by_Product</em>” and “<em>Product_by_Customer</em>“.</p>\n<p>Let’s look at the Cassandra table schema for this example:</p>\n<pre class=\"brush: sql; gutter: true\">CREATE TABLE Customer (&#13;\n  cust_id text,&#13;\n  first_name text, &#13;\n  last_name text,&#13;\n  registered_on timestamp, &#13;\n  PRIMARY KEY (cust_id));&#13;\n&#13;\nCREATE TABLE Product (&#13;\n  prdt_id text,&#13;\n  title text,&#13;\n  PRIMARY KEY (prdt_id));&#13;\n&#13;\nCREATE TABLE Customer_By_Liked_Product (&#13;\n  liked_prdt_id text,&#13;\n  liked_on timestamp,&#13;\n  title text,&#13;\n  cust_id text,&#13;\n  first_name text, &#13;\n  last_name text, &#13;\n  PRIMARY KEY (prdt_id, liked_on));&#13;\n&#13;\nCREATE TABLE Product_Liked_By_Customer (&#13;\n  cust_id text, &#13;\n  first_name text,&#13;\n  last_name text,&#13;\n  liked_prdt_id text, &#13;\n  liked_on timestamp,&#13;\n  title text,&#13;\n  PRIMARY KEY (cust_id, liked_on));</pre>\n<p>Note: To support both the queries, recently-liked products by a given customer and customers who recently liked a given product, we have used the “<em>liked_on</em>” column as a clustering key.</p>\n<p>Let’s look at the query to find the ten Customers who most recently liked the product “<em>Pepsi</em>“:</p>\n<pre class=\"brush: sql; gutter: true\">SELECT * FROM Customer_By_Liked_Product WHERE title = \"Pepsi\" LIMIT 10</pre>\n<p>And let’s see the query that finds the recently-liked products (up to ten) by a customer named “<em>Anna</em>“:</p>\n<pre class=\"brush: sql; gutter: true\">SELECT * FROM Product_Liked_By_Customer &#13;\n  WHERE first_name = \"Anna\" LIMIT 10</pre>\n<h2><strong>6. Inefficient Query Patterns</strong></h2>\n<p>Due to the way that Cassandra stores data, some query patterns are not at all efficient, including the following:</p>\n<ul><li><strong>Fetching data from multiple partitions</strong> – this will require a coordinator to fetch the data from multiple nodes, store it temporarily in heap, and then aggregate the data before returning results to the user</li>\n<li><strong>Join-based queries</strong> – due to its distributed nature, Cassandra does not support table joins in queries the same way a relational database does, and as a result, <strong>queries with</strong> <strong>joins will be slower and can also lead to inconsistency and availability issues</strong></li>\n</ul><h2><strong>7. Conclusion</strong></h2>\n<p>In this tutorial, we have covered several best practices around how to approach data modeling in Cassandra.</p>\n<p>Understanding the core concepts and identifying the query patterns in advance is necessary for designing a correct data model that gets the best performance from a Cassandra cluster.</p>\n<div class=\"short_box short_end\">\n<h3><b>I just announced the new Spring 5 modules in REST With Spring: </b></h3>\n<p><strong><a href=\"http://www.baeldung.com/rest-with-spring-course#new-modules\">&gt;&gt; CHECK OUT THE LESSONS</a></strong></p>\n</div>"}}]}},"pageContext":{"alternative_id":10874}}