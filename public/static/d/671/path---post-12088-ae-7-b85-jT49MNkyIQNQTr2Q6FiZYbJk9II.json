{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Apache Cassandra, Part 5: Data Modelling with Examples","alternative_id":12088,"content":"<p id=\"0352\" class=\"graf graf--p graf--leading\">Data modelling in Cassandra revolves around two goals:</p><ol class=\"postList\"><li id=\"9b10\" class=\"graf graf--li graf-after--p\">Spread data evenly among partitions.</li><li id=\"83ff\" class=\"graf graf--li graf-after--li\">A read query should (ideally) hit only a single partition.</li></ol><p id=\"cf55\" class=\"graf graf--p graf-after--li\">Often you will find yourself in scenarios, and as you will see later in examples, these rules start conflicting, so you have to balance them according to business requirements.</p><h3 id=\"5503\" class=\"graf graf--h3 graf-after--p\">Data Modelling Tips</h3><p id=\"30ef\" class=\"graf graf--p graf-after--h3\">Before going through the data modelling examples, let’s review some of the points to keep in mind while modelling the data in Cassandra.</p><ul class=\"postList\"><li id=\"c786\" class=\"graf graf--li graf-after--p\">Model your data around queries and not around relationships. In other words, your data model should be heavily driven by your read requirements and use cases.</li><li id=\"01a0\" class=\"graf graf--li graf-after--li\">Create tables where you can satisfy your queries by reading (ideally) one or minimum number of partitions.</li><li id=\"e082\" class=\"graf graf--li graf-after--li\">Each table should pre-build the answer to a high-level query that you need to support.</li><li id=\"5ed8\" class=\"graf graf--li graf-after--li\">Key point to remember is <strong class=\"markup--strong markup--li-strong\">Optimize for Reads</strong>.</li><li id=\"d890\" class=\"graf graf--li graf-after--li\">Remember <strong class=\"markup--strong markup--li-strong\">Writes are Cheap</strong>, disks are available at very low costs, and data duplication is fact of life in Cassandra. Don’t be afraid of data duplication while trying to optimize for reads.</li></ul><h3 id=\"67d9\" class=\"graf graf--h3 graf-after--li\">Data Modelling Examples</h3><p id=\"17c8\" class=\"graf graf--p graf-after--h3\">Lets look at few examples and try to apply the knowledge we have gained so far on Cassandra.</p><h4 id=\"7dd1\" class=\"graf graf--h4 graf-after--p\">Example 1</h4><p id=\"d1e1\" class=\"graf graf--p graf-after--h4\">Consider a scenario where we have a large number of <strong class=\"markup--strong markup--p-strong\">users</strong> and we want to look up a user by <strong class=\"markup--strong markup--p-strong\">username</strong> or by <strong class=\"markup--strong markup--p-strong\">email</strong>. With either method, we should get the full details of matching user.</p><figure id=\"aa99\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*VM1p0xpblqcJg0PXi5u4rg.png\" data-width=\"500\" data-height=\"272\" src=\"https://cdn-images-1.medium.com/max/1600/1*VM1p0xpblqcJg0PXi5u4rg.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" data-href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling</a></figcaption></figure><p id=\"dd1e\" class=\"graf graf--p graf-after--figure\">In first implementation we have created two tables. One has partition key <strong class=\"markup--strong markup--p-strong\">username</strong> and other one <strong class=\"markup--strong markup--p-strong\">email</strong>. Note that we are duplicating information (age) in both tables.</p><figure id=\"ad1f\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*WEKG9Khc-se7Nnc5dts0pw.png\" data-width=\"500\" data-height=\"393\" src=\"https://cdn-images-1.medium.com/max/1600/1*WEKG9Khc-se7Nnc5dts0pw.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" data-href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling</a></figcaption></figure><p id=\"ca68\" class=\"graf graf--p graf-after--figure\">Another way to model this data could be what’s shown above. In this case we have three tables, but we have avoided the data duplication by using last two tables as reference tables. Just like before reference tables are partitioning the data using username and email, but user details are located at a single place.</p><p id=\"8559\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\"><em class=\"markup--em markup--p-em\">So which data model is better?</em></strong></p><p id=\"b752\" class=\"graf graf--p graf-after--p\">Recall two primary rules of data modelling in Cassandra (1) each partition should have roughly same amount of data (2) read operations should access minimum partitions, ideally only one.</p><p id=\"3466\" class=\"graf graf--p graf-after--p\">If we apply these rules to model #1, we will only need to access one partition to get full user details. Additionally, we can easily find which partition contains our data as both username and email have been used as partition key. Assuming usernames and emails have uniform distribution, we will have roughly same quantity of data in each partition.</p><p id=\"6f19\" class=\"graf graf--p graf-after--p\">Now, lets evaluate model #2. Although there is no data duplication in this model (keep in mind it’s okay to have data duplication as long as it optimizes read performance) but it comes with one big disadvantage: it violates the rule of reading from a single partition. To find user details, first we will go to a partition using username (or email), and then we will do another partition lookup through uuid.</p><p id=\"e579\" class=\"graf graf--p graf-after--p\">Therefore, in this scenario it is better to use model #1.</p><h4 id=\"ca69\" class=\"graf graf--h4 graf-after--p\">Example 2</h4><p id=\"e845\" class=\"graf graf--p graf-after--h4\">Our requirements have been updated. Now, each user belongs to a group. And we want to fetch all users of a group by group name including all details of its users.</p><figure id=\"4aee\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*8srORb1aPHlpw6qNyLU8-g.png\" data-width=\"500\" data-height=\"158\" src=\"https://cdn-images-1.medium.com/max/1600/1*8srORb1aPHlpw6qNyLU8-g.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" data-href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling</a></figcaption></figure><p id=\"250b\" class=\"graf graf--p graf-after--figure\">Here, data will be distributed among nodes based on group_name (partition key) and sorted within a node by username (clustering key). Each group stores complete information of its users.</p><p id=\"0d75\" class=\"graf graf--p graf-after--p\">Our proposed model satisfies the first data modeling principle, i.e. to read any group’s data we will have to hit only a single partition and there will find all users of that group. But does this model satisfy the 2nd principle? The answer is probably not. Why? Because generally, in the real world, there will be some very populated groups while other groups might be very small. Which means the size of partitions won’t be roughly same, and that is violation of our data modelling principle.</p><p id=\"f011\" class=\"graf graf--p graf-after--p\">One way to fix this could be this model</p><figure id=\"590f\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*uYkMW2vouxRfzvtELjIyPg.png\" data-width=\"1218\" data-height=\"344\" data-action=\"zoom\" data-action-value=\"1*uYkMW2vouxRfzvtELjIyPg.png\" src=\"https://cdn-images-1.medium.com/max/1600/1*uYkMW2vouxRfzvtELjIyPg.png\" alt=\"image\" /></div></figure><p id=\"6e9d\" class=\"graf graf--p graf-after--figure\">Now we are using a composite partition key, where hash_prefix is a just random number. This composite key will ensure that data is uniformly distributed among nodes hence our model no longer violates the 2nd principle. But it comes with a catch. As data will be distributed uniformly among partitions, in order to fetch all users in a particular group we will have to read more than one partition, hence violating the 1st principle.</p><p id=\"ae76\" class=\"graf graf--p graf-after--p\">This example teaches us an interesting lesson in Cassandra data modelling.</p><blockquote id=\"aab7\" class=\"graf graf--blockquote graf-after--p\"><div>The two data modeling principles often conflict, therefore you have to find a balance between the two based on domain understanding and business needs.</div></blockquote><h4 id=\"156e\" class=\"graf graf--h4 graf-after--blockquote\">Example 3</h4><p id=\"5563\" class=\"graf graf--p graf-after--h4\">Continuing on the previous examples, our new requirement is to add support for getting X newest users in a group. Here is one data model</p><figure id=\"19cf\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*5LesR_IYYrlRIh_qjnHzLA.png\" data-width=\"500\" data-height=\"188\" src=\"https://cdn-images-1.medium.com/max/1600/1*5LesR_IYYrlRIh_qjnHzLA.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" data-href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling</a></figcaption></figure><p id=\"38bd\" class=\"graf graf--p graf-after--figure\">All user data is located at a single place, data is partitioned by group_name and ordered by join date. [Ignoring the issue of data distribution we already discussed in last example] Model looks decent. Lookup by group name would take us to exact partition containing group data, sorting by join date means we only need to read last X records from the end. There is one further improvement we can do on this model which will make our queries more faster.</p><figure id=\"7059\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*qEjC070JbN_KlBw0dilqFA.png\" data-width=\"500\" data-height=\"167\" src=\"https://cdn-images-1.medium.com/max/1600/1*qEjC070JbN_KlBw0dilqFA.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" data-href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling</a></figcaption></figure><p id=\"3c28\" class=\"graf graf--p graf-after--figure\">Here, we are still sorting the partition data by join date, but in descending order. Now, we won’t even need to go to end of partition in order to read last X records. We can simply read top X records from the start of partition, hence reducing the IO cost.</p><p id=\"8a50\" class=\"graf graf--p graf-after--p\">Recall the data distribution problem we touched upon earlier, one way to solve that could be this.</p><figure id=\"14ec\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*F-ij4Ec1viZHqe2i1ZWazQ.png\" data-width=\"500\" data-height=\"163\" src=\"https://cdn-images-1.medium.com/max/1600/1*F-ij4Ec1viZHqe2i1ZWazQ.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" data-href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling</a></figcaption></figure><p id=\"b2d5\" class=\"graf graf--p graf-after--figure\">We have made the partition key composite by adding join date. This way a new partition will be created everyday for every group. Assuming each group is roughly inducting same number of users daily, this model can work. But now, in order to get last X joined users in a group, we will have to read more than one partition if number of users who joined that group in last day are less than X. One way to fix this could be to benchmark the number of users joining daily and set the composite key in such a way that last X users query only need to access a single partition.</p><h4 id=\"047b\" class=\"graf graf--h4 graf-after--p\">Example 4</h4><p id=\"9064\" class=\"graf graf--p graf-after--h4\">Let’s implement a simple Facebook use case where we need to fetch recent posts posted by a specific user. Here is a possible data model</p><figure id=\"6fd1\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*q7gMcWJtuAqWWdDiTmeE4Q.png\" data-width=\"500\" data-height=\"170\" src=\"https://cdn-images-1.medium.com/max/1600/1*q7gMcWJtuAqWWdDiTmeE4Q.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\">Couldn’t find the original source.</figcaption></figure><p id=\"e66f\" class=\"graf graf--p graf-after--figure\">Here, partition key user_id can easily take us to partition carrying posts of a particular user, sorting by post_id will help us in locating top X posts, and the descending order will further reduce our disk seeks by removing the need to go until the end of partition.</p><h4 id=\"76ed\" class=\"graf graf--h4 graf-after--p\">Example 5</h4><p id=\"1747\" class=\"graf graf--p graf-after--h4\">Let’s say we are developing an e-commerce site and we need to support following queries.</p><ol class=\"postList\"><li id=\"f585\" class=\"graf graf--li graf-after--p\">Get user by user id.</li><li id=\"c64f\" class=\"graf graf--li graf-after--li\">Get item by item id.</li><li id=\"bfc5\" class=\"graf graf--li graf-after--li\">Get all the items that a particular user likes.</li><li id=\"9625\" class=\"graf graf--li graf-after--li\">Get all the users who like a particular item.</li></ol><p id=\"46d0\" class=\"graf graf--p graf-after--li\">Here is an entity relationship diagram showing relationship between entities described in the use case.</p><figure id=\"5b7a\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*oLs1pcSZQ7DLAKM1Qmm_rQ.png\" data-width=\"600\" data-height=\"360\" data-is-featured=\"true\" src=\"https://cdn-images-1.medium.com/max/1600/1*oLs1pcSZQ7DLAKM1Qmm_rQ.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\" data-href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/</a></figcaption></figure><p id=\"ea0c\" class=\"graf graf--p graf-after--figure\">Lets start with a simple relational-like data model where we have three tables. First for keeping users with user Id as partition key, second for items with item Id as partition key, and third for storing user-item likes partitioned by unique Id assigned to each like record.</p><figure id=\"0a73\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*9MrS-S_85z1-d9q26sZmmw.png\" data-width=\"600\" data-height=\"307\" src=\"https://cdn-images-1.medium.com/max/1600/1*9MrS-S_85z1-d9q26sZmmw.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\" data-href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/</a></figcaption></figure><p id=\"cbb0\" class=\"graf graf--p graf-after--figure\">If Ids are being auto generated, each partition will have roughly same amount of data which satisfies our first data modelling goal. Coming to partition reads, this data model will be able to find result of query #1 and #2 very efficiently as Id of each user and item is being used as partition key. But, there is no easy way to access data for query #3 and #4 because there is no way to predetermine what partitions might have the required data. Rather all partitions will have to be scanned, which violates our second data modelling principle.</p><p id=\"0800\" class=\"graf graf--p graf-after--p\">A better data modelling approach can be following.</p><figure id=\"a4f3\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*nRV637CWZknwzGup_dHfHQ.png\" data-width=\"600\" data-height=\"300\" src=\"https://cdn-images-1.medium.com/max/1600/1*nRV637CWZknwzGup_dHfHQ.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\" data-href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/</a></figcaption></figure><p id=\"671a\" class=\"graf graf--p graf-after--figure\">Here, we have divided the user-like relationship table into two by introducing data redundancy. Using this redundancy we are able to partition data by both user Id and item Id separately. This gives us the ability to look at specific partitions when finding results for query #3 and #4.</p><p id=\"77d7\" class=\"graf graf--p graf-after--p\">But there is still one problem, note that we are only getting Ids i.e. user Id and item Id, from the newly introduced tables. In this design, we will still have to look up user and item partitions if we want to show meaningful information about users and items involved. Here is a quick fix, again using data duplication.</p><figure id=\"118b\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*1xDLAPSyOwB8TuoOggRSMA.png\" data-width=\"600\" data-height=\"301\" src=\"https://cdn-images-1.medium.com/max/1600/1*1xDLAPSyOwB8TuoOggRSMA.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\"><a href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\" data-href=\"https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.ebayinc.com/stories/blogs/tech/cassandra-data-modeling-best-practices-part-1/</a></figcaption></figure><p id=\"fb40\" class=\"graf graf--p graf-after--figure\">It is important to note here that we are not duplicating entire information of user or item in the relationship tables. For example, to show email or item description a lookup will still be required, but that decision is driven by business context. For example, in this case, we might be showing only user name or item title on initial interface and let user click on user/item for further details.</p><p id=\"ee5b\" class=\"graf graf--p graf-after--p graf--trailing\"><a href=\"https://blog.emumba.com/apache-cassandra-part-6-time-series-modelling-b9b0ad2e96d9\" data-href=\"https://blog.emumba.com/apache-cassandra-part-6-time-series-modelling-b9b0ad2e96d9\" class=\"markup--anchor markup--p-anchor\" target=\"_blank\">Next: Apache Cassandra, Part 6: Time Series Modelling in Cassandra</a></p>"}}]}},"pageContext":{"alternative_id":12088}}