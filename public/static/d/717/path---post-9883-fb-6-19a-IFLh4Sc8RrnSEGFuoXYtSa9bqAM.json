{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Understanding Cassandra tombstones – Beyond the lines","alternative_id":9883,"content":"<div id=\"ssba-classic-2\" class=\"ssba ssbp-wrap left ssbp--theme-1\"><div><a data-site=\"\" class=\"ssba_twitter_share\" href=\"http://twitter.com/share?url=https://www.beyondthelines.net/databases/cassandra-tombstones/&amp;text=Understanding%20Cassandra%20tombstones%20\" target=\"&quot;_blank&quot;\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/twitter.png\" title=\"Twitter\" class=\"ssba ssba-img\" alt=\"Tweet about this on Twitter\" /><div title=\"Twitter\" class=\"ssbp-text\">Twitter</div></a><a data-site=\"linkedin\" class=\"ssba_linkedin_share ssba_share_link\" href=\"http://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.beyondthelines.net/databases/cassandra-tombstones/\" target=\"&quot;_blank&quot;\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/linkedin.png\" title=\"LinkedIn\" class=\"ssba ssba-img\" alt=\"Share on LinkedIn\" /><div title=\"Linkedin\" class=\"ssbp-text\">Linkedin</div></a><a data-site=\"\" class=\"ssba_facebook_share\" href=\"http://www.facebook.com/sharer.php?u=https://www.beyondthelines.net/databases/cassandra-tombstones/\" target=\"_blank\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/facebook.png\" title=\"Facebook\" class=\"ssba ssba-img\" alt=\"Share on Facebook\" /><div title=\"Facebook\" class=\"ssbp-text\">Facebook</div></a><a data-site=\"\" class=\"ssba_google_share\" href=\"https://plus.google.com/share?url=https://www.beyondthelines.net/databases/cassandra-tombstones/\" target=\"&quot;_blank&quot;\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/google.png\" title=\"Google+\" class=\"ssba ssba-img\" alt=\"Share on Google+\" /><div title=\"Google+\" class=\"ssbp-text\">Google+</div></a><a data-site=\"reddit\" class=\"ssba_reddit_share\" href=\"http://reddit.com/submit?url=https://www.beyondthelines.net/databases/cassandra-tombstones/&amp;title=Understanding Cassandra tombstones\" target=\"&quot;_blank&quot;\"><img src=\"https://www.beyondthelines.net/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/reddit.png\" title=\"Reddit\" class=\"ssba ssba-img\" alt=\"Share on Reddit\" /><div title=\"Reddit\" class=\"ssbp-text\">Reddit</div></a></div></div><p>We recently deployed in production a distributed system that uses Cassandra as its persistent storage.</p>\n<p>Not long after we noticed that there were many warnings about tombstones in Cassandra logs. </p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">&#13;\nWARN  [SharedPool-Worker-2] 2017-01-20 16:14:45,153 ReadCommand.java:508 - &#13;\nRead 5000 live rows and 4771 tombstone cells for query &#13;\nSELECT * FROM warehouse.locations WHERE token(address) &gt;= token(D3-DJ-21-B-02) LIMIT 5000 &#13;\n(see tombstone_warn_threshold)&#13;\n</pre>\n<p>We found it quite surprising at first because we’ve only inserted data so far and didn’t expect to see that many tombstones in our database. After asking some people around no one seemed to have a clear explanation on what was going on in Cassandra.</p>\n<p>In fact, the main misconception about tombstones is that people associate it with delete operations. While it’s true that tombstones are generated when data is deleted it is not the only case as we shall see.</p>\n<h4>Looking into sstables</h4>\n<p>Cassandra provides a tool to look at what is stored inside an sstable: sstabledump. This tool comes with the ‘casssandra-tools’ package which is not automatically installed with Cassandra. It’s quite straight-forward to install on a delian-like (e.g. unbuntu) distribution:</p>\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">&#13;\nsudo apt-get update&#13;\nsudo apt-get install cassandra-tools&#13;\n</pre>\n<p>In this blog post I used ssltabledump to understand how Cassandra stores data and when tombstones are generated.<br />\nThe syntax is pretty straightforward:</p>\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">&#13;\nsstabledump /var/lib/cassandra/data/warehouse/locations-660dbcb0e4a211e6814a9116fc548b6b/mc-1-big-Data.db&#13;\n</pre>\n<p>sstabledump just takes the sstable file and displays its content as json. Before being able to dump an sstable we need to flush the in-memory data into an sstable file using nodetool:</p>\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">&#13;\nnodetool flush warehouse locations&#13;\n</pre>\n<p>This command flushes the table ‘locations’ in the ‘warehouse’ keyspace.</p>\n<p>Now that we’re all setup, let’s have a look at some cases that generate tombstones.</p>\n<h4>Null values creates tombstones</h4>\n<p>An upsert operation can generate a tombstone as well. Why? Because Cassandra doesn’t store ‘null’ values. Null means the absence of data. Cassandra returns a ‘null’ value when there is no value for a field. Therefore when a field is set to null Cassandra needs to delete the existing data.</p>\n<pre class=\"brush: sql; title: ; notranslate\" title=\"\">&#13;\nINSERT INTO movements (&#13;\n  id,&#13;\n  address, &#13;\n  item_id, &#13;\n  quantity,&#13;\n  username&#13;\n) VALUES (&#13;\n  103,&#13;\n  'D3-DJ-21-B-02', &#13;\n  '3600029145',&#13;\n  2,&#13;\n  null&#13;\n);&#13;\n</pre>\n<p>This statements removes any existing username value for the movement identified by the id 103. And how does Cassandra remove data ? Yes, by inserting a tombstone.</p>\n<p><a href=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/movement-tombstone-1.png\"><img src=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/movement-tombstone-1.png\" alt=\"\" width=\"800\" height=\"149\" class=\"aligncenter size-full wp-image-858\" srcset=\"https://www.beyondthelines.net/wp-content/uploads/2017/01/movement-tombstone-1.png 800w, https://www.beyondthelines.net/wp-content/uploads/2017/01/movement-tombstone-1-300x56.png 300w, https://www.beyondthelines.net/wp-content/uploads/2017/01/movement-tombstone-1-768x143.png 768w\" /></a></p>\n<p>This is the corresponding ssltabledump output:</p>\n<pre class=\"brush: jscript; title: ; notranslate\" title=\"\">&#13;\n[&#13;\n  {&#13;\n    \"partition\" : {&#13;\n      \"key\" : [ \"103\" ],&#13;\n      \"position\" : 0&#13;\n    },&#13;\n    \"rows\" : [&#13;\n      {&#13;\n        \"type\" : \"row\",&#13;\n        \"position\" : 18,&#13;\n        \"liveness_info\" : { \"tstamp\" : \"2017-01-27T15:09:50.065224Z\" },&#13;\n        \"cells\" : [&#13;\n          { \"name\" : \"address\", \"value\" : \"D3-DJ-21-B-02\" },&#13;\n          { \"name\" : \"item_d\", \"value\" : \"3600029145\" },&#13;\n          { \"name\" : \"quantity\", \"value\" : \"2\" },&#13;\n          { \"name\" : \"username\", \"deletion_info\" : { \"local_delete_time\" : \"2017-01-27T15:09:50Z\" }&#13;\n        ]&#13;\n      }&#13;\n    ]&#13;\n  }&#13;\n]&#13;\n</pre>\n<p>Cassandra is designed for optimised performance and every operation is written to an append-only log. When a data is removed we can’t removed the existing value from the log, instead a “tombstone” value is inserted in the log. </p>\n<p>Moreover Cassandra doesn’t perform read before write (except for light-weight transactions) as it would be too expensive.</p>\n<p>Therefore when the above insert is executed Cassandra insert a tombstone value for the username field (even if there was no existing data for this key before).</p>\n<p>Now let’s consider the following statement that looks very similar to the previous one:</p>\n<pre class=\"brush: sql; title: ; notranslate\" title=\"\">&#13;\nINSERT INTO movements (&#13;\n  id,&#13;\n  address, &#13;\n  item_id, &#13;\n  quantity&#13;\n) VALUES (&#13;\n  103,&#13;\n  'D3-DJ-21-B-02', &#13;\n  '3600029145',&#13;\n  2&#13;\n);&#13;\n</pre>\n<p>But there is one difference. The first statement creates a tombstone for the username whereas the second statement doesn’t insert anything in that column.</p>\n<p><a href=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/movement-row-1.png\"><img src=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/movement-row-1.png\" alt=\"\" width=\"700\" height=\"195\" class=\"aligncenter size-full wp-image-857\" srcset=\"https://www.beyondthelines.net/wp-content/uploads/2017/01/movement-row-1.png 700w, https://www.beyondthelines.net/wp-content/uploads/2017/01/movement-row-1-300x84.png 300w\" /></a></p>\n<pre class=\"brush: jscript; title: ; notranslate\" title=\"\">&#13;\n[&#13;\n  {&#13;\n    \"partition\" : {&#13;\n      \"key\" : [ \"103\" ],&#13;\n      \"position\" : 0&#13;\n    },&#13;\n    \"rows\" : [&#13;\n      {&#13;\n        \"type\" : \"row\",&#13;\n        \"position\" : 18,&#13;\n        \"liveness_info\" : { \"tstamp\" : \"2017-01-27T15:09:50.065224Z\" },&#13;\n        \"cells\" : [&#13;\n          { \"name\" : \"address\", \"value\" : \"D3-DJ-21-B-02\" },&#13;\n          { \"name\" : \"item_d\", \"value\" : \"3600029145\" },&#13;\n          { \"name\" : \"quantity\", \"value\" : \"2\" }&#13;\n        ]&#13;\n      }&#13;\n    ]&#13;\n  }&#13;\n]&#13;\n</pre>\n<p>If this is the first insert for this key (no previously existing data) then both statements yield to the same state, except that the second one doesn’t insert an unnecessary tombstone.</p>\n<p>If there is existing data then what ends up in the username column might be different. With statement 1 whatever data was there it is deleted with the tombstone and no longer returned. With statement 2 the username remains unchanged so whatever value was there before (if any) will get returned.</p>\n<p><a href=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/movement-upsert-1.png\"><img src=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/movement-upsert-1.png\" alt=\"\" width=\"700\" height=\"245\" class=\"aligncenter size-full wp-image-859\" srcset=\"https://www.beyondthelines.net/wp-content/uploads/2017/01/movement-upsert-1.png 700w, https://www.beyondthelines.net/wp-content/uploads/2017/01/movement-upsert-1-300x105.png 300w\" /></a></p>\n<p>Therefore you should strive to only update the fields that you need to. </p>\n<p>For instance let’s say that I need to update the status of a location. Then I should only update the status field rather than the whole object. That would avoid tombstones for every missing value in the object.</p>\n<figure id=\"attachment_855\" class=\"wp-caption aligncenter\"><a href=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/location-row-1.png\"><img src=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/location-row-1.png\" alt=\"\" width=\"450\" height=\"190\" class=\"size-full wp-image-855\" srcset=\"https://www.beyondthelines.net/wp-content/uploads/2017/01/location-row-1.png 450w, https://www.beyondthelines.net/wp-content/uploads/2017/01/location-row-1-300x127.png 300w\" /></a><figcaption class=\"wp-caption-text\">The ‘properties’ field is not set in the query so no value is stored in Cassandra.</figcaption></figure><p>The following statement is exactly what we need as it only sets the status field:</p>\n<pre class=\"brush: sql; title: ; notranslate\" title=\"\">&#13;\nUPDATE locations SET status = 'damaged' WHERE location_address = 'D3-DJ-21-B-02';&#13;\n</pre>\n<p>as the sstable dump shows</p>\n<pre class=\"brush: jscript; title: ; notranslate\" title=\"\">&#13;\n[&#13;\n  {&#13;\n    \"partition\" : {&#13;\n      \"key\" : [ \"D3-DJ-21-B-02\" ],&#13;\n      \"position\" : 0&#13;\n    },&#13;\n    \"rows\" : [&#13;\n      {&#13;\n        \"type\" : \"row\",&#13;\n        \"position\" : 28,&#13;\n        \"cells\" : [&#13;\n          { \"name\" : \"status\", \"value\" : \"damaged\", \"tstamp\" : \"2017-01-28T11:55:18.146255Z\" }&#13;\n        ]&#13;\n      }&#13;\n    ]&#13;\n  }&#13;\n]&#13;\n</pre>\n<p>Compare it with the following one which saves the whole location object (which happens to not have any properties – and insert an unnecessary tombstone in the ‘properties’ column).</p>\n<pre class=\"brush: sql; title: ; notranslate\" title=\"\">&#13;\nINSERT INTO locations (&#13;\n  address,&#13;\n  status,&#13;\n  properties&#13;\n) VALUES (&#13;\n  'D3-DJ-21-B-02',&#13;\n  'damaged',&#13;\n  null&#13;\n);&#13;\n</pre>\n<figure id=\"attachment_854\" class=\"wp-caption aligncenter\"><a href=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/location-empty-collection-1.png\"><img src=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/location-empty-collection-1.png\" alt=\"\" width=\"500\" height=\"189\" class=\"size-full wp-image-854\" srcset=\"https://www.beyondthelines.net/wp-content/uploads/2017/01/location-empty-collection-1.png 500w, https://www.beyondthelines.net/wp-content/uploads/2017/01/location-empty-collection-1-300x113.png 300w\" /></a><figcaption class=\"wp-caption-text\">An empty collection is stored as a tombstone cell</figcaption></figure><pre class=\"brush: jscript; title: ; notranslate\" title=\"\">&#13;\n[&#13;\n  {&#13;\n    \"partition\" : {&#13;\n      \"key\" : [ \"D3-DJ-21-B-02\" ],&#13;\n      \"position\" : 0&#13;\n    },&#13;\n    \"rows\" : [&#13;\n      {&#13;\n        \"type\" : \"row\",&#13;\n        \"position\" : 18,&#13;\n        \"liveness_info\" : { \"tstamp\" : \"2017-01-28T11:58:59.160898Z\" },&#13;\n        \"cells\" : [&#13;\n          { \"name\" : \"status\", \"value\" : \"damaged\" },&#13;\n          { \"name\" : \"properties\", \"deletion_info\" : { \"marked_deleted\" : \"2017-01-28T11:58:59.160897Z\", \"local_delete_time\" : \"2017-01-28T11:58:59Z\" } }&#13;\n        ]&#13;\n      }&#13;\n    ]&#13;\n  }&#13;\n]&#13;\n</pre>\n<h4>Be aware of the collection types</h4>\n<p>In the previous example the ‘properties’ field is a collection type (most likely a set), so let’s talk about collections as they are trickier than it looks.</p>\n<p>Let’s create a new location with the following statement</p>\n<pre class=\"brush: sql; title: ; notranslate\" title=\"\">&#13;\nINSERT INTO locations (&#13;\n  address,&#13;\n  status,&#13;\n  properties&#13;\n) VALUES (&#13;\n  'C3-BE-52-C-01',&#13;\n  'normal',&#13;\n  {'pickable'}&#13;\n);&#13;\n</pre>\n<p>Everything looks good, doesn’t it? Every field has a value, so no tombstone expected. And yet, this statement does create a tombstone for the ‘properties’ field.</p>\n<pre class=\"brush: jscript; title: ; notranslate\" title=\"\">&#13;\n[&#13;\n  {&#13;\n    \"partition\" : {&#13;\n      \"key\" : [ \"C3-BE-52-C-01\" ],&#13;\n      \"position\" : 0&#13;\n    },&#13;\n    \"rows\" : [&#13;\n      {&#13;\n        \"type\" : \"row\",&#13;\n        \"position\" : 18,&#13;\n        \"liveness_info\" : { \"tstamp\" : \"2017-01-28T12:01:00.256789Z\" },&#13;\n        \"cells\" : [&#13;\n          { \"name\" : \"status\", \"value\" : \"normal\" },&#13;\n          { \"name\" : \"properties\", \"deletion_info\" : { \"marked_deleted\" : \"2017-01-28T12:01:00.256788Z\", \"local_delete_time\" : \"2017-01-28T12:01:00Z\" } },&#13;\n          { \"name\" : \"properties\", \"path\" : [ \"pickable\" ], \"value\" : \"\" }&#13;\n        ]&#13;\n      }&#13;\n    ]&#13;\n  }&#13;\n]&#13;\n</pre>\n<p>To understand why, we need to look at how Cassandra store a collection in the underlying storage.</p>\n<figure id=\"attachment_853\" class=\"wp-caption aligncenter\"><a href=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/location-collection-1.png\"><img src=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/location-collection-1.png\" alt=\"\" width=\"500\" height=\"175\" class=\"size-full wp-image-853\" srcset=\"https://www.beyondthelines.net/wp-content/uploads/2017/01/location-collection-1.png 500w, https://www.beyondthelines.net/wp-content/uploads/2017/01/location-collection-1-300x105.png 300w\" /></a><figcaption class=\"wp-caption-text\">The collection field includes a tombstone cell to empty the collection before adding a value.</figcaption></figure><p>Cassandra appends new values to the set, so when we want the collection to contain only the values passed in the query, we have to remove everything that might have been there before. That’s why Cassandra inserts a tombstone and then our value. This makes sure the set now contains only the ‘pickable’ value whatever was there before.</p>\n<p>That’s one more reason to just set the values you need to update and nothing more.</p>\n<h4>Be careful with materialised views</h4>\n<p>A materialised view is a table that is maintained by Cassandra. One of its main feature is that we can define a different primary key than the one in the base table. You can re-order the fields of the primary key from the base table, but you can also add one extra field into the primary key of the view.</p>\n<p>This is great as it allows to define a different partitioning or clustering but it also generates more tombstones in the view. Let’s consider an example to understand what’s happening.</p>\n<p>Imagine that we need to query the locations by status. For instance we want to retrieve all ‘damaged’ locations. We can create a materialised view to support this use case.</p>\n<pre class=\"brush: sql; title: ; notranslate\" title=\"\">&#13;\nCREATE MATERIALIZED VIEW locations_by_status AS&#13;\n  SELECT&#13;\n    status,&#13;\n    address,&#13;\n    properties&#13;\n  FROM locations&#13;\n  WHERE status IS NOT NULL&#13;\n  AND address IS NOT NULL&#13;\n  PRIMARY KEY (status, address);&#13;\n</pre>\n<p>Good, now we can use this view to find out all the locations with a given status. </p>\n<p>But let’s consider what happens in the view when we change the status of a location with an update query</p>\n<pre class=\"brush: sql; title: ; notranslate\" title=\"\">&#13;\nUPDATE locations&#13;\nSET status = 'damaged'&#13;\nWHERE address = 'C3-BE-52-C-01';&#13;\n</pre>\n<p>As we’ve seen this query just updates one field in the base table (locations) and doesn’t generate any tombstone in this table. However in the materialised view the ‘status’ field is part of the primary key. When the status changes the partition key changes as well.</p>\n<pre class=\"brush: jscript; title: ; notranslate\" title=\"\">&#13;\n[&#13;\n  {&#13;\n    \"partition\" : {&#13;\n      \"key\" : [ \"normal\" ],&#13;\n      \"position\" : 0&#13;\n    },&#13;\n    \"rows\" : [&#13;\n      {&#13;\n        \"type\" : \"row\",&#13;\n        \"position\" : 18,&#13;\n        \"clustering\" : [ \"C3-BE-52-C-01\" ],&#13;\n        \"deletion_info\" : { \"marked_deleted\" : \"2017-01-20T10:34:27.707604Z\", \"local_delete_time\" : \"2017-01-20T10:46:14Z\" },&#13;\n        \"cells\" : [ ]&#13;\n      }&#13;\n    ]&#13;\n  },&#13;\n  {&#13;\n    \"partition\" : {&#13;\n      \"key\" : [ \"damaged\" ],&#13;\n      \"position\" : 31&#13;\n    },&#13;\n    \"rows\" : [&#13;\n      {&#13;\n        \"type\" : \"row\",&#13;\n        \"position\" : 49,&#13;\n        \"clustering\" : [ \"C3-BE-52-C-01\" ],&#13;\n        \"liveness_info\" : { \"tstamp\" : \"2017-01-20T10:46:14.285730Z\" },&#13;\n        \"cells\" : [&#13;\n          { \"name\" : \"properties\", \"deletion_info\" : { \"marked_deleted\" : \"2017-01-20T10:46:14.285729Z\", \"local_delete_time\" : \"2017-01-20T10:46:14Z\" } }&#13;\n        ]&#13;\n      }&#13;\n    ]&#13;\n  }&#13;\n]&#13;\n</pre>\n<p>To maintain the view in sync with the base table Cassandra needs to delete the row from the existing partition and insert a new one into the new partition. And a delete means a tombstone.</p>\n<figure id=\"attachment_856\" class=\"wp-caption aligncenter\"><a href=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/materialized-view-tombstones-1.png\"><img src=\"http://www.beyondthelines.net/wp-content/uploads/2017/01/materialized-view-tombstones-1.png\" alt=\"\" width=\"800\" height=\"398\" class=\"size-full wp-image-856\" srcset=\"https://www.beyondthelines.net/wp-content/uploads/2017/01/materialized-view-tombstones-1.png 800w, https://www.beyondthelines.net/wp-content/uploads/2017/01/materialized-view-tombstones-1-300x149.png 300w, https://www.beyondthelines.net/wp-content/uploads/2017/01/materialized-view-tombstones-1-768x382.png 768w\" /></a><figcaption class=\"wp-caption-text\">The update in the base table triggers a partition change in the materialised view which creates a tombstone to remove the row from the old partition.</figcaption></figure><p>The key thing here is to be thoughtful when designing the primary key of a materialised view (especially when the key contains more fields than the key of the base table). That being said it might be the only solution and completely worth it. </p>\n<p>Also consider the rate of the changes of the fields of the primary key. In our case we should evaluate the rate at which the status changes for a given location (the location address doesn’t change). The less often the better off we are with respect to tombstones.</p>\n<p>Finally tombstones will disappear over time, when compaction occurs. The typical delay is 10 days (which corresponds to the ‘gc_grace_seconds’ configuration parameter). You may want to adjust it if there are too many tombstones generated during this period.</p>\n<h4>Conclusion</h4>\n<p>As we’ve seen tombstones can be tricky and there not only associated to delete operations. There are many other cases that may generate tombstones. </p>\n<p>Tombstones are not necessarily a bad thing that we should avoid at all cost. It’s just a way to delete data in an append-only structure. </p>\n<p>However it can affect performances so you’d better be aware when they are generated when designing your data model and queries. </p>\n<p>If you use the java driver the query fails if more than 100,000 tombstones are seen.</p>\n<p>With this knowledge you should be able to limit their generation only when necessary. In this case you should evaluate how many are going to be generated and evaluate if it’s going to be an issue or not. If so you may want to tune the ‘gc_grace_seconds’ parameter to trigger compaction more often.</p>"}}]}},"pageContext":{"alternative_id":9883}}