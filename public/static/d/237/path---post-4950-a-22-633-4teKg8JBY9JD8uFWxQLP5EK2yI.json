{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Running Cassandra with Linux on Azure and Accessing it from Node.js","alternative_id":4950,"content":"<div class=\"IMPORTANT\" readability=\"8\"><p>Important</p><p>Azure has two different deployment models for creating and working with resources: <a href=\"https://docs.microsoft.com/en-us/azure/resource-manager-deployment-model\" data-linktype=\"relative-path\">Resource Manager and Classic</a>. This article covers using the Classic deployment model. Microsoft recommends that most new deployments use the Resource Manager model. See Resource Manager templates for <a href=\"https://azure.microsoft.com/documentation/templates/datastax\" data-linktype=\"external\">Datastax Enterprise</a> and <a href=\"https://azure.microsoft.com/documentation/templates/spark-and-cassandra-on-centos/\" data-linktype=\"external\">Spark cluster and Cassandra on CentOS</a>.</p>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p>Microsoft Azure is an open cloud platform that runs both Microsoft as well as non-Microsoft software which  includes operating systems, application servers, messaging middleware as well as SQL and NoSQL databases from both commercial and open source models. Building resilient services on public clouds including Azure requires careful planning and deliberate architecture for both applications servers as well storage layers. Cassandra’s distributed storage architecture naturally helps in building highly available systems that are fault tolerant for cluster failures. Cassandra is a cloud scale NoSQL database maintained by Apache Software Foundation at cassandra.apache.org; Cassandra is written in Java and hence runs on both on Windows as well as Linux platforms.</p>\n<p>The focus of this article is to show Cassandra deployment on Ubuntu as a single and multi-data center cluster leveraging Microsoft Azure Virtual Machines and Virtual Networks. The cluster deployment for production optimized workloads is out of scope of this article as it requires multi-disk node configuration, appropriate ring topology design and data modeling to support the needed replication, data consistency, throughput and high availability requirements.</p>\n<p>This article takes a fundamental approach to show what is involved in building the Cassandra cluster compared Docker, Chef or Puppet which can make the infrastructure deployment a lot easier.  </p>\n<h2 id=\"the-deployment-models\">The Deployment Models</h2>\n<p>Microsoft Azure networking allows the deployment of isolated private clusters, the access of which can be restricted to attain fine grained network security.  Since this article is about showing the Cassandra deployment at a fundamental level, we will not focus on the consistency level and the optimal storage design for throughput. Here is the list of networking requirements for our hypothetical cluster:</p>\n<ul><li>External systems can’t access Cassandra database from within or outside Azure</li>\n<li>Cassandra cluster has to be behind a load balancer for thrift traffic</li>\n<li>Deploy Cassandra nodes in two groups in each data center for an enhanced cluster availability</li>\n<li>Lock down the cluster so that only application server farm has access to the database directly</li>\n<li>No public networking endpoints other than SSH</li>\n<li>Each Cassandra node needs a fixed internal IP address</li>\n</ul><p>Cassandra can be deployed to a single Azure region or to multiple regions based on the distributed nature of the workload. Multi-region deployment model can be leveraged to serve end users closer to a particular geography through the same Cassandra infrastructure. Cassandra’s built-in node replication takes care of the synchronization of multi-master writes originating from multiple data centers and presents a consistent view of the data to applications. Multi-region deployment can also help with the risk mitigation of the broader Azure service outages. Cassandra’s tunable consistency and replication topology will help in meeting diverse RPO needs of applications.</p>\n<h3 id=\"single-region-deployment\">Single Region Deployment</h3>\n<p>We will start with a single region deployment and harvest the learnings in creating a multi-region model. Azure virtual networking will be used to create isolated subnets so that the network security requirements mentioned above can be met.  The process described in creating the single region deployment uses Ubuntu 14.04 LTS and Cassandra 2.08; however, the process can easily be adopted to the other Linux variants. The following are some of the systemic characteristics of the single region deployment.  </p>\n<p><strong>High Availability:</strong> The Cassandra nodes shown in the Figure 1 are deployed to two availability sets so that the nodes are spread between multiple fault domains for high availability. VMs annotated with each availability set is mapped to 2 fault domains.  Microsoft Azure uses the concept of fault domain to manage unplanned down time (e.g. hardware or software failures) while the concept of upgrade domain (e.g. host or guest OS patching/upgrades, application upgrades) is used for managing scheduled down time. Please see <a href=\"http://msdn.microsoft.com/library/dn251004.aspx\" data-linktype=\"external\">Disaster Recovery and High Availability for Azure Applications</a> for the role of fault and upgrade domains in attaining high availability.</p>\n<p><img src=\"https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/media/cassandra-nodejs/cassandra-linux1.png\" alt=\"Single region deployment\" data-linktype=\"relative-path\"/></p>\n<p>Figure 1: Single region deployment</p>\n<p>Note that at the time of this writing, Azure doesn’t allow the explicit mapping of a group of VMs to a specific fault domain; consequently, even with the deployment model shown in Figure 1, it is statistically probable that all the virtual machines may be mapped to two fault domains instead of four.</p>\n<p><strong>Load Balancing Thrift Traffic:</strong> Thrift client libraries inside the web server connect to the cluster through an internal load balancer. This requires the process of adding the internal load balancer to the “data” subnet (refer Figure 1) in the context of the cloud service hosting the Cassandra cluster. Once the internal load balancer is defined, each node requires the load balanced endpoint to be added with the annotations of a load balanced set with previously defined load balancer name. See <a href=\"https://docs.microsoft.com/en-us/azure/load-balancer/load-balancer-internal-overview\" data-linktype=\"relative-path\">Azure Internal Load Balancing </a>for more details.</p>\n<p><strong>Cluster Seeds:</strong> It is important to select the most highly available nodes for seeds as the new nodes will communicate with seed nodes to discover the topology of the cluster. One node from each availability set is designated as seed nodes to avoid single point of failure.</p>\n<p><strong>Replication Factor and Consistency Level:</strong> Cassandra’s build-in high-availability and data durability is characterized by the Replication Factor (RF - number of copies of each row stored on the cluster) and Consistency Level (number of replicas to be read/written before returning the result to the caller). Replication factor is specified during the KEYSPACE (similar to a relational database) creation whereas the consistency level is specified while issuing the CRUD query. See Cassandra documentation at <a href=\"http://www.datastax.com/documentation/cassandra/2.0/cassandra/dml/dml_config_consistency_c.html\" data-linktype=\"external\">Configuring for Consistency</a> for consistency details and the formula for quorum computation.</p>\n<p>Cassandra supports two types of data integrity models – Consistency and Eventual Consistency; the Replication Factor and Consistency Level will together determine if the data will be consistent as soon as a write operation is complete or it will be eventually consistent. For example, specifying QUORUM as the Consistency Level will always ensures data Consistency while any consistency level, below the number of replicas to be written as needed to attain QUORUM (e.g. ONE) results in data being eventually consistent.</p>\n<p>The 8-node cluster shown above, with a replication factor of 3 and QUORUM (2 nodes are read or written for consistency) read/write consistency level, can survive the theoretical loss of at the most 1 node per replication group before the application start noticing the failure. This assumes that all the key spaces have well balanced read/write requests.  The following are the parameters we will use for the deployed cluster:</p>\n<p>Single region Cassandra cluster configuration:</p>\n<table><thead><tr><th>Cluster Parameter</th>\n<th>Value</th>\n<th>Remarks</th>\n</tr></thead><tbody readability=\"10\"><tr readability=\"1\"><td>Number of Nodes (N)</td>\n<td>8</td>\n<td>Total number of nodes in the cluster</td>\n</tr><tr readability=\"2\"><td>Replication Factor (RF)</td>\n<td>3</td>\n<td>Number of replicas of a given row</td>\n</tr><tr readability=\"5\"><td>Consistency Level (Write)</td>\n<td>QUORUM[(RF/2) +1) = 2] The result of the formula is rounded down</td>\n<td>Writes at the most 2 replicas before the response is sent to the caller; 3rd replica is written in an eventually consistent manner.</td>\n</tr><tr readability=\"3\"><td>Consistency Level (Read)</td>\n<td>QUORUM [(RF/2) +1= 2] The result of the formula is rounded down</td>\n<td>Reads 2 replicas before sending response to the caller.</td>\n</tr><tr readability=\"5\"><td>Replication Strategy</td>\n<td>NetworkTopologyStrategy see <a href=\"http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureDataDistributeReplication_c.html\" data-linktype=\"external\">Data Replication</a> in Cassandra documentation for more information</td>\n<td>Understands the deployment topology and places replicas on nodes so that all the replicas don’t end up on the same rack</td>\n</tr><tr readability=\"7\"><td>Snitch</td>\n<td>GossipingPropertyFileSnitch see <a href=\"http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureSnitchesAbout_c.html\" data-linktype=\"external\">Snitches</a> in Cassandra documentation for more information</td>\n<td>NetworkTopologyStrategy uses a concept of snitch to understand the topology. GossipingPropertyFileSnitch gives better control in mapping each node to data center and rack. The cluster then uses gossip to propagate this information. This is much simpler in dynamic IP setting relative to PropertyFileSnitch</td>\n</tr></tbody></table><p><strong>Azure Considerations for Cassandra Cluster:</strong> Microsoft Azure Virtual Machines capability uses Azure Blob storage for disk persistence; Azure Storage saves 3 replicas of each disk for high durability. That means each row of data inserted into a Cassandra table is already stored in 3 replicas and hence data consistency is already taken care of even if the Replication Factor (RF) is 1. The main problem with Replication Factor being 1 is that the application will experience downtime even if a single Cassandra node fails. However, if a node is down for the problems (e.g. hardware, system software failures) recognized by Azure Fabric Controller, it will provision a new node in its place using the same storage drives. Provisioning a new node to replace the old one may take a few minutes.  Similarly for planned maintenance activities like guest OS changes, Cassandra upgrades and application changes Azure Fabric Controller performs rolling upgrades of the nodes in the cluster.  Rolling upgrades also may take down a few nodes at a time and hence the cluster may experience brief downtime for a few partitions. However, the data will not be lost due to the built-in Azure Storage redundancy.  </p>\n<p>For systems deployed to Azure that doesn’t require high availability (e.g. around 99.9 which is equivalent to 8.76 hrs/year; see <a href=\"http://en.wikipedia.org/wiki/High_availability\" data-linktype=\"external\">High Availability</a> for details) you may be able to run with RF=1 and Consistency Level=ONE.  For applications with high availability requirements, RF=3 and Consistency Level=QUORUM will tolerate the down time of one of the nodes one of the replicas. RF=1 in traditional deployments (e.g. on-premises) can’t be used due to the possible data loss resulting from problems like disk failures.   </p>\n<h2 id=\"multi-region-deployment\">Multi-region Deployment</h2>\n<p>Cassandra’s data-center-aware replication and consistency model described above helps with the multi-region deployment out of the box without the need for any external tooling. This is quite different from the traditional relational databases where the setup for database mirroring for multi-master writes can be quite complex. Cassandra in a multi-region set up can help with the usage scenarios including the following:</p>\n<p><strong>Proximity based deployment:</strong> Multi-tenant applications, with clear mapping of tenant users -to-region, can be benefited by the multi-region cluster’s low latencies. For example a learning management systems for educational institutions can deploy a distributed cluster in East US and West US regions to serve the respective campuses for transactional as well as analytics. The data can be locally consistent at the time reads and writes and can be eventually consistent across both the regions. There are other examples like media distribution, e-commerce and anything and everything that serves geo concentrated user base is a good use case for this deployment model.</p>\n<p><strong>High Availability:</strong> Redundancy is a key factor in attaining high availability of software and hardware; see Building Reliable Cloud Systems on Microsoft Azure for details. On Microsoft Azure, the only reliable way of achieving true redundancy is by deploying a multi-region cluster. Applications can be deployed in an active-active or active-passive mode and if one of the regions is down, Azure Traffic Manager can redirect traffic to the active region.  With the single region deployment, if the availability is 99.9, a two-region deployment can attain an availability of 99.9999 computed by the formula: (1-(1-0.999) * (1-0.999))*100); see the above paper for details.</p>\n<p><strong>Disaster Recovery:</strong> Multi-region Cassandra cluster, if properly designed, can withstand catastrophic data center outages. If one region is down, the application deployed to other regions can start serving the end users. Like any other business continuity implementations, the application has to be tolerant for some data loss resulting from the data in the asynchronous pipeline. However, Cassandra makes the recovery much swifter than the time taken by traditional database recovery processes. Figure 2 shows the typical multi-region deployment model with eight nodes in each region. Both regions are mirror images of each other for the same of symmetry; real world designs depend on the workload type (e.g. transactional or analytical), RPO, RTO, data consistency and availability requirements.</p>\n<p><img src=\"https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/media/cassandra-nodejs/cassandra-linux2.png\" alt=\"Multi region deployment\" data-linktype=\"relative-path\"/></p>\n<p>Figure 2: Multi-region Cassandra deployment</p>\n<h3 id=\"network-integration\">Network Integration</h3>\n<p>Sets of virtual machines deployed to private networks located on two regions communicates with each other using a VPN tunnel. The VPN tunnel connects two software gateways provisioned during the network deployment process. Both regions have similar network architecture in terms of “web” and “data” subnets; Azure networking allows the creation of as many subnets as needed and apply ACLs as needed by network security. While designing the cluster topology inter data center communication latency and the economic impact of the network traffic need to be considered.</p>\n<h3 id=\"data-consistency-for-multi-data-center-deployment\">Data Consistency for Multi-Data Center Deployment</h3>\n<p>Distributed deployments need to be aware of the cluster topology impact on throughput and high availability. The RF and Consistency Level need to be selected in such way that the quorum doesn’t depend on the availability of all the data centers.\nFor a system that needs high consistency, a LOCAL_QUORUM for consistency level (for reads and writes) will make sure that the local reads and writes are satisfied from the local nodes while data is replicated asynchronously to the remote data centers.  Table 2 summarizes the configuration details for the multi-region cluster outlined later in the write up.</p>\n<p><strong>Two-region Cassandra cluster configuration</strong></p>\n<table><thead><tr><th>Cluster Parameter</th>\n<th>Value</th>\n<th>Remarks</th>\n</tr></thead><tbody readability=\"11\"><tr readability=\"1\"><td>Number of Nodes (N)</td>\n<td>8 + 8</td>\n<td>Total number of nodes in the cluster</td>\n</tr><tr readability=\"2\"><td>Replication Factor (RF)</td>\n<td>3</td>\n<td>Number of replicas of a given row</td>\n</tr><tr readability=\"5\"><td>Consistency Level (Write)</td>\n<td>LOCAL_QUORUM [(sum(RF)/2) +1) = 4] The result of the formula is rounded down</td>\n<td>2 nodes will be written to the first data center synchronously; the additional 2 nodes needed for quorum will be written asynchronously to the 2nd data center.</td>\n</tr><tr readability=\"5\"><td>Consistency Level (Read)</td>\n<td>LOCAL_QUORUM ((RF/2) +1) = 2 The result of the formula is rounded down</td>\n<td>Read requests are satisfied from only one region; 2 nodes are read before the response is sent back to the client.</td>\n</tr><tr readability=\"5\"><td>Replication Strategy</td>\n<td>NetworkTopologyStrategy see <a href=\"http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureDataDistributeReplication_c.html\" data-linktype=\"external\">Data Replication</a> in Cassandra documentation for more information</td>\n<td>Understands the deployment topology and places replicas on nodes so that all the replicas don’t end up on the same rack</td>\n</tr><tr readability=\"7\"><td>Snitch</td>\n<td>GossipingPropertyFileSnitch see <a href=\"http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureSnitchesAbout_c.html\" data-linktype=\"external\">Snitches</a> in Cassandra documentation for more information</td>\n<td>NetworkTopologyStrategy uses a concept of snitch to understand the topology. GossipingPropertyFileSnitch gives better control in mapping each node to data center and rack. The cluster then uses gossip to propagate this information. This is much simpler in dynamic IP setting relative to PropertyFileSnitch</td>\n</tr></tbody></table><h2 id=\"the-software-configuration\">THE SOFTWARE CONFIGURATION</h2>\n<p>The following software versions are used during the deployment:</p>\n<table readability=\"0\"><tr><th>Software</th><th>Source</th><th>Version</th></tr><tr><td>JRE    </td><td><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html\" data-linktype=\"external\">JRE 8</a> </td><td>8U5</td></tr><tr><td>JNA    </td><td><a href=\"https://github.com/twall/jna\" data-linktype=\"external\">JNA</a> </td><td> 3.2.7</td></tr><tr readability=\"0\"><td>Cassandra</td><td><a href=\"http://www.apache.org/dist/cassandra/2.0.8/apache-cassandra-2.0.8-bin.tar.gz\" data-linktype=\"external\">Apache Cassandra 2.0.8</a></td><td> 2.0.8</td></tr><tr><td>Ubuntu    </td><td><a href=\"https://azure.microsoft.com/\" data-linktype=\"external\">Microsoft Azure</a> </td><td>14.04 LTS</td></tr></table><p>Since downloading of JRE requires manual acceptance of Oracle license, to simplify the deployment, download all the required software to the desktop for later uploading into the Ubuntu template image we will be creating as a precursor to the cluster deployment.</p>\n<p>Download the above software into a well-known download directory (e.g. %TEMP%/downloads on Windows or ~/Downloads on most Linux distributions or Mac) on the local computer.</p>\n<h3 id=\"create-ubuntu-vm\">CREATE UBUNTU VM</h3>\n<p>In this step of the process we will create Ubuntu image with the pre-requisite software so that the image can be reused for provisioning several Cassandra nodes.  </p>\n<h4 id=\"step-1-generate-ssh-key-pair\">STEP 1: Generate SSH key pair</h4>\n<p>Azure needs an X509 public key that is either PEM or DER encoded at the provisioning time. Generate a public/private key pair using the instructions located at How to Use SSH with Linux on Azure. If you plan to use putty.exe as an SSH client either on Windows or Linux, you have to convert the PEM encoded RSA private key to PPK format using puttygen.exe; the instructions for this can be found in the above web page.</p>\n<h4 id=\"step-2-create-ubuntu-template-vm\">STEP 2: Create Ubuntu template VM</h4>\n<p>To create the template VM, log into the Azure portal and use the following sequence: Click NEW, COMPUTE, VIRTUAL MACHINE, FROM GALLERY, UBUNTU, Ubuntu Server 14.04 LTS, and then click the right arrow. For a tutorial that describes how to create a Linux VM, see Create a Virtual Machine Running Linux.</p>\n<p>Enter the following information on the “Virtual machine configuration” screen #1:</p>\n<table readability=\"4\"><tr><th>FIELD NAME              </th><td>       FIELD VALUE               </td><td>         REMARKS                </td></tr><tr/><tr readability=\"2\"><td>VERSION RELEASE DATE    </td><td> Select a date from the drop down</td><td/></tr><tr/><tr readability=\"2\"><td>VIRTUAL MACHINE NAME    </td><td> cass-template                   </td><td> This is the hostname of the VM </td></tr><tr/><tr><td>TIER                     </td><td> STANDARD                           </td><td> Leave the default              </td></tr><tr/><tr readability=\"1\"><td>SIZE                     </td><td> A1                              </td><td>Select the VM based on the IO needs; for this purpose leave the default </td></tr><tr/><tr readability=\"1\"><td> NEW USER NAME             </td><td> localadmin                       </td><td> \"admin\" is a reserved user name in Ubuntu 12.xx and after</td></tr><tr/><tr readability=\"1\"><td> AUTHENTICATION         </td><td> Click check box                 </td><td>Check if you want to secure with an SSH key </td></tr><tr/><tr readability=\"2\"><td> CERTIFICATE             </td><td> file name of the public key certificate </td><td> Use the public key generated previously</td></tr><tr/><tr><td> New Password    </td><td> strong password </td><td> </td></tr><tr/><tr><td> Confirm Password    </td><td> strong password </td><td/></tr><tr/></table><p>Enter the following information on the “Virtual machine configuration” screen #2:</p>\n<table readability=\"4\"><tr><th>FIELD NAME             </th><th> FIELD VALUE                       </th><th> REMARKS                                 </th></tr><tr readability=\"2\"><td> CLOUD SERVICE    </td><td> Create a new cloud service    </td><td>Cloud service is a container compute resources like virtual machines</td></tr><tr readability=\"3\"><td> CLOUD SERVICE DNS NAME    </td><td>ubuntu-template.cloudapp.net    </td><td>Give a machine agnostic load balancer name</td></tr><tr readability=\"2\"><td> REGION/AFFINITY GROUP/VIRTUAL NETWORK </td><td>    West US    </td><td> Select a region from which your web applications access the Cassandra cluster</td></tr><tr readability=\"1\"><td>STORAGE ACCOUNT </td><td>    Use default    </td><td>Use the default storage account  or a pre-created storage account in a particular region</td></tr><tr><td>AVAILABILITY SET </td><td>    None </td><td>    Leave it blank</td></tr><tr readability=\"1\"><td>ENDPOINTS    </td><td>Use default </td><td>    Use the default SSH configuration </td></tr></table><p>Click right arrow, leave the defaults on the screen #3 and click the “check” button to complete the VM provisioning process. After a few minutes, the VM with the name “ubuntu-template” should be in a “running” status.</p>\n<h3 id=\"install-the-necessary-software\">INSTALL THE NECESSARY SOFTWARE</h3>\n<p>Using scp or pscp, copy the previously downloaded software to ~/downloads directory using the following command format:</p>\n<h5 id=\"pscp-server-jre-8u5-linux-x64targz-localadminhk-cas-templatecloudappnethomelocaladmindownloadsserver-jre-8u5-linux-x64targz\">pscp server-jre-8u5-linux-x64.tar.gz localadmin@hk-cas-template.cloudapp.net:/home/localadmin/downloads/server-jre-8u5-linux-x64.tar.gz</h5>\n<p>Repeat the above command for JRE as well as for the Cassandra bits.</p>\n<p>Log into the VM and create the directory structure and extract software as a super user using the bash script below:</p>\n<pre>#!/bin/bash\nCASS_INSTALL_DIR=\"/opt/cassandra\"\nJRE_INSTALL_DIR=\"/opt/java\"\nCASS_DATA_DIR=\"/var/lib/cassandra\"\nCASS_LOG_DIR=\"/var/log/cassandra\"\nDOWNLOADS_DIR=\"~/downloads\"\nJRE_TARBALL=\"server-jre-8u5-linux-x64.tar.gz\"\nCASS_TARBALL=\"apache-cassandra-2.0.8-bin.tar.gz\"\nSVC_USER=\"localadmin\"\nRESET_ERROR=1\nMKDIR_ERROR=2\nreset_installation ()\n{\n   rm -rf $CASS_INSTALL_DIR 2&gt; /dev/null\n   rm -rf $JRE_INSTALL_DIR 2&gt; /dev/null\n   rm -rf $CASS_DATA_DIR 2&gt; /dev/null\n   rm -rf $CASS_LOG_DIR 2&gt; /dev/null\n}\nmake_dir ()\n{\n   if [ -z \"$1\" ]\n   then\n      echo \"make_dir: invalid directory name\"\n      exit $MKDIR_ERROR\n   fi\n   if [ -d \"$1\" ]\n   then\n      echo \"make_dir: directory already exists\"\n      exit $MKDIR_ERROR\n   fi\n   mkdir $1 2&gt;/dev/null\n   if [ $? != 0 ]\n   then\n      echo \"directory creation failed\"\n      exit $MKDIR_ERROR\n   fi\n}\nunzip()\n{\n   if [ $# == 2 ]\n   then\n      tar xzf $1 -C $2\n   else\n      echo \"archive error\"\n   fi\n}\nif [ -n \"$1\" ]\nthen\n   SVC_USER=$1\nfi\nreset_installation\nmake_dir $CASS_INSTALL_DIR\nmake_dir $JRE_INSTALL_DIR\nmake_dir $CASS_DATA_DIR\nmake_dir $CASS_LOG_DIR\n#unzip JRE and Cassandra\nunzip $HOME/downloads/$JRE_TARBALL $JRE_INSTALL_DIR\nunzip $HOME/downloads/$CASS_TARBALL $CASS_INSTALL_DIR\n#Change the ownership to the service credentials\nchown -R $SVC_USER:$GROUP $CASS_DATA_DIR\nchown -R $SVC_USER:$GROUP $CASS_LOG_DIR\necho \"edit /etc/profile to add JRE to the PATH\"\necho \"installation is complete\"\n</pre><p>If you paste this script into vim window, make sure to remove the carriage return (‘\\r”) using the following command:</p>\n<pre>tr -d '\\r' &lt;infile.sh &gt;outfile.sh\n</pre><h4 id=\"step-3-edit-etcprofile\">Step 3: Edit etc/profile</h4>\n<p>Append the following at the end:</p>\n<pre>JAVA_HOME=/opt/java/jdk1.8.0_05\nCASS_HOME= /opt/cassandra/apache-cassandra-2.0.8\nPATH=$PATH:$HOME/bin:$JAVA_HOME/bin:$CASS_HOME/bin\nexport JAVA_HOME\nexport CASS_HOME\nexport PATH\n</pre><h4 id=\"step-4-install-jna-for-production-systems\">Step 4: Install JNA for production systems</h4>\n<p>Use the following command sequence:\nThe following command will install jna-3.2.7.jar and jna-platform-3.2.7.jar to /usr/share.java directory\nsudo apt-get install libjna-java</p>\n<p>Create symbolic links in $CASS_HOME/lib directory so that Cassandra startup script can find these jars:</p>\n<pre>ln -s /usr/share/java/jna-3.2.7.jar $CASS_HOME/lib/jna.jar\nln -s /usr/share/java/jna-platform-3.2.7.jar $CASS_HOME/lib/jna-platform.jar\n</pre><h4 id=\"step-5-configure-cassandrayaml\">Step 5: Configure cassandra.yaml</h4>\n<p>Edit cassandra.yaml on each VM to reflect configuration needed by all the virtual machines [we will tweak this during the actual provisioning]:</p>\n<table readability=\"3\"><tr><th>Field Name   </th><th> Value  </th><th>    Remarks </th></tr><tr readability=\"1\"><td>cluster_name </td><td>    “CustomerService”    </td><td> Use the name that reflects your deployment</td></tr><tr><td>listen_address    </td><td>[leave it blank]    </td><td> Delete “localhost” </td></tr><tr><td>rpc_addres   </td><td>[leave it blank]    </td><td> Delete “localhost” </td></tr><tr readability=\"4\"><td>seeds    </td><td>\"10.1.2.4, 10.1.2.6, 10.1.2.8\"    </td><td>List of  all the IP addresses which are designated as seeds.</td></tr><tr readability=\"2\"><td>endpoint_snitch </td><td> org.apache.cassandra.locator.GossipingPropertyFileSnitch </td><td> This is used by the NetworkTopologyStrateg for inferring the data center and the rack of the VM</td></tr></table><h4 id=\"step-6-capture-the-vm-image\">Step 6: Capture the VM image</h4>\n<p>Log into the virtual machine using the hostname (hk-cas-template.cloudapp.net) and the SSH private key previously created. See How to Use SSH with Linux on Azure for details on how to log in using the command ssh or putty.exe.</p>\n<p>Execute the following sequence of actions to capture the image:</p>\n<h5 id=\"1-deprovision\">1. Deprovision</h5>\n<p>Use the command “sudo waagent –deprovision+user” to remove Virtual Machine instance specific information. See for <a href=\"https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/capture-image\" data-linktype=\"relative-path\">How to Capture a Linux Virtual Machine</a> to Use as a Template more details on the image capture process.</p>\n<h5 id=\"2-shutdown-the-vm\">2: Shutdown the VM</h5>\n<p>Make sure that the virtual machine is highlighted and click the SHUTDOWN link from the bottom command bar.</p>\n<h5 id=\"3-capture-the-image\">3: Capture the image</h5>\n<p>Make sure that the virtual machine is highlighted and click the CAPTURE link from the bottom command bar. In the next screen, give an IMAGE NAME (e.g. hk-cas-2-08-ub-14-04-2014071), appropriate IMAGE DESCRIPTION, and click the “check” mark to finish the CAPTURE process.</p>\n<p>This will take a few seconds and the image should be available in MY IMAGES section of the image gallery. The source VM will be automatically deleted after the image is successfully captured. </p>\n<p><strong>Step 1: Create the Virtual Network</strong>\nLog into the Azure portal and create a virtual network (classic) with the attributes shown in the following table. See <a href=\"https://docs.microsoft.com/en-us/azure/virtual-network/virtual-networks-create-vnet-classic-pportal\" data-linktype=\"relative-path\">Create a virtual network (classic) using the Azure portal</a> for detailed steps of the process.      </p>\n<table readability=\"0\"><tr><th>VM Attribute Name</th><th>Value</th><th>Remarks</th></tr><tr><td>Name</td><td>vnet-cass-west-us</td><td/></tr><tr><td>Region</td><td>West US</td><td/></tr><tr readability=\"1\"><td>DNS Servers</td><td>None</td><td>Ignore this as we are not using a DNS Server</td></tr><tr><td>Address Space</td><td>10.1.0.0/16</td><td/></tr><br/><tr><td>Starting IP</td><td>10.1.0.0</td><td/></tr><br/><tr><td>CIDR </td><td>/16 (65531)</td><td/></tr></table><p>Add the following subnets:</p>\n<table readability=\"1\"><tr><th>Name</th><th>Starting IP</th><th>CIDR</th><th>Remarks</th></tr><tr readability=\"1\"><td>web</td><td>10.1.1.0</td><td>/24 (251)</td><td>Subnet for the web farm</td></tr><tr readability=\"1\"><td>data</td><td>10.1.2.0</td><td>/24 (251)</td><td>Subnet for the database nodes</td></tr></table><p>Data and Web subnets can be protected through network security groups the coverage of which is out of scope for this article.  </p>\n<p><strong>Step 2: Provision Virtual Machines</strong>\nUsing the image created previously, we will create the following virtual machines in the cloud server “hk-c-svc-west” and bind them to the respective subnets as shown below:</p>\n<table readability=\"4\"><tr><th>Machine Name    </th><th>Subnet    </th><th>IP Address    </th><th>Availability set</th><th>DC/Rack</th><th>Seed?</th></tr><tr readability=\"1\"><td>hk-c1-west-us    </td><td>data    </td><td>10.1.2.4    </td><td>hk-c-aset-1    </td><td>dc =WESTUS rack =rack1 </td><td>Yes</td></tr><tr readability=\"1\"><td>hk-c2-west-us    </td><td>data    </td><td>10.1.2.5    </td><td>hk-c-aset-1    </td><td>dc =WESTUS rack =rack1    </td><td>No </td></tr><tr readability=\"1\"><td>hk-c3-west-us    </td><td>data    </td><td>10.1.2.6    </td><td>hk-c-aset-1    </td><td>dc =WESTUS rack =rack2    </td><td>Yes</td></tr><tr readability=\"1\"><td>hk-c4-west-us    </td><td>data    </td><td>10.1.2.7    </td><td>hk-c-aset-1    </td><td>dc =WESTUS rack =rack2    </td><td>No </td></tr><tr readability=\"1\"><td>hk-c5-west-us    </td><td>data    </td><td>10.1.2.8    </td><td>hk-c-aset-2    </td><td>dc =WESTUS rack =rack3    </td><td>Yes</td></tr><tr readability=\"1\"><td>hk-c6-west-us    </td><td>data    </td><td>10.1.2.9    </td><td>hk-c-aset-2    </td><td>dc =WESTUS rack =rack3    </td><td>No </td></tr><tr readability=\"1\"><td>hk-c7-west-us    </td><td>data    </td><td>10.1.2.10    </td><td>hk-c-aset-2    </td><td>dc =WESTUS rack =rack4    </td><td>Yes</td></tr><tr readability=\"1\"><td>hk-c8-west-us    </td><td>data    </td><td>10.1.2.11    </td><td>hk-c-aset-2    </td><td>dc =WESTUS rack =rack4    </td><td>No </td></tr><tr><td>hk-w1-west-us    </td><td>web    </td><td>10.1.1.4    </td><td>hk-w-aset-1    </td><td>                       </td><td>N/A</td></tr><tr><td>hk-w2-west-us    </td><td>web    </td><td>10.1.1.5    </td><td>hk-w-aset-1    </td><td>                       </td><td>N/A</td></tr></table><p>Creation of the above list of VMs requires the following process:</p>\n<ol><li>Create an empty cloud service in a particular region</li>\n<li>Create a VM from the previously captured image and attach it to the virtual network created previously; repeat this for all the VMs</li>\n<li>Add an internal load balancer to the cloud service and attach it to the “data” subnet</li>\n<li>For each VM created previously, add a load balanced endpoint for thrift traffic through a load balanced set connected to the previously created internal load balancer</li>\n</ol><p>The above process can be executed using Azure classic portal; use a Windows machine (use a VM on Azure if you don't have access to a Windows machine), use the following PowerShell script to provision all 8 VMs automatically.</p>\n<p><strong>List 1: PowerShell script for provisioning virtual machines</strong></p>\n<pre>    #Tested with Azure Powershell - November 2014\n    #This powershell script deployes a number of VMs from an existing image inside an Azure region\n    #Import your Azure subscription into the current Powershell session before proceeding\n    #The process: 1. create Azure Storage account, 2. create virtual network, 3.create the VM template, 2. crate a list of VMs from the template\n    #fundamental variables - change these to reflect your subscription\n    $country=\"us\"; $region=\"west\"; $vnetName = \"your_vnet_name\";$storageAccount=\"your_storage_account\"\n    $numVMs=8;$prefix = \"hk-cass\";$ilbIP=\"your_ilb_ip\"\n    $subscriptionName = \"Azure_subscription_name\";\n    $vmSize=\"ExtraSmall\"; $imageName=\"your_linux_image_name\"\n    $ilbName=\"ThriftInternalLB\"; $thriftEndPoint=\"ThriftEndPoint\"\n    #generated variables\n    $serviceName = \"$prefix-svc-$region-$country\"; $azureRegion = \"$region $country\"\n    $vmNames = @()\n    for ($i=0; $i -lt $numVMs; $i++)\n    {\n       $vmNames+=(\"$prefix-vm\"+($i+1) + \"-$region-$country\" );\n    }\n    #select an Azure subscription already imported into Powershell session\n    Select-AzureSubscription -SubscriptionName $subscriptionName -Current\n    Set-AzureSubscription -SubscriptionName $subscriptionName -CurrentStorageAccountName $storageAccount\n    #create an empty cloud service\n    New-AzureService -ServiceName $serviceName -Label \"hkcass$region\" -Location $azureRegion\n    Write-Host \"Created $serviceName\"\n    $VMList= @()   # stores the list of azure vm configuration objects\n    #create the list of VMs\n    foreach($vmName in $vmNames)\n    {\n       $VMList += New-AzureVMConfig -Name $vmName -InstanceSize ExtraSmall -ImageName $imageName |\n       Add-AzureProvisioningConfig -Linux -LinuxUser \"localadmin\" -Password \"Local123\" |\n       Set-AzureSubnet \"data\"\n    }\n    New-AzureVM -ServiceName $serviceName -VNetName $vnetName -VMs $VMList\n    #Create internal load balancer\n    Add-AzureInternalLoadBalancer -ServiceName $serviceName -InternalLoadBalancerName $ilbName -SubnetName \"data\" -StaticVNetIPAddress \"$ilbIP\"\n    Write-Host \"Created $ilbName\"\n    #Add add the thrift endpoint to the internal load balancer for all the VMs\n    foreach($vmName in $vmNames)\n    {\n        Get-AzureVM -ServiceName $serviceName -Name $vmName |\n            Add-AzureEndpoint -Name $thriftEndPoint -LBSetName \"ThriftLBSet\" -Protocol tcp -LocalPort 9160 -PublicPort 9160 -ProbePort 9160 -ProbeProtocol tcp -ProbeIntervalInSeconds 10 -InternalLoadBalancerName $ilbName |\n            Update-AzureVM\n        Write-Host \"created $vmName\"     \n    }\n</pre><p><strong>Step 3: Configure Cassandra on each VM</strong></p>\n<p>Log into the VM and perform the following:</p>\n<ul readability=\"4\"><li readability=\"3\"><p>Edit $CASS_HOME/conf/cassandra-rackdc.properties to specify the data center and rack properties:</p>\n<pre> dc =EASTUS, rack =rack1\n</pre></li>\n<li readability=\"5\"><p>Edit cassandra.yaml to configure seed nodes as below:</p>\n<pre> Seeds: \"10.1.2.4,10.1.2.6,10.1.2.8,10.1.2.10\"\n</pre></li>\n</ul><p><strong>Step 4: Start the VMs and test the cluster</strong></p>\n<p>Log into one of the nodes (e.g. hk-c1-west-us) and run the following command to see the status of the cluster:</p>\n<pre>   nodetool –h 10.1.2.4 –p 7199 status\n</pre><p>You should see the display similar to the one below for an 8-node cluster:</p>\n<table><tr><th>Status</th><th>Address    </th><th>Load    </th><th>Tokens    </th><th>Owns </th><th>Host ID    </th><th>Rack</th></tr><tr><th>UN    </th><td>10.1.2.4     </td><td>87.81 KB    </td><td>256    </td><td>38.0%    </td><td>Guid (removed)</td><td>rack1</td></tr><tr><th>UN    </th><td>10.1.2.5     </td><td>41.08 KB    </td><td>256    </td><td>68.9%    </td><td>Guid (removed)</td><td>rack1</td></tr><tr><th>UN    </th><td>10.1.2.6     </td><td>55.29 KB    </td><td>256    </td><td>68.8%    </td><td>Guid (removed)</td><td>rack2</td></tr><tr><th>UN    </th><td>10.1.2.7     </td><td>55.29 KB    </td><td>256    </td><td>68.8%    </td><td>Guid (removed)</td><td>rack2</td></tr><tr><th>UN    </th><td>10.1.2.8     </td><td>55.29 KB    </td><td>256    </td><td>68.8%    </td><td>Guid (removed)</td><td>rack3</td></tr><tr><th>UN    </th><td>10.1.2.9     </td><td>55.29 KB    </td><td>256    </td><td>68.8%    </td><td>Guid (removed)</td><td>rack3</td></tr><tr><th>UN    </th><td>10.1.2.10     </td><td>55.29 KB    </td><td>256    </td><td>68.8%    </td><td>Guid (removed)</td><td>rack4</td></tr><tr><th>UN    </th><td>10.1.2.11     </td><td>55.29 KB    </td><td>256    </td><td>68.8%    </td><td>Guid (removed)</td><td>rack4</td></tr></table><p>Use the following steps to test the cluster:</p>\n<ol readability=\"9\"><li>Using the Powershell command Get-AzureInternalLoadbalancer commandlet, obtain the IP address of the internal load balancer (e.g.  10.1.2.101). The syntax of the command is shown below: Get-AzureLoadbalancer –ServiceName \"hk-c-svc-west-us” [displays the details of the internal load balancer along with its IP address]</li>\n<li>Log into the web farm VM (e.g. hk-w1-west-us) using Putty or ssh</li>\n<li>Execute $CASS_HOME/bin/cqlsh 10.1.2.101 9160</li>\n<li readability=\"19\"><p>Use the following CQL commands to verify if the cluster is working:</p>\n<p>  CREATE KEYSPACE customers_ks WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 3 };\n  USE customers_ks;\n  CREATE TABLE Customers(customer_id int PRIMARY KEY, firstname text, lastname text);\n  INSERT INTO Customers(customer_id, firstname, lastname) VALUES(1, 'John', 'Doe');\n  INSERT INTO Customers(customer_id, firstname, lastname) VALUES (2, 'Jane', 'Doe');</p>\n<p>  SELECT * FROM Customers;</p>\n</li>\n</ol><p>You should see a display like the one below:</p>\n<table><tr><th> customer_id </th><th> firstname </th><th> lastname </th></tr><tr><td> 1 </td><td> John </td><td> Doe </td></tr><tr><td> 2 </td><td> Jane </td><td> Doe </td></tr></table><p>Please note that the keyspace created in step 4 uses SimpleStrategy with a  replication_factor of 3. SimpleStrategy is recommended for single data center deployments whereas NetworkTopologyStrategy for multi-data center deployments. A replication_factor of 3 will give tolerance for node failures.</p>\n<h2 id=\"a-idtworegion-amulti-region-deployment-process\"><a id=\"tworegion\"> </a>Multi-Region Deployment Process</h2>\n<p>Will leverage the single region deployment completed and repeat the same process for installing the second region. The key difference between the single and multiple region deployment is the VPN tunnel setup for inter-region communication; we will start with the network installation, provision the VMs and configure Cassandra.</p>\n<h3 id=\"step-1-create-the-virtual-network-at-the-2nd-region\">Step 1: Create the Virtual Network at the 2nd Region</h3>\n<p>Log into the Azure classic portal and create a Virtual Network with the attributes show in the table. See <a href=\"https://docs.microsoft.com/en-us/azure/virtual-network/virtual-networks-create-vnet-classic-pportal\" data-linktype=\"relative-path\">Configure a Cloud-Only Virtual Network in the Azure classic portal</a> for detailed steps of the process.      </p>\n<table readability=\"1\"><tr><th>Attribute Name    </th><th>Value    </th><th>Remarks</th></tr><tr><td>Name    </td><td>vnet-cass-east-us</td><td/></tr><tr><td>Region    </td><td>East US</td><td/></tr><tr readability=\"1\"><td>DNS Servers        </td><td/><td>Ignore this as we are not using a DNS Server</td></tr><tr readability=\"1\"><td>Configure a point-to-site VPN</td><td/><td>        Ignore this</td></tr><tr readability=\"1\"><td>Configure a site-to-site VPN</td><td/><td>        Ignore this</td></tr><tr><td>Address Space    </td><td>10.2.0.0/16</td><td/></tr><tr><td>Starting IP    </td><td>10.2.0.0    </td><td/></tr><tr><td>CIDR    </td><td>/16 (65531)</td><td/></tr></table><p>Add the following subnets:</p>\n<table readability=\"1\"><tr><th>Name    </th><th>Starting IP    </th><th>CIDR    </th><th>Remarks</th></tr><tr readability=\"1\"><td>web    </td><td>10.2.1.0    </td><td>/24 (251)    </td><td>Subnet for the web farm</td></tr><tr readability=\"1\"><td>data    </td><td>10.2.2.0    </td><td>/24 (251)    </td><td>Subnet for the database nodes</td></tr></table><h3 id=\"step-2-create-local-networks\">Step 2: Create Local Networks</h3>\n<p>A Local Network in Azure virtual networking is a proxy address space that maps to a remote site including a private cloud or another Azure region. This proxy address space is bound to a remote gateway for routing network to the right networking destinations. See <a href=\"https://docs.microsoft.com/en-us/azure/vpn-gateway/virtual-networks-configure-vnet-to-vnet-connection\" data-linktype=\"relative-path\">Configure a VNet to VNet Connection</a> for the instructions on establishing VNET-to-VNET connection.</p>\n<p>Create two local networks per the following details:</p>\n<table><thead><tr><th>Network Name</th>\n<th>VPN Gateway Address</th>\n<th>Address Space</th>\n<th>Remarks</th>\n</tr></thead><tbody readability=\"5\"><tr readability=\"6\"><td>hk-lnet-map-to-east-us</td>\n<td>23.1.1.1</td>\n<td>10.2.0.0/16</td>\n<td>While creating the Local Network give a placeholder gateway address. The real gateway address is filled once the gateway is created. Make sure the address space exactly matches the respective remote VNET; in this case the VNET created in the East US region.</td>\n</tr><tr readability=\"6\"><td>hk-lnet-map-to-west-us</td>\n<td>23.2.2.2</td>\n<td>10.1.0.0/16</td>\n<td>While creating the Local Network give a placeholder gateway address. The real gateway address is filled once the gateway is created. Make sure the address space exactly matches the respective remote VNET; in this case the VNET created in the West US region.</td>\n</tr></tbody></table><h3 id=\"step-3-map-local-network-to-the-respective-vnets\">Step 3: Map “Local” network to the respective VNETs</h3>\n<p>From the Azure classic portal, select each vnet, click “Configure”, check “Connect to the local network”, and select the Local Networks per the following details:</p>\n<table><thead><tr><th>Virtual Network</th>\n<th>Local Network</th>\n</tr></thead><tbody readability=\"1\"><tr readability=\"1\"><td>hk-vnet-west-us</td>\n<td>hk-lnet-map-to-east-us</td>\n</tr><tr readability=\"1\"><td>hk-vnet-east-us</td>\n<td>hk-lnet-map-to-west-us</td>\n</tr></tbody></table><h3 id=\"step-4-create-gateways-on-vnet1-and-vnet2\">Step 4: Create Gateways on VNET1 and VNET2</h3>\n<p>From the dashboard of both the virtual networks, click CREATE GATEWAY which will trigger the VPN gateway provisioning process. After a few minutes the dashboard of each virtual network should display the actual gateway address.</p>\n<p>Edit both the local networks to replace the placeholder gateway IP address with the real IP address of the just provisioned gateways. Use the following mapping:</p>\n<table readability=\"2\"><tr><th>Local Network    </th><th>Virtual Network Gateway</th></tr><tr readability=\"2\"><td>hk-lnet-map-to-east-us </td><td>Gateway of hk-vnet-west-us</td></tr><tr readability=\"2\"><td>hk-lnet-map-to-west-us </td><td>Gateway of hk-vnet-east-us</td></tr></table><p>Use the following Powershell script to update the IPSec key of each VPN gateway [use the sake key for both the gateways]:\nSet-AzureVNetGatewayKey -VNetName hk-vnet-east-us -LocalNetworkSiteName hk-lnet-map-to-west-us -SharedKey D9E76BKK\nSet-AzureVNetGatewayKey -VNetName hk-vnet-west-us -LocalNetworkSiteName hk-lnet-map-to-east-us -SharedKey D9E76BKK</p>\n<h3 id=\"step-7-establish-the-vnet-to-vnet-connection\">Step 7: Establish the VNET-to-VNET connection</h3>\n<p>From the Azure classic portal, use the “DASHBOARD” menu of both the virtual networks to establish gateway-to-gateway connection. Use the “CONNECT” menu items in the bottom toolbar. After a few minutes the dashboard should display the connection details graphically.</p>\n<h3 id=\"step-8-create-the-virtual-machines-in-region-2\">Step 8: Create the virtual machines in region #2</h3>\n<p>Create the Ubuntu image as described in region #1 deployment by following the same steps or copy the image VHD file to the Azure storage account located in region #2 and create the image. Use this image and create the following list of virtual machines into a new cloud service hk-c-svc-east-us:</p>\n<table><thead><tr><th>Machine Name</th>\n<th>Subnet</th>\n<th>IP Address</th>\n<th>Availability set</th>\n<th>DC/Rack</th>\n<th>Seed?</th>\n</tr></thead><tbody readability=\"3\"><tr readability=\"1\"><td>hk-c1-east-us</td>\n<td>data</td>\n<td>10.2.2.4</td>\n<td>hk-c-aset-1</td>\n<td>dc =EASTUS rack =rack1</td>\n<td>Yes</td>\n</tr><tr readability=\"1\"><td>hk-c2-east-us</td>\n<td>data</td>\n<td>10.2.2.5</td>\n<td>hk-c-aset-1</td>\n<td>dc =EASTUS rack =rack1</td>\n<td>No</td>\n</tr><tr readability=\"1\"><td>hk-c3-east-us</td>\n<td>data</td>\n<td>10.2.2.6</td>\n<td>hk-c-aset-1</td>\n<td>dc =EASTUS rack =rack2</td>\n<td>Yes</td>\n</tr><tr readability=\"1\"><td>hk-c5-east-us</td>\n<td>data</td>\n<td>10.2.2.8</td>\n<td>hk-c-aset-2</td>\n<td>dc =EASTUS rack =rack3</td>\n<td>Yes</td>\n</tr><tr readability=\"1\"><td>hk-c6-east-us</td>\n<td>data</td>\n<td>10.2.2.9</td>\n<td>hk-c-aset-2</td>\n<td>dc =EASTUS rack =rack3</td>\n<td>No</td>\n</tr><tr readability=\"1\"><td>hk-c7-east-us</td>\n<td>data</td>\n<td>10.2.2.10</td>\n<td>hk-c-aset-2</td>\n<td>dc =EASTUS rack =rack4</td>\n<td>Yes</td>\n</tr><tr readability=\"1\"><td>hk-c8-east-us</td>\n<td>data</td>\n<td>10.2.2.11</td>\n<td>hk-c-aset-2</td>\n<td>dc =EASTUS rack =rack4</td>\n<td>No</td>\n</tr><tr><td>hk-w1-east-us</td>\n<td>web</td>\n<td>10.2.1.4</td>\n<td>hk-w-aset-1</td>\n<td>N/A</td>\n<td>N/A</td>\n</tr><tr><td>hk-w2-east-us</td>\n<td>web</td>\n<td>10.2.1.5</td>\n<td>hk-w-aset-1</td>\n<td>N/A</td>\n<td>N/A</td>\n</tr></tbody></table><p>Follow the same instructions as region #1 but use 10.2.xxx.xxx address space.</p>\n<h3 id=\"step-9-configure-cassandra-on-each-vm\">Step 9: Configure Cassandra on each VM</h3>\n<p>Log into the VM and perform the following:</p>\n<ol><li>Edit $CASS_HOME/conf/cassandra-rackdc.properties to specify the data center and rack properties in the format:\n dc =EASTUS\n rack =rack1</li>\n<li>Edit cassandra.yaml to configure seed nodes:\n Seeds: \"10.1.2.4,10.1.2.6,10.1.2.8,10.1.2.10,10.2.2.4,10.2.2.6,10.2.2.8,10.2.2.10\"</li>\n</ol><h3 id=\"step-10-start-cassandra\">Step 10: Start Cassandra</h3>\n<p>Log into each VM and start Cassandra in the background by running the following command:\n$CASS_HOME/bin/cassandra</p>\n<h2 id=\"test-the-multi-region-cluster\">Test the Multi-Region Cluster</h2>\n<p>By now Cassandra has been deployed to 16 nodes with 8 nodes in each Azure region. These nodes are in the same cluster by virtue of the common cluster name and the seed node configuration. Use the following process to test the cluster:</p>\n<ul readability=\"1\"><li>Get-AzureInternalLoadbalancer -ServiceName \"hk-c-svc-west-us\"</li>\n<li readability=\"3\"><p>Get-AzureInternalLoadbalancer -ServiceName \"hk-c-svc-east-us\"  </p>\n<p>  Note the IP addresses (e.g. west - 10.1.2.101, east - 10.2.2.101) displayed.</p>\n</li>\n</ul><h3 id=\"step-2-execute-the-following-in-the-west-region-after-logging-into-hk-w1-west-us\">Step 2: Execute the following in the west region after logging into hk-w1-west-us</h3>\n<ol readability=\"9\"><li>Execute $CASS_HOME/bin/cqlsh 10.1.2.101 9160</li>\n<li readability=\"19\"><p>Execute the following CQL commands:</p>\n<p>  CREATE KEYSPACE customers_ks\n  WITH REPLICATION = { 'class' : 'NetworkToplogyStrategy', 'WESTUS' : 3, 'EASTUS' : 3};\n  USE customers_ks;\n  CREATE TABLE Customers(customer_id int PRIMARY KEY, firstname text, lastname text);\n  INSERT INTO Customers(customer_id, firstname, lastname) VALUES(1, 'John', 'Doe');\n  INSERT INTO Customers(customer_id, firstname, lastname) VALUES (2, 'Jane', 'Doe');\n  SELECT * FROM Customers;</p>\n</li>\n</ol><p>You should see a display like the one below:</p>\n<table><thead><tr><th>customer_id</th>\n<th>firstname</th>\n<th>Lastname</th>\n</tr></thead><tbody><tr><td>1</td>\n<td>John</td>\n<td>Doe</td>\n</tr><tr><td>2</td>\n<td>Jane</td>\n<td>Doe</td>\n</tr></tbody></table><h3 id=\"step-3-execute-the-following-in-the-east-region-after-logging-into-hk-w1-east-us\">Step 3: Execute the following in the east region after logging into hk-w1-east-us:</h3>\n<ol readability=\"7\"><li>Execute $CASS_HOME/bin/cqlsh 10.2.2.101 9160</li>\n<li readability=\"15\"><p>Execute the following CQL commands:</p>\n<p>  USE customers_ks;\n  CREATE TABLE Customers(customer_id int PRIMARY KEY, firstname text, lastname text);\n  INSERT INTO Customers(customer_id, firstname, lastname) VALUES(1, 'John', 'Doe');\n  INSERT INTO Customers(customer_id, firstname, lastname) VALUES (2, 'Jane', 'Doe');\n  SELECT * FROM Customers;</p>\n</li>\n</ol><p>You should see the same display as seen for the West region:</p>\n<table><thead><tr><th>customer_id</th>\n<th>firstname</th>\n<th>Lastname</th>\n</tr></thead><tbody><tr><td>1</td>\n<td>John</td>\n<td>Doe</td>\n</tr><tr><td>2</td>\n<td>Jane</td>\n<td>Doe</td>\n</tr></tbody></table><p>Execute a few more inserts and see that those get replicated to west-us part of the cluster.</p>\n<h2 id=\"test-cassandra-cluster-from-nodejs\">Test Cassandra Cluster from Node.js</h2>\n<p>Using one of the Linux VMs crated in the \"web\" tier previously, we will execute a simple Node.js script to read the previously inserted data</p>\n<p><strong>Step 1: Install Node.js and Cassandra Client</strong></p>\n<ol readability=\"20\"><li>Install Node.js and npm</li>\n<li>Install node package \"cassandra-client\" using npm</li>\n<li readability=\"43\"><p>Execute the following script at the shell prompt which displays the json string of the retrieved data:</p>\n<pre> var pooledCon = require('cassandra-client').PooledConnection;\n var ksName = \"custsupport_ks\";\n var cfName = \"customers_cf\";\n var hostList = ['internal_loadbalancer_ip:9160'];\n var ksConOptions = { hosts: hostList,\n                      keyspace: ksName, use_bigints: false };\n function createKeyspace(callback){\n    var cql = 'CREATE KEYSPACE ' + ksName + ' WITH strategy_class=SimpleStrategy AND strategy_options:replication_factor=1';\n    var sysConOptions = { hosts: hostList,  \n                          keyspace: 'system', use_bigints: false };\n    var con = new pooledCon(sysConOptions);\n    con.execute(cql,[],function(err) {\n    if (err) {\n      console.log(\"Failed to create Keyspace: \" + ksName);\n      console.log(err);\n    }\n    else {\n      console.log(\"Created Keyspace: \" + ksName);\n      callback(ksConOptions, populateCustomerData);\n    }\n    });\n    con.shutdown();\n }\n function createColumnFamily(ksConOptions, callback){\n   var params = ['customers_cf','custid','varint','custname',\n                 'text','custaddress','text'];\n   var cql = 'CREATE COLUMNFAMILY ? (? ? PRIMARY KEY,? ?, ? ?)';\n var con =  new pooledCon(ksConOptions);\n   con.execute(cql,params,function(err) {\n       if (err) {\n          console.log(\"Failed to create column family: \" + params[0]);\n          console.log(err);\n       }\n       else {\n          console.log(\"Created column family: \" + params[0]);\n          callback();\n       }\n   });\n   con.shutdown();\n }\n //populate Data\n function populateCustomerData() {\n    var params = ['John','Infinity Dr, TX', 1];\n    updateCustomer(ksConOptions,params);\n    params = ['Tom','Fermat Ln, WA', 2];\n    updateCustomer(ksConOptions,params);\n }\n //update will also insert the record if none exists\n function updateCustomer(ksConOptions,params)\n {\n   var cql = 'UPDATE customers_cf SET custname=?,custaddress=? where custid=?';\n   var con = new pooledCon(ksConOptions);\n   con.execute(cql,params,function(err) {\n       if (err) console.log(err);\n       else console.log(\"Inserted customer : \" + params[0]);\n   });\n   con.shutdown();\n }\n //read the two rows inserted above\n function readCustomer(ksConOptions)\n {\n   var cql = 'SELECT * FROM customers_cf WHERE custid IN (1,2)';\n   var con = new pooledCon(ksConOptions);\n   con.execute(cql,[],function(err,rows) {\n       if (err)\n          console.log(err);\n       else\n          for (var i=0; i&lt;rows.length; i++)\n             console.log(JSON.stringify(rows[i]));\n     });\n    con.shutdown();\n }\n //exectue the code\n createKeyspace(createColumnFamily);\n readCustomer(ksConOptions)\n</pre></li>\n</ol><h2 id=\"conclusion\">Conclusion</h2>\n<p>Microsoft Azure is a flexible platform that allows the running of both Microsoft as well as open source software as demonstrated by this exercise. Highly available Cassandra clusters can be deployed on a single data center through the spreading of the cluster nodes across multiple fault domains. Cassandra clusters can also be deployed across multiple geographically distant Azure regions for disaster proof systems. Azure and Cassandra together enables the construction of highly scalable, highly available and disaster recoverable cloud services needed by today's internet scale services.  </p>\n<h2 id=\"references\">References</h2>\n<ul><li><a href=\"http://cassandra.apache.org\" data-linktype=\"external\">http://cassandra.apache.org</a></li>\n<li><a href=\"http://www.datastax.com\" data-linktype=\"external\">http://www.datastax.com</a></li>\n<li><a href=\"http://www.nodejs.org\" data-linktype=\"external\">http://www.nodejs.org</a></li>\n</ul>"}}]}},"pageContext":{"alternative_id":4950}}