{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Building a Custom Spark Connector for Near Real-Time Speech-to-Text Transcription - Developer Blog","alternative_id":11604,"content":"<img src=\"https://www.microsoft.com/developerblog//wp-content/uploads/fortis-radio-to-text-spark-450x300.png\" alt=\"image\" /><p>The <a href=\"http://aka.ms/fortis\">Fortis project</a> is a social data ingestion, analysis, and visualization platform. Originally developed in collaboration with the <a href=\"https://www.unocha.org/\">United Nations Office for the Coordination of Humanitarian Affairs</a> (UN OCHA), Fortis provides planners and scientists with tools to gain insight from social media, public websites and custom data sources.  UN OCHA mobilizes humanitarian aid for crises such as famines, epidemics, and war.</p><p>To understand crisis situations and formulate appropriate mitigations, UN OCHA needs access to tremendous amounts of data and intelligence, from a wide range of sources including newspapers, social media, and radio.</p><p>Fortis already has support for social media and web content, but UN OCHA wanted to be able to incorporate content from local radio broadcasts. Working together, we created a solution based on Spark Streaming to extract textual information from radio in near real-time by developing a new <a href=\"https://github.com/CatalystCode/SpeechToText-WebSockets-Java/\">Java client</a> for Azure Cognitive Services’ speech-to-text APIs. This code story delves into our Fortis solution by providing examples of Spark Streaming custom receivers needed to consume Azure Cognitive Service’s speech-to-text API and showing how to integrate with Azure Cognitive Service’s speech-to-text protocol.</p><h2>A Spark Streaming pipeline for analyzing radio</h2><p>We covered the Fortis pipeline in a <a href=\"https://www.microsoft.com/developerblog/2017/05/10/graphql-providing-context-into-global-crisiss-and-social-public-data-sources/\">previous code story</a>. Below is a brief summary of the pipeline:</p><ol><li>Real-time data sources (such as Facebook, Twitter, and news feeds) generate events</li><li>Events are filtered and analyzed by Spark Streaming</li><li>Spark stores events and aggregations in Cassandra for reporting uses</li></ol><p>A NodeJS and GraphQL services layer sends the data from Cassandra to a ReactJS dashboard.</p><p><img class=\"alignnone size-large wp-image-4891\" src=\"https://codestoryedge.azureedge.net/developerblog/wp-content/uploads/radio-codestory-fortis-diagram-1024x447.png\" alt=\"Overview of the Fortis pipeline\" width=\"780\" height=\"340\" srcset=\"https://www.microsoft.com/developerblog//wp-content/uploads/radio-codestory-fortis-diagram-1024x447.png 1024w, https://www.microsoft.com/developerblog//wp-content/uploads/radio-codestory-fortis-diagram-300x131.png 300w, https://www.microsoft.com/developerblog//wp-content/uploads/radio-codestory-fortis-diagram-768x335.png 768w\" /></p><p>To add radio analysis to this pipeline, we made three simplifying assumptions:</p><ul><li>The raw radio stream is freely accessible on the web via HTTP</li><li>The content published via the radio stream can be discretized into short segments</li><li>The radio content can be meaningfully analyzed via its textual transcription</li></ul><p>Once framed in this way, we see that we need two pieces to ingest radio into a Spark Streaming pipeline:</p><ol><li>A mechanism to get transcribed radio content into our Spark cluster for processing via our text-based analyses <a href=\"https://www.microsoft.com/developerblog/2017/05/10/graphql-providing-context-into-global-crisiss-and-social-public-data-sources/\">as described in a previous code story</a></li><li>A process to receive audio from a radio feed (such as the <a href=\"http://bbcwssc.ic.llnwd.net/stream/bbcwssc_mp1_ws-einws\">BBC World Service</a> or Radio France International) and convert it to text</li></ol><p>The following sections will cover each of these pieces.</p><h2>Consuming arbitrary APIs via Spark Streaming custom receivers</h2><p>Spark’s <a href=\"https://spark.apache.org/docs/latest/streaming-custom-receivers.html\">custom receivers</a> are a powerful mechanism to turn APIs into real-time data sources for Spark Streaming. A custom receiver needs to implement just a few methods. For example, in Scala:</p><p>After we define our custom receiver, we can now turn its underlying data source into a Spark stream that is easy to consume via the usual high-level Spark APIs:</p><p>We make heavy use of custom receivers in the Fortis project as a simple way to turn APIs into streaming data-sources. Fortis has published packages to integrate with the <a href=\"https://github.com/CatalystCode/streaming-facebook\">Facebook API</a>, <a href=\"https://github.com/CatalystCode/streaming-reddit\">Reddit API</a>, <a href=\"https://github.com/CatalystCode/streaming-instagram\">Instagram API</a>, <a href=\"https://github.com/CatalystCode/streaming-bing\">Bing News API</a> and <a href=\"https://github.com/CatalystCode/streaming-rss-html\">RSS feeds</a>. Similarly, the radio-to-text functionality described below is wrapped in a <a href=\"https://github.com/CatalystCode/project-fortis-spark/tree/f2b8d2dec955c5f78eed00ff884a86a40b5b255b/src/main/scala/com/microsoft/partnercatalyst/fortis/spark/sources/streamwrappers/radio\">custom radio receiver</a> to integrate it into our Spark pipeline.</p><h2>Converting radio to text in near real-time</h2><p>After solving the problem of how to integrate custom data sources into Spark, we next require a solution to convert a stream of audio, such as from an online radio broadcast, to a stream of text.</p><p>Azure Cognitive Services has been offering speech-to-text capabilities for more than 10 languages for a long time via the <a href=\"https://azure.microsoft.com/en-ca/services/cognitive-services/speech/\">Bing Speech API</a>. However, the API is based on a request-response paradigm which is not suited to our streaming use case as it would require us to buffer large audio clips in the radio receiver, send the chunks to the speech-to-text service and wait for a transcribed response. This approach would introduce latency and HTTP request overhead.</p><p>However, Azure Cognitive Services recently published a <a href=\"https://docs.microsoft.com/en-us/azure/cognitive-services/speech/api-reference-rest/websocketprotocol\">speech-to-text protocol</a> that works via WebSockets which are well suited for a streaming scenario. We simply open a single bi-directional communication channel via a WebSocket connection and use it to continuously send audio to the speech-to-text service and receive back the transcribed results via the same channel.</p><p>A reference implementation of this speech-to-text approach via WebSockets exists for <a href=\"https://github.com/Azure-Samples/SpeechToText-WebSockets-Javascript\">Javascript</a> and an unofficial implementation exists for <a href=\"https://github.com/noopkat/ms-bing-speech-service\">NodeJS</a>. We created a new implementation of the protocol in <a href=\"https://github.com/CatalystCode/SpeechToText-WebSockets-Java/\">Java</a> so that we can leverage the WebSocket speech-to-text from our Scala-on-Spark pipeline.</p><h3>How does the WebSocket speech-to-text protocol work?</h3><p>After creating a Bing Speech API resource in Azure and noting the access key, we’re ready to start implementing the speech-to-text WebSocket protocol.</p><p><img class=\"alignnone size-full wp-image-4892\" src=\"https://codestoryedge.azureedge.net/developerblog/wp-content/uploads/radio-codestory-azure-dashboard.png\" alt=\"Creating the required resources in Azure\" width=\"564\" height=\"271\" srcset=\"https://codestoryedge.azureedge.net/developerblog/wp-content/uploads/radio-codestory-azure-dashboard.png 564w, https://codestoryedge.azureedge.net/developerblog/wp-content/uploads/radio-codestory-azure-dashboard-300x144.png 300w\" /></p><p>The speech-to-text WebSocket protocol specifies three phases that clients must implement:</p><ol><li>Establishing the speech-to-text WebSocket connection</li><li>Transcribing audio via the speech-to-text WebSocket</li><li>Closing the speech-to-text WebSocket connection</li></ol><p>In the first phase, the client identifies itself with the speech-to-text service and establishes the WebSocket connection. After identification, the client is free to send audio to the speech-to-text service and receive back transcriptions. Eventually, the speech-to-text service will detect the end of the audio stream. When the end is detected, the speech-to-text service will send the client an alert that the audio stream is done getting messages. The client will respond to the service’s end-of-the-audio message by closing the WebSocket speech-to-text connection.</p><p>The full end-to-end flow is illustrated in the diagram below and each phase is described in more detail in the following sections.</p><p><img class=\"alignnone size-large wp-image-4893\" src=\"https://codestoryedge.azureedge.net/developerblog/wp-content/uploads/radio-codestory-tts-pipeline-1024x807.png\" alt=\"WebSocket speech-to-text messages flow\" width=\"780\" height=\"615\" srcset=\"https://www.microsoft.com/developerblog//wp-content/uploads/radio-codestory-tts-pipeline-1024x807.png 1024w, https://www.microsoft.com/developerblog//wp-content/uploads/radio-codestory-tts-pipeline-300x236.png 300w, https://www.microsoft.com/developerblog//wp-content/uploads/radio-codestory-tts-pipeline-768x605.png 768w, https://www.microsoft.com/developerblog//wp-content/uploads/radio-codestory-tts-pipeline.png 1348w\" /></p><h4>Phase 1: Establishing the speech-to-text WebSocket connection</h4><p>To kick off a speech-to-text session, we need to establish a connection with the Bing speech-to-text WebSocket service and identify our client via our API token for the Bing service. Note that all authentication and configuration information must be passed in via query parameters on the WebSocket connection URL since many WebSocket clients don’t have support for headers that would typically be used for sending information like API tokens. For example, using the Java <a href=\"https://github.com/TakahikoKawasaki/nv-websocket-client\">NV WebSocket client</a>, we’d connect to the speech-to-text service as follows:</p><p>After the WebSocket connection is established, we must send additional identifying information about our client (like the operating system used, the audio source being transcribed, etc.) to the speech-to-text service via a WebSocket text message and then we’re ready to transcribe audio:</p><h4>Phase 2: Transcribing audio via the speech-to-text WebSocket</h4><p>Once the client has successfully identified itself with the speech-to-text service, it can start sending chunks of audio for transcription, via binary WebSocket messages:</p><p>The messages follow a specific schema:</p><p><img class=\"alignnone size-large wp-image-4894\" src=\"https://www.microsoft.com/developerblog//wp-content/uploads/radio-codestory-tts-audio-message-schema-1024x592.png\" alt=\"Format of speech-to-text audio transfer messages\" width=\"780\" height=\"451\" srcset=\"https://codestoryedge.azureedge.net/developerblog/wp-content/uploads/radio-codestory-tts-audio-message-schema-1024x592.png 1024w, https://codestoryedge.azureedge.net/developerblog/wp-content/uploads/radio-codestory-tts-audio-message-schema-300x173.png 300w, https://codestoryedge.azureedge.net/developerblog/wp-content/uploads/radio-codestory-tts-audio-message-schema-768x444.png 768w\" /></p><p>Note that the audio data sent to the speech-to-text service must be single-channel mono WAV audio sampled at 16kHz with 16 bits per sample. The speech-to-text service does not validate the format of the audio messages and will silently return incorrect transcriptions on receipt of messages with malformed encodings.</p><p>Most online radio is in MP3 rather than WAV format, making an audio format conversion step necessary for the radio input to be processed by the speech-to-text service. The Java ecosystem has a lack of great open source, permissively licensed streaming MP3 decoders; as a result, our client resorts to converting small batches of MP3 audio to WAV on disk using the <a href=\"https://github.com/pdudits/soundlibs/tree/master/jlayer/src/javazoom/jl/converter\">javazoom converter</a> and then <a href=\"https://github.com/CatalystCode/SpeechToText-WebSockets-Java/blob/182cb301d41427a7a8dd9221ad91aa7922f2d559/src/main/java/com/github/catalystcode/fortis/speechtotext/websocket/MessageSender.java#L58-L101\">resampling</a> the WAV using the javax.sound APIs with the <a href=\"http://www.tritonus.org\">Tritonus plugin</a>. Hopefully, in the future, the trip to disk will be made unnecessary by moving to a streaming or in-memory MP3 decoder.</p><p>After the client starts sending audio messages to the speech-to-text service, the service will transcribe the audio and send the transcription results back to the client. Via WebSocket, transcriptions will be sent with a JSON payload for the client to parse and process. Note that the service may choose to batch multiple input audio messages sent by the client into a single output transcription message returned to the client.</p><h4>Phase 3: Closing the speech-to-text WebSocket connection</h4><p>When the client wishes to close the connection with the speech-to-text service, it must execute three steps in sequence:</p><ol><li>Send an audio message as described in Phase 2, but with a zero-byte audio payload</li><li>Send telemetry as a JSON WebSocket text message about its perception of the speech-to-text service’s performance</li><li>Shut down the WebSocket connection</li></ol><p>Sending the connection-end telemetry is like the client-information telemetry described in Phase 1 above. The schema for the JSON payload of the message is <a href=\"https://docs.microsoft.com/en-us/azure/cognitive-services/speech/api-reference-rest/websocketprotocol#telemetry-schema\">well documented</a>.</p><h2>Summary</h2><p>In many parts of the world, essential information is broadcast via traditional sources such as radio. To formulate effective crisis response plans, the United Nations Office for the Coordination of Humanitarian Affairs needs to be able to access and analyze these data sources in a timely manner.</p><p>To solve this problem, we created a <a href=\"https://github.com/CatalystCode/SpeechToText-WebSockets-Java/\">Java client</a> for the Azure Cognitive Services <a href=\"https://azure.microsoft.com/en-ca/services/cognitive-services/speech/\">speech-to-text</a> WebSocket protocol. We then fed the transcribed radio into a pipeline based on Spark Streaming for further analysis, augmentation, and aggregation. This solution enabled us to ingest and analyze radio in near real-time.</p><p>Our <a href=\"https://github.com/CatalystCode/SpeechToText-WebSockets-Java/\">Java client</a> is reusable across a wide range of text-to-speech scenarios that require time-efficient speech-to-text transcription in more than 10 languages including English, French, Spanish, German and Chinese.</p><h2>Resources</h2><ul><li><a href=\"https://github.com/CatalystCode/SpeechToText-WebSockets-Java/\">Java client for speech-to-text WebSocket protocol</a></li><li><a href=\"https://github.com/Azure-Samples/SpeechToText-WebSockets-Javascript\">JavaScript client for speech-to-text WebSocket protocol</a></li><li><a href=\"https://github.com/noopkat/ms-bing-speech-service\">NodeJS client for speech-to-text WebSocket protocol</a></li><li><a href=\"https://github.com/CatalystCode/project-fortis-spark\">Fortis project using speech-to-text WebSocket and Spark custom receivers</a></li><li><a href=\"https://azure.microsoft.com/en-ca/services/cognitive-services/speech/\">Bing speech-to-text documentation</a></li></ul>"}}]}},"pageContext":{"alternative_id":11604}}