{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cassandra | Apigee","alternative_id":1571,"content":"<article id=\"node-30711\" class=\"node node-blog-content node-promoted node-teaser clearfix\"><header>\n                \n            Submitted by anant on Tue, 2016-09-06 15:26    \n      </header><div class=\"field field-name-body field-type-text-with-summary field-label-hidden\"><div class=\"field-items\"><div class=\"field-item even\"><p dir=\"ltr\"><img alt=\"\" src=\"https://d38wlcdzwz02m5.cloudfront.net/about/cdn/farfuture/fH6gsYnWTam_Kbs0_sr_uwtRDMcBCReQRV70oYYVscI/mtime:1473192147/sites/mktg-new/files/DeveloperNoun_Kevin%20Augustine%20LO.jpg\" />I have always admired Google :). The company delivers kick-ass technology, but it also delivers a kick-ass experience. Take Google Docs. Instant changes, no “Oh crap, I forgot to Ctrl-S, I am screwed.” I’m typing this in a Google doc. While it’s not the only reason (or even the main reason), I do believe that an important reason for Google’s quality is that Googlers use their own product, and they’d never let an embarrassment go out.</p><p dir=\"ltr\">Contrast this with enterprise software. I have built database technologies for decades—yet, for a long time, I never used it (I mean really used it, as opposed to testing or demoing it). This is true for tons of enterprise software technologies. The developers who build it and the developers who use it are not one and the same.  </p><p dir=\"ltr\">What about open source software like Cassandra? Isn’t it built out of needs, and aren’t the developers who build it the developers who use it? Only partially. Apps use databases. Database developers build databases, whether it’s DB2, or Cassandra. Neat architecture, pretty bad user experience.  </p><p dir=\"ltr\">Technologies that work well are technologies that are built and used by the same developers. No ifs, ands, or buts about it.</p><p dir=\"ltr\">That brings us to what I am doing now. I am immersed in microservices and API management. There are some things our developers will never have a good feel for. SAML 2.0 for connecting to SAP R/3? How could a developer in a 300-person startup have that intuition?</p><p dir=\"ltr\">We have to call upon general product management, security, and enterprise software knowledge to build something that we hope is functional and usable, and then have a good feedback loop. The developer building the technology and the developer using the technology are different.  </p><p dir=\"ltr\">But microservices and APIs are different. We produce software for other folks to deploy APIs on. How do we do it? With small teams that aspire to the right set of microservices principles. With clean APIs. Each service needs to scale up and down.</p><p dir=\"ltr\">The deployment of these services can have errors, so we have to implement the right <a href=\"https://docs.pivotal.io/pivotalcf/1-7/devguide/deploy-apps/blue-green.html\">blue-green deployment</a> infrastructure. Teams are independent, so they need clean APIs, with documentation as contracts between them. Our developers employ microservices and API best practices. The software they build is a reflection of what they need, day in and day out.</p><p dir=\"ltr\">Whenever you evaluate software, ask the vendor: “Do your developers use it?” It will help you make better decisions.</p><p dir=\"ltr\">Image: <a href=\"https://thenounproject.com/\">The Noun Project</a>/Kevin Augustine LO</p></div></div></div><footer></footer></article><article id=\"node-15231\" class=\"node node-blog-content node-promoted node-teaser clearfix\"><header>\n                \n            Submitted by GregJai on Thu, 2015-09-24 13:18    \n      </header><div class=\"field field-name-body field-type-text-with-summary field-label-hidden\"><div class=\"field-items\"><div class=\"field-item even\"><p dir=\"ltr\"><img alt=\"\" src=\"https://d38wlcdzwz02m5.cloudfront.net/about/cdn/farfuture/b2D9rs2_NkaTWZ95v33BSCvTpdaVrgNKlar9tFNHNc0/mtime:1443119148/sites/mktg-new/files/CloudDots_noun_Kirill%20Ulitin.png\" />Amazon Web Services suffered <a href=\"https://venturebeat.com/2015/09/20/amazons-aws-outage-takes-down-netflix-reddit-medium-and-more/\">another outage</a> Sunday morning. The cause this time seems to have been the <a href=\"https://aws.amazon.com/dynamodb/\">DynamoDB </a>service, which is a very scalable, cloud-backed data store. Lots of other services suffered from “increased error rates” at the same time—apparently either DynamoDB underpins more of AWS than we realized, or it’s all based on some other layer that Amazon doesn’t talk about publicly.</p><p dir=\"ltr\">We’ve seen a pattern play out in the last few AWS outages that should make us all think carefully about how we use the cloud.</p><h3 dir=\"ltr\">The problem: what if you can’t make changes?</h3><p dir=\"ltr\">One version of this pattern is best exemplified by the following list of status messages from the <a href=\"http://status.aws.amazon.com/\">AWS Status Dashboard</a> for the EC2 service:</p><p dir=\"ltr\">3:12 AM PDT: We are investigating increased error rates and latencies for the EC2 APIs in the US-EAST region.</p><p dir=\"ltr\">...</p><p dir=\"ltr\">7:43 AM PDT: Error rates for impacted APIs are beginning to recover and new instance launches are starting to succeed.</p><p dir=\"ltr\">In other words, early Sunday morning, it was hard to launch a new EC2 instance in the US-East region, and this condition persisted for four-and-a-half hours. Past EC2 outages have also affected this aspect of the service. Applications that weren’t dependent on DynamoDB Sunday morning kept running along fine—that is, just as long as they didn’t need to start new instances, or auto-scale, or do anything anything else that relies on the EC2 API.</p><p dir=\"ltr\">The second version of the pattern occurs when thousands of ops teams detect a problem in AWS and respond by launching new instances somewhere else, such as in another region. We have seen this in the past, when launching a new instance can go from taking a few seconds to taking much longer.</p><p dir=\"ltr\">For instance, imagine that an East Coast AWS outage was more than just a few services; say a whole Availability Zone catches on fire or is taken offline by an <a href=\"https://en.wikipedia.org/wiki/2011_Virginia_earthquake\">earthquake</a>. Thousands of ops teams around the world start scrambling to launch new instances in other regions, or on other clouds. As huge as AWS is, that kind of load is going to start to play tricks on the management systems, and those instances might take a while to launch.</p><p dir=\"ltr\">Do you want to be the last team in line when that happens?</p><h3 dir=\"ltr\">The importance of geographic redundancy</h3><p dir=\"ltr\">So what does this mean to us as we try to design robust systems that run in the public cloud? The first lesson is the one that you can read about <a href=\"https://www.techrepublic.com/article/aws-outage-how-netflix-weathered-the-storm-by-preparing-for-the-worst/\">all</a> over the <a href=\"https://www.forbes.com/sites/justinwarren/2015/09/20/aws-outage-doesnt-change-anything/\">place</a>. That’s because Amazon did a smart and far-thinking thing here—they divided up their world into <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html\">“regions” and “availability zones.” </a></p><p dir=\"ltr\">AZs are close together, but physically isolated. As a result, an AWS region is actually a super-data-center that includes multiple redundant physical facilities. It’s arguably a lot more redundant than anything any of us would build on our own.</p><p dir=\"ltr\">Regions, however, are not just physically isolated, but logically isolated. Not only do they run a totally different set of AWS software, but they are only connected via the public Internet. As a result, a software problem in one region cannot affect another one.</p><p dir=\"ltr\">That means, that, as architects, one thing we should do is to try to design our systems to take advantage of multiple regions. Of course, it’s not as easy as the blogosphere makes it out to be.</p><p dir=\"ltr\">For instance, at Apigee we have been running our service across regions since 2012, primarily by extending our Cassandra and Zookeeper clusters across regions. We were able to do this because our software is built around technology, like Cassandra, that inherently supports geographical replication on an unreliable network. (We also had to set up redundant VPN tunnels and do some careful planning).</p><p dir=\"ltr\">If we had based our product on a traditional DBMS or some other type of technology, however, we probably would not have been able to achieve the SLAs that our customers demand.</p><p dir=\"ltr\">But unless you were a big DynamoDB user, you didn’t even need to use multi-region availability in order to stay alive last weekend. In fact, although we run across regions, we didn’t need to use that capability to stay alive—that part of our service remained doing its normal job, which is to reduce latency.</p><p dir=\"ltr\">What you do need, however, is to be a bit conservative.</p><h3 dir=\"ltr\">The importance of systems management</h3><p dir=\"ltr\">When we design systems, we tend to go through all the things that can go down. “What happens if a disk fails?” “What happens if a server fails?” “What happens if we need to upgrade the database server?”</p><p dir=\"ltr\">Then we get to management, and someone asks a question like, “What happens when the systems management server goes down?” Too often, the answer is, “It’s just management. Everything else will keep running if it’s down. <a href=\"http://www.nytimes.com/2010/02/26/us/26tyler.html\">Don’t worry about it.”</a></p><p dir=\"ltr\">This, of course, is precisely the wrong answer.</p><p dir=\"ltr\">The infinite scalability and API-driven nature of the cloud leads to all sorts of interesting possibilities. Auto scaling is easy to turn on. You never need to update the software on a server because it’s easier to launch a new server. And you certainly don’t need to have servers, already running, that you can use in case of a failure.</p><p dir=\"ltr\">But every one of those possibilities assumes that you can make management changes to your cloud at all times. In fact, you are more likely to need to make those changes when something is going wrong in the public cloud—and that is precisely when you need them most.</p><h3 dir=\"ltr\">The importance of conservatism</h3><p dir=\"ltr\">So although it’s not an exciting and ground-breaking way to use the cloud, conservatism has its virtues, at least in this case.</p><p>For instance:</p><ul><li>Provision more capacity than you need</li>\n\t<li>Keep that capacity up and running and actively serving traffic at all times</li>\n\t<li>Spread that capacity across multiple data centers (AZs for Amazon customers)</li>\n\t<li>If you can replicate across regions, and it makes sense cost-wise, then do it</li>\n\t<li>Don’t assume that you can scale up in minutes, let alone seconds</li>\n\t<li>Don’t assume that you can replace instances in minutes, or even hours</li>\n\t<li>If your disaster recovery plan involves another cloud, expect it to be slow when you need it most</li>\n</ul><p dir=\"ltr\"> </p><p dir=\"ltr\">By the way, this isn’t just an AWS thing. Do you build your own management infrastructure? Do you depend on Puppet or Chef or Ansible or Salt Stack or a single Git server, or even GitHub itself? What happens when that’s down? Maybe it’s time to think about that.</p><p dir=\"ltr\">Image: Kirill Ulitin/<a href=\"https://thenounproject.com/\">The Noun Project</a></p></div></div></div><footer></footer></article><article id=\"node-15196\" class=\"node node-blog-content node-promoted node-teaser clearfix\"><header>\n                \n            Submitted by RussoWest on Thu, 2015-09-17 15:03    \n      </header><div class=\"field field-name-body field-type-text-with-summary field-label-hidden\"><div class=\"field-items\"><div class=\"field-item even\"><p dir=\"ltr\"><img alt=\"\" src=\"https://d38wlcdzwz02m5.cloudfront.net/about/cdn/farfuture/UTig0oMJAzp-FE9HZF5OJIQWqwRJvtyPSLe5wFZFI0U/mtime:1442520098/sites/mktg-new/files/Speedometer_Noun_Lara_thumb_0.png\" />We recently did some testing on Apache Usergrid, the open-source Backend as a Service, and found that it can reach 10,000 transactions per second, and can scale horizontally. This means the upcoming Usergrid 2 release is potentially the most scalable open-source BaaS available. Here's the story of how we got there.</p><h3 dir=\"ltr\">What is Usergrid?</h3><p dir=\"ltr\"><a href=\"http://usergrid.apache.org\">Apache Usergrid</a> is a software stack that enables you to run a BaaS that can store, index, and query JSON objects. It also enables you to manage assets and provide authentication, push notifications, and a host of other features useful to developers—especially those working on mobile apps.</p><p dir=\"ltr\">The project recently graduated from the Apache Incubator and is now a top-level project of the Apache Software Foundation (ASF). Usergrid also comprises the foundation for Apigee’s API BaaS product, which has been in production for three years now.</p><h3 dir=\"ltr\">What’s new in Usergrid 2?</h3><p dir=\"ltr\">Usergrid 1 used Cassandra for all persistence, indexing, query, and graph relationships. The index and query engine wasn’t performing well, however, and was quite complex and difficult to maintain. Usergrid 2 provides a complete new persistence, index, and query engine and the index and query features are provide by ElasticSearch. This enables us to delete lots of code and trade up to a great search engine. Additionally, separating key-value persistence from index/query allows us to scale each concern separately.</p><p dir=\"ltr\">As the architecture of Usergrid changed drastically, we needed to have a new baseline performance benchmark to make sure the system scaled as well as, if not better than, it did before.</p><h3 dir=\"ltr\">Our testing framework and approach</h3><p dir=\"ltr\">The Usergrid team has invested a lot of time building repeatable test cases using the Gatling load-testing framework. Performance is a high priority for us and we need a way to validate performance metrics for every release candidate.</p><p dir=\"ltr\">As Usergrid is open source, so are our Usergrid-specific Gatling scenarios, which you can find here: <a href=\"https://github.com/apache/usergrid/tree/two-dot-o-dev/stack/loadtests\">https://github.com/apache/usergrid/tree/two-dot-o-dev/stack/loadtests</a></p><h3 dir=\"ltr\">Usergrid application benchmark</h3><p dir=\"ltr\">One of our goals was to prove that we had the ability to scale more requests per second with more hardware, so we started small and worked our way up.</p><p dir=\"ltr\">As the first in our series of new benchmarking for Usergrid, we wanted to start with a trivial use case to establish a solid baseline for the application. All testing scenarios use the HTTP API and test the concurrency and performance of the requests. We inserted a few million entities that we could later read from the system. The test case itself was simple. Each entity has a UUID (universally unique identifier) property. For all the entities we had inserted, we randomly read them out by their UUID:</p><pre dir=\"ltr\">\nGET /organization/application/collection/:entityUUID</pre><p dir=\"ltr\">First, we tried scaling the Usergrid application by its configuration. We configured a higher number of connections to use for Cassandra and a higher number of threads for Tomcat to use.  This actually yielded higher latencies and system resource usage for marginally the same throughput. We saw better throughput when there was less concurrency allowed. This made sense, but we needed more, and immediately added more Usergrid servers to verify horizontal scalability. What will it take to get to 10,000 RPS?</p><p dir=\"ltr\"><img alt=\"\" src=\"https://d38wlcdzwz02m5.cloudfront.net/about/cdn/farfuture/p5Ok32fcKP1sNeFG9rgnyDJihH07z3bGAKXk30_gRFo/mtime:1442517504/sites/mktg-new/files/UsergridGraphic1.png\" /></p><p dir=\"ltr\">We started increasing the number of concurrent clients and adding more Usergrid servers.  Once we got 10 Usergrid servers against our cluster of 6 Cassandra nodes, we noticed that our throughput increase was flattening and latencies were increasing. The Usergrid servers were fine on memory usage and CPU usage was starting to increase slowly.  </p><h3 dir=\"ltr\">Cassandra performance</h3><p dir=\"ltr\">It was time to see if Cassandra was keeping up. As we scaled up the load we found Cassandra read operation latencies were also increasing. Shouldn't Cassandra handle more, though? We observed a single Usergrid read by UUID was translating to about 10 read operations to cassandra. Optimization #1: reduce the number of read operations from Cassandra on our most trivial use case. Given what we know, we still decided to test up to a peak 10,000 RPS in the current state.  </p><div><img src=\"https://lh3.googleusercontent.com/a5YQ-Kj_POkfDoBTyXGWPcEIv1l0kMsLJcc77p5Bvq_D1SssENRGV_2PI0QwE6EMl2dW8vePfizeIe1AQNoJRC0NbGSu-66AbAC3DWGIjCLa41r0_R_vN8g4HEqc6hX532oQVQ8\" alt=\"image\" /></div><div><p dir=\"ltr\">The cluster was scaled horizontally (more nodes) until we needed to vertically scale (bigger nodes) Cassandra due to high CPU usage.  We stopped at 10,268 Requests Per Second with the following:</p><ul><li>thirty-five c3.xlarge Usergrid servers running Tomcat</li>\n\t\t<li>nine c3.4xlarge Cassandra nodes doing roughly100k operations/second</li>\n\t</ul><p dir=\"ltr\">By this point numerous opportunities for improvement were identified in the codebase, and we had already executed on some. We fully expect to reach the same throughput with much less infrastructure in the coming weeks. In fact, we've already reached ~7,800 RPS with only 15 Usergrid servers since our benchmarking.</p><h3 dir=\"ltr\">What's next?</h3><p dir=\"ltr\">As part of this testing, not only did we identify code optimizations that we can quickly fix for huge performance gains, we also learned more about tuning our infrastructure to handle high concurrency. Having this baseline gives us the motivation to continually improve performance of the Usergrid application, reducing the cost for operating a BaaS platform at huge scale.</p><p dir=\"ltr\">This post is just the start of our performance series. Stay tuned, as we’ll be publishing more results in the future for the following Usergrid scenarios:</p><ul><li>Query performance - this includes complex graph and geo-location queries</li>\n\t\t<li>Write performance - performance of directly writing entities as well as completing indexing</li>\n\t\t<li>Push notification performance - this is a combination of query and write performance</li>\n\t</ul><p>Image: Lara/<a href=\"https://thenounproject.com/\">The Noun Project</a></p><hr /><p><em>Reference</em></p><p dir=\"ltr\"><em>The following components are used by the Usergrid application, with the associated versions used for our benchmarking:</em></p><ul dir=\"ltr\"><li><em>Tomcat 7.0.62 where the Usergrid WAR file is deployed</em></li>\n\t\t<li><em>Cassandra 2.0.15 with Astyanax client</em></li>\n\t\t<li><em>Elasticsearch 1.4.4 (not utilized in these tests)</em></li>\n\t</ul><p><em>As part of benchmarking, we wanted to ensure that all configurations and deployment scenarios exactly matched how we would run a production cluster. Here are the main configurations recommended for production use of Usergrid:</em></p><p><img alt=\"\" src=\"https://d38wlcdzwz02m5.cloudfront.net/about/cdn/farfuture/BxkhugrTv_7hnreX_gRuq0B_ziULZXHu96aYM0F4rD4/mtime:1442519187/sites/mktg-new/files/UsergridGraphic2_0.png\" /></p></div></div></div></div><footer></footer></article>"}}]}},"pageContext":{"alternative_id":1571}}