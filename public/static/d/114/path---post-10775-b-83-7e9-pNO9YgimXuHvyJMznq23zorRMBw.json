{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cassandra to Kafka Data Pipeline Part 1","alternative_id":10775,"content":"<p><strong>Introduction</strong></p><p>I’ve wanted to create a system which in its core uses event sourcing for quite a while - actually since I’ve read Martin Kleppmann’s <a rel=\"noopener noreferrer\" href=\"http://www.oreilly.com/data/free/stream-processing.csp\" target=\"_blank\">Making Sense of Stream Processing</a>. The book is really amazing, Martin tends to explain all concepts from basic building blocks and in a really simple and understandable way. I recommend it to everyone.</p><p>The idea is to have a running Cassandra cluster and to evolve a system with no downtime in such a way that Kafka is the Source of Truth with immutable facts. Every other system (in this case Cassandra cluster) should use these facts and aggregate / transform them for its purpose. Also, since all facts are in Kafka, it should be easy to drop the whole database, index, cache or any other data system and recreate it from scratch again.</p><p>The following diagrams should illustrate the system evolution.</p><p><img src=\"https://www.smartcat.io/media/1359/starting-architecture.png?width=341&amp;height=243\" alt=\"\" data-udi=\"umb://media/dd373f3e90d34fe89de279c1aa0d2542\" /></p><p>Starting system architecture</p><p><img src=\"https://www.smartcat.io/media/1360/target-architecture.png?width=341&amp;height=243\" alt=\"\" data-udi=\"umb://media/069d0a53b9e84ecb9a6f84f23ecff872\" /></p><p>Target system architecture</p><p>When observing the diagrams, it seems like a pretty straightforward and trivial thing to do, but there’s more to it, especially when you want to do it with no downtime.</p><p><strong>Evolution breakdown</strong></p><p>I tried to break down the evolution process to a few conceptual steps and this is what I came up with: </p><p><strong>1. Have a mechanism to push each Cassandra change to Kafka with timestamp</strong></p><p><strong>2. Start collecting each Cassandra change to temporary Kafka topic</strong></p><p>I need to start collecting before a snapshot is taken, otherwise there will be a time window in which incoming changes would be lost, and it also needs to go to temporary topic since there is data in the database which should be first in an ordered sequence of events.</p><p><strong>3. Take the existing database snapshot</strong></p><p>This one is pretty straightforward. </p><p><strong>4. Start reading data from the snapshot into the right Kafka topic</strong></p><p>Since the data from the snapshot was created first, it should be placed first into Kafka.</p><p><strong>5. After the snapshot is read, redirect the data from the temporary Kafka topic to the right Kafka topic, but mind the timestamp when the snapshot is taken</strong></p><p>This step is essential to be done correctly, and could be considered as the hardest part. Since change event collecting started before the snapshot, there is a possibility that some events also exist in the snapshot as well and, to avoid inconsistencies, each event should be idempotent and I should try to be as precise as possible when comparing the event timestamp with the snapshot timestamp.</p><p><strong>6. Create a new Cassandra cluster/keyspace/table and Kafka stream to read from Kafka and insert into this new Cassandra cluster/keyspace/table</strong></p><p>As a result, the new cassandra cluster should be practically a copy/clone of the existing one.</p><p><strong>7. Wait for the temporary Kafka topic to deplete</strong></p><p>If I change the application to read from the new cassandra right away, and Kafka temporary topic still doesn’t catch up with system, there will be significant read delays (performance penalties) in the system. To make sure everything is in order, I think monitoring of time to propagate the change to the new Cassandra cluster will help and if the number is decent (a few milliseconds), I can proceed to the next step.</p><p><strong>8. Change the application to read from the new cassandra instead of old and still write to old</strong></p><p>Since everything is done within the no downtime context, the application is actually several instances of application on different nodes, and they won’t be changed simultaneously, that would cause the downtime. I’d need to change one at a time, while others are still having the old software version. For this reason, the application still needs to write to the old cassandra, since other application nodes are still reading from the old cassandra.</p><p><strong>9. When each application instance is updated, change the application to write directly to Kafka right topic</strong></p><p>Now each node, one by one, can be updated with new application version which will write directly to Kafka. In parallel, old nodes will write to the old Cassandra which will propagate to Kafka topic, and new nodes will write directly to the Kafka topic. When the change is complete, all nodes are writing directly to the Kafka topic and we are good to go.</p><p><strong>10. Clean up</strong></p><p>At this point, the system writes to the right Kafka topic, the stream is reading from it and making inserts into the new Cassandra. The old Cassandra and Kafka temporary topic are no longer necessary so it should be safe for me to remove them.</p><p>Well, that’s the plan, so we’ll see whether it is doable or not. </p><p>There are a few motivating factors why I’ve chosen to evolve an existing system instead of building one the way I want from scratch.</p><ol><li>It is more challenging, hence more fun.</li>\n<li>The need for evolving existing systems is the everyday job of software developers; you don’t get a chance to build a system for a starting set of requirements with guarantee that nothing in it will ever change (except for a college project, perhaps).</li>\n<li>When a system needs to change, you can choose two ways, to build a new one from scratch and when ready replace the old or to evolve the existing. I’ve done the former a few times in my life, and it might seem as fun at the beginning, but it takes awfully long, with a lot of bug fixing, often ends up as a catastrophe and is always expensive.</li>\n<li>Evolving a system takes small changes with more control, instead of placing a totally new system instead of the old.</li>\n<li>I’m a fan of Martin Fowler’s blog, <a rel=\"noopener noreferrer\" href=\"https://martinfowler.com/articles/evodb.html\" target=\"_blank\">Evolutionary Database Design</a> fits particularly nicely in this topic.</li>\n</ol><p>Since writing about this in a single post would render quite a huge post, I’ve decided to split it into a few, I’m still not sure how many, but I’ll start and see where it takes me. Bear with me.</p><p><strong>Data model</strong></p><p>I’ll start with data model. Actually, it is just one simple table, but it should be enough to demonstrate the idea. The following CQL code describes the table.</p><pre class=\"csharpcode\">CREATE TABLE IF NOT EXISTS movies_by_genre (<br />title text,<br />genre text,<br />year int,<br />rating float,<br />duration int,<br />director text,<br />country text,<br />PRIMARY KEY ((genre, year), rating, duration)<br />) WITH CLUSTERING ORDER BY (rating DESC, duration ASC)</pre><p>The use case for this table might not be that common, since the table is actually designed to have a complex primary key with at least two columns as a partition key and at least two clustering columns. The reason for that is it will leverage examples, since handling of a complex primary key might be needed for someone reading this.</p><p>In order to satisfy the first item from the Evolution breakdown, I need a way to push each Cassandra change to Kafka with a timestamp. There are a few ways to do it: Cassandra Triggers, Cassandra CDC, Cassandra Custom Secondary Index and possibly some other ways, but I’ll investigate only the three mentioned.</p><p><strong>Cassandra Triggers</strong></p><p>For this approach I’ll use two Cassandra 3.11.0 nodes, two Kafka 0.10.1.1 nodes and one Zookeeper 3.4.6. Every node will run in a separate Docker container. I decided to use Docker since it keeps my machine clean and it is easy to recreate infrastructure.</p><p dir=\"ltr\">To create a trigger in Cassandra, ITrigger interface needs to be implemented. The interface itself is pretty simple:</p><pre class=\"csharpcode\">public interface ITrigger {public Collection&lt;Mutation&gt; augment(Partition update);<br />}</pre><p dir=\"ltr\">And that’s all there is to it. The interface has been changed since Cassandra 3.0. Earlier versions of Cassandra used the following interface:</p><pre class=\"csharpcode\">public interface ITrigger {public Collection&lt;Mutation&gt; augment(ByteBuffer partitionKey, ColumnFamily update);<br />}</pre><p>Before I dive into implementation, let’s discuss the interface a bit more. There are several important points regarding the implementation that need to be honored and those points are explained on the interface’s javadoc:</p><ol><li>Implementation of this interface should only have a constructor without parameters</li>\n<li>ITrigger implementation can be instantiated multiple times during the server life time. (Depends on the number of times the trigger folder is updated.)</li>\n<li>ITrigger implementation should be stateless (avoid dependency on instance variables).</li>\n</ol><p>Besides that, augment method is called exactly once per update and Partition object contains all relevant information about the update. You might notice that return type is not void but rather a collection of mutations. This way trigger can be implemented to perform some additional changes when certain criteria are met. But since I just want to propagate data to Kafka, I’ll just read the update information, send it to Kafka and return empty mutation collection. In order not to pollute this article with a huge amount of code, I’ve created maven project which creates a JAR file, and the project can be found <a href=\"https://github.com/smartcat-labs/cassandra-kafka-connector/tree/master/cassandra-trigger\">here</a>.</p><p>I’ll try to explain the code in the project. Firstly, there is a FILE_PATH constant, which points to /etc/cassandra/triggers/KafkaTrigger.yml and this is where YAML configuration for trigger class needs to be. It should contain configuration options for Kafka brokers and for topic name. The file is pretty simple, since the whole file contains just the following two lines:</p><pre class=\"csharpcode\">bootstrap.servers: cluster_kafka_1:9092,cluster_kafka_2:9092&#13;\ntopic.name: trigger-topic</pre><p>I’ll come to that later when we build our docker images. Next, there is a constructor which initializes the Kafka producer and ThreadPoolExecutor. I could have done it without ThreadPoolExecutor, but the reason for it is that the trigger augment call is on Cassandra’s write path and in that way it impacts Cassandra’s write performances. To minimize that, I’ve moved trigger execution to background thread. This is doable in this case, since I am not making any mutations, I can just start the execution in another thread and return an empty list of mutations immediately. In case when the trigger needs to make a mutation based on partition changes, that would need to happen in the same thread.</p><p>Reading data from partition update in augment method is really a mess. Cassandra API is not that intuitive and I went through a real struggle to read all the necessary information. There are a few different ways to update a partition in Cassandra, and these are ones I’ve covered:</p><ol><li>Insert</li>\n<li>Update</li>\n<li>Delete of director column</li>\n<li>Delete of title column</li>\n<li>Delete of both director and title columns</li>\n<li>Delete of row</li>\n<li>Delete range of rows for last clustering column (duration between some values)</li>\n<li>Delete all rows for specific rating clustering column</li>\n<li>Delete range of rows for first clustering column (rating between some values)</li>\n<li>Delete whole partition</li>\n</ol><p>A simplified algorithm would be: </p><pre class=\"csharpcode\">if (isPartitionDeleted(partition)) {<br />handle partition delete;<br />} else {<br />if (isRowUpdated(partition)) {<br />if (isRowDeleted(partition)) {<br />handle row delete;<br />} else {<br />if (isCellDeleted(partition)) {<br />handle cell delete;<br />} else {<br />handle upsert;<br />}<br />}<br />} else if (isRangeDelete(partition)) {<br />handle range delete;<br />}<br />}</pre><p>In each case, JSON is generated and sent to Kafka. Each message contains enough information to recreate Cassandra CQL query from it.</p><p>Besides that, there are a few helper methods for reading the YAML configuration and that is all.</p><p>In order to test everything, I’ve chosen Docker, as stated earlier. I’m using <a rel=\"noopener noreferrer\" href=\"https://hub.docker.com/_/cassandra/\" target=\"_blank\">Cassandra</a> docker image with 3.11.0 tag. But since the JAR file and KafkaTrigger.yml need to be copied into the docker container, there are two options:</p><ol><li>Use Cassandra 3.11.0 image and docker cp command to copy the files into the container</li>\n<li>Create a new Docker image with files already in it and use that image</li>\n</ol><p>The first option is not an option actually, it is not in the spirit of Docker to do such thing so I will go with the second option.</p><p>Create a cluster directory somewhere and a cassandra directory within it</p><pre class=\"csharpcode\">mkdir -p cluster/cassandra</pre><p>cluster directory will be needed for later, now just create KafkaTrigger.yml in cassandra dir with the content I provided earlier. Also, the built JAR file (cassandra-trigger-0.0.1-SNAPSHOT.jar) needs to be copied here. To build all that into Docker, I created a Dockerfile with the following content:</p><pre class=\"csharpcode\">FROM cassandra:3.11.0<br />COPY KafkaTrigger.yml /etc/cassandra/triggers/KafkaTrigger.yml<br />COPY cassandra-trigger-0.0.1-SNAPSHOT.jar /etc/cassandra/triggers/trigger.jar<br />CMD [\"cassandra\", \"-f\"]</pre><p>In console, just position yourself in the cassandra directory and run:</p><pre class=\"csharpcode\">docker build -t trigger-cassandra .</pre><p>That will create a docker image with name trigger-cassandra.</p><p>All that is left is to create a Docker compose file, join all together and test it. The Docker compose file should be placed in the  cluster directory. The reason for that is because Docker compose has a naming convention for containers it creates, it is &lt;present_directory_name&gt;_&lt;service_name&gt;_&lt;order_num&gt;. And I already specified the Kafka domain names in KafkaTrigger.yml as cluster_kafka_1 and cluster_kafka_2, in case the Docker compose is run from another location, container naming would change and KafkaTrigger.yml would need to be updated.</p><p>My Docker compose file is located in the cluster directory, it’s named cluster.yml and it looks like this:</p><pre class=\"csharpcode\">version: '3.3'<br />services:<br />zookeeper:<br />image: wurstmeister/zookeeper:3.4.6<br />ports:<br />- \"2181:2181\"<br />kafka:<br />image: wurstmeister/kafka:0.10.1.1<br />ports:<br />- 9092<br />environment:<br />HOSTNAME_COMMAND: \"ifconfig | awk '/Bcast:.+/{print $$2}' | awk -F\\\":\\\" '{print $$2}'\"<br />KAFKA_ADVERTISED_PORT: 9092<br />KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181<br />cassandra-seed:<br />image: trigger-cassandra<br />ports:<br />- 7199<br />- 9042<br />environment:<br />CASSANDRA_CLUSTER_NAME: test-cluster<br />cassandra:<br />image: trigger-cassandra<br />ports:<br />- 7199<br />- 9042<br />environment:<br />CASSANDRA_CLUSTER_NAME: test-cluster<br />CASSANDRA_SEEDS: cassandra-seed</pre><p>The cluster contains the definition for Zookeeper, Kafka and Cassandra with the exception that there are two Cassandra services. The reason for that is that one can be standalone, but all others need a seed list. cassandra-seed will serve as seed, and cassandra as scalable service. That way, I can start multiple instances of cassandra. However, to start multiple instances, it takes time, and it is not recommended to have multiple Cassandra nodes in joining state. So, scale should be done one node at a time. That does not apply to Kafka nodes. With the following command, I’ve got a running cluster ready for use:</p><pre class=\"csharpcode\">docker-compose -f cluster.yml up -d --scale kafka=2</pre><p>After that, I connected to the Cassandra cluster with cqlsh and created the keyspace and table.</p><p>To add a trigger to the table, you need to execute the following command:</p><pre class=\"csharpcode\">CREATE TRIGGER kafka_trigger ON movies_by_genre USING 'io.smartcat.cassandra.trigger.KafkaTrigger';</pre><p>In case you get the following error:</p><pre class=\"csharpcode\">ConfigurationException: Trigger class 'io.smartcat.cassandra.trigger.KafkaTrigger' doesn't exist</pre><p>There are several things that can be wrong. The JAR file might not be loaded within the Cassandra node; that should happen automatically, but if it doesn’t you can try to load it with:</p><pre class=\"csharpcode\">nodetool reloadTriggers</pre><p>If the problem persists, it might be that the configuration file is not at a proper location, but that can only happen if you are using a different infrastructure setup and you forgot to copy KafkaTrigger.yml to the proper location. Cassandra will show the same error even if class is found but there is some problem instantiating it or casting it to theITrigger interface. Also, make sure that you implemented the ITrigger interface from the right Cassandra version (versions of cassandra in the JAR file and of the cassandra node should match).</p><p>If there are no errors, the trigger is created properly. This can be checked by executing the following CQL commands:</p><pre class=\"csharpcode\">USE system_schema;<br />SELECT * FROM triggers;</pre><p><strong>Results</strong></p><p>I used kafka-console-consumer to see if messages end up in Kafka, but any other option is good enough. Here are a few things I tried and the results it gave me:</p><pre class=\"csharpcode\">-- insert<br />INSERT INTO movies_by_genre (genre, year, rating, duration, title, director) VALUES ('drama', 2015, 7.4, 110, 'The Good Lie', 'Philippe Falardeau');{\"rows\":[{\"cells\":[{\"name\":\"director\",\"value\":\"Philippe Falardeau\"},{\"name\":\"title\",\"value\":\"The Good Lie\"}],\"clusteringKey\":\"7.4, 110\"}],\"key\":\"drama:2015\"}-- update<br />UPDATE movies_by_genre SET title = 'a' WHERE genre = 'drama' AND year = 2015 AND rating = 7.4 AND duration = 110;{\"rows\":[{\"cells\":[{\"name\":\"title\",\"value\":\"a\"}],\"clusteringKey\":\"7.4, 110\"}],\"key\":\"drama:2015\"}-- delete of director column<br />DELETE director FROM movies_by_genre WHERE genre = 'drama' AND year = 2015 AND rating = 7.4 AND duration = 110;{\"rows\":[{\"cells\":[{\"deleted\":true,\"name\":\"director\"}],\"clusteringKey\":\"7.4, 110\"}],\"key\":\"drama:2015\"}-- delete of title column<br />DELETE title FROM movies_by_genre WHERE genre = 'drama' AND year = 2015 AND rating = 7.4 AND duration = 110;{\"rows\":[{\"cells\":[{\"deleted\":true,\"name\":\"title\"}],\"clusteringKey\":\"7.4, 110\"}],\"key\":\"drama:2015\"}-- delete of both director and title columns<br />DELETE title, director FROM movies_by_genre WHERE genre = 'drama' AND year = 2015 AND rating = 7.4 AND duration = 110;{\"rows\":[{\"cells\":[{\"deleted\":true,\"name\":\"director\"},{\"deleted\":true,\"name\":\"title\"}],\"clusteringKey\":\"7.4, 110\"}],\"key\":\"drama:2015\"}-- delete of row<br />DELETE FROM movies_by_genre WHERE genre = 'drama' AND year = 2015 AND rating = 7.4 AND duration = 110;{\"rowDeleted\":true,\"rows\":[{\"clusteringKey\":\"7.4, 110\"}],\"key\":\"drama:2015\"}-- delete range of rows for last clustering column (duration between some values) <br />DELETE FROM movies_by_genre WHERE genre = 'drama' AND year = 2015 AND rating = 7.4 AND duration &gt; 90;                    {\"rowRangeDeleted\":true,\"start\":[{\"clusteringKey\":\"7.4\"},{\"inclusive\":false,\"clusteringKey\":\"90\"}],\"end\":[{\"inclusive\":true,\"clusteringKey\":\"7.4\"}],\"rows\":[],\"key\":\"drama:2015\"}-- delete range of rows for last clustering column (duration between some values) <br />DELETE FROM movies_by_genre WHERE genre = 'drama' AND year = 2015 AND rating = 7.4 AND duration &lt; 90;{\"rowRangeDeleted\":true,\"start\":[{\"inclusive\":true,\"clusteringKey\":\"7.4\"}],\"end\":[{\"clusteringKey\":\"7.4\"},{\"inclusive\":false,\"clusteringKey\":\"90\"}],\"rows\":[],\"key\":\"drama:2015\"}-- delete range of rows for last clustering column (duration between some values) <br />DELETE FROM movies_by_genre WHERE genre = 'drama' AND year = 2015 AND rating = 7.4 AND duration &gt; 90 AND duration &lt;= 120;{\"rowRangeDeleted\":true,\"start\":[{\"clusteringKey\":\"7.4\"},{\"inclusive\":false,\"clusteringKey\":\"90\"}],\"end\":[{\"clusteringKey\":\"7.4\"},{\"inclusive\":true,\"clusteringKey\":\"120\"}],\"rows\":[],\"key\":\"drama:2015\"}-- delete all rows for specific rating clustering column<br />DELETE FROM movies_by_genre WHERE genre = 'drama' AND year = 2015 AND rating = 7.4;     {\"rowRangeDeleted\":true,\"start\":[{\"inclusive\":true,\"clusteringKey\":\"7.4\"}],\"end\":[{\"inclusive\":true,\"clusteringKey\":\"7.4\"}],\"rows\":[],\"key\":\"drama:2015\"}-- delete range of rows for first clustering column (rating between some values)<br />DELETE FROM movies_by_genre WHERE genre = 'drama' AND year = 2015 AND rating &gt;= 7.5 AND rating &lt;  9.0;{\"rowRangeDeleted\":true,\"start\":[{\"inclusive\":false,\"clusteringKey\":\"9.0\"}],\"end\":[{\"inclusive\":true,\"clusteringKey\":\"7.5\"}],\"rows\":[],\"key\":\"drama:2015\"}-- delete whole partition<br />DELETE FROM movies_by_genre WHERE genre = 'drama' AND year = 2015;{\"partitionDeleted\":true,\"key\":\"drama:2015\"}</pre><p>For most cases, not all of these mutations are used, usually it’s just insert, update and one kind of delete. Here I intentionally tried several ways since it might come in handy to someone. In case you have a simpler table use case, you might be able to simplify the trigger code as well.</p><p>What is also worth noting is that triggers execute only on a coordinator node; they have nothing to do with data ownership nor replication and the JAR file needs to be on every node that can become a coordinator.</p><p><strong>Going a step further</strong></p><p>This is OK for testing purposes, but for this experiment to have any value, I will simulate the mutations to the cassandra cluster at some rate. This can be accomplished in several ways, writing a custom small application, using cassandra stress or using some other tool. Here at SmartCat, we have developed a tool for such purpose. That is the easiest way for me to create load on a Cassandra cluster. The tool is called <a rel=\"noopener noreferrer\" href=\"https://github.com/smartcat-labs/berserker\" target=\"_blank\">Berserker</a>, you can give it a try.</p><p>To start with Berserker, I’ve downloaded the latest version (0.0.7 is the latest at the moment of writing) from <a rel=\"noopener noreferrer\" href=\"https://bintray.com/smartcat-labs/maven/download_file?file_path=io%2Fsmartcat%2Fberserker-runner%2F0.0.7%2Fberserker-runner-0.0.7.jar\" target=\"_blank\">here</a>. And I’ve created a configuration file named configuration.yml.</p><pre class=\"csharpcode\">load-generator-configuration:<br />data-source-configuration-name: Ranger<br />rate-generator-configuration-name: ConstantRateGenerator<br />worker-configuration-name: Cassandra<br />metrics-reporter-configuration-name: JMX<br />thread-count: 10<br />queue-capacity: 100000data-source-configuration:<br />values:<br />genre: random(['horror', 'comedy', 'action', 'sci-fi', 'drama', 'thriller'])<br />year: random(1980..2017)<br />rating: random(float(5.5)..float(9.5))<br />duration: random(85..150)<br />title: random(['Jurassic World', 'Toy Story', 'Deadpool', 'Gravity', 'The Matrix'])<br />director: random(['Philippe Falardeau', 'Martin Scorsese', 'Steven Spielberg', 'Ridley Scott'])<br />insert: string(\"INSERT INTO movies_by_genre (genre, year, rating, duration, title, director) VALUES ('{}', {}, {}, {}, '{}', '{}');\", $genre, $year, $rating, $duration, $title, $director)<br />deleteRow: string(\"DELETE FROM movies_by_genre WHERE genre = '{}' AND year = {} AND rating = {} and duration = {}\", $genre, $year, $rating, $duration)<br />deletePartition: string(\"DELETE FROM movies_by_genre WHERE genre = '{}' AND year = {}\", $genre, $year)<br />statement:<br />consistencyLevel: ONE<br />query: random([$insert, $deleteRow, $deletePartition])<br />output: $statementrate-generator-configuration:<br />rate: 1000worker-configuration:<br />connection-points: 0.0.0.0:32779,0.0.0.0:32781<br />keyspace: custom<br />async: false<br />bootstrap-commands:<br />- \"CREATE KEYSPACE IF NOT EXISTS custom WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 2};\"<br />- USE custom;<br />- CREATE TABLE IF NOT EXISTS movies_by_genre (title text, genre text, year int, rating float, duration int, director text, country text, PRIMARY KEY ((genre, year), rating, duration)) WITH CLUSTERING ORDER BY (rating DESC, duration ASC);metrics-reporter-configuration:<br />domain: berserker<br />filter:</pre><p>load-generator-configuration section is used to specify all other configurations. There, for every type of the configuration, name is specified in order for the Berserker to know which configuration parser to use in concrete sections. After that, a section for each configuration with parser specific options and format is found. There are following sections available: </p><ol><li>data-source-configuration where data source which will generate data for worker is specified</li>\n<li>rate-generator-configuration where should be specified how rate generator will be created and it will generate rate. This rate is rate at which worker will execute</li>\n<li>worker-configuration, configuration for worker</li>\n<li>metrics-reporter-configuration, configuration for metrics reporting, currently only JMX and console reporting is supported</li>\n</ol><p>In this case, the data-source-configuration section is actually a Ranger configuration format and can be found<a rel=\"noopener noreferrer\" href=\"https://github.com/smartcat-labs/ranger/blob/dev/yaml-configuration.md\" target=\"_blank\"> here</a>.</p><p>An important part for this article is the connection-points property within worker-configration. This will probably be different every time Docker compose creates a cluster. To see your connection points run:</p><pre class=\"csharpcode\">docker ps</pre><p>It should give you a similar output:</p><p dir=\"ltr\">There you can find port mapping for cluster_cassandra-seed_1 and cluster_cassandra_1 containers and use it, in this case it is: 0.0.0.0:32779 and 0.0.0.0:32781.</p><p dir=\"ltr\">Now that everything is settled, just run:</p><pre class=\"csharpcode\">java -jar berserker-runner-0.0.7.jar -c configuration.yml</pre><p dir=\"ltr\">Berserker starts spamming the Cassandra cluster and in my terminal where kafka-console-consumer is running, I can see messages appearing, it seems everything is as expected, at least for now.</p><p><strong>End</strong></p><p>That’s all, next time I’ll talk about Cassandra CDC and maybe custom secondary index. Hopefully, in a few blog posts, I’ll have the whole idea tested and running.</p>"}}]}},"pageContext":{"alternative_id":10775}}