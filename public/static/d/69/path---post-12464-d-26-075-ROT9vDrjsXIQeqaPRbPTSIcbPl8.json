{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Setting Up a Cassandra Cluster in AWS - DZone Cloud","alternative_id":12464,"content":"<div class=\"content-html\" itemprop=\"text\"><article class=\"post-section post-2624 post type-post status-publish format-standard hentry category-developer-tips\" id=\"post-2624\"><div class=\"sw-wrapper clearfix\"> \n  <div class=\"post-detail\"> \n   <p>Apache Cassandra is a NoSQL database that allows for easy horizontal scaling, <a href=\"https://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeHashing.html\" rel=\"nofollow\">using the consistent hashing mechanism</a>. <a href=\"https://techblog.bozho.net/why-i-decided-not-to-use-cassandra/\" target=\"_blank\" rel=\"nofollow\">Seven years ago, I tried it and decided not use it for a side-project of mine</a> because it was too new. But things are different now — Cassandra is well-established, there’s a company behind it (DataStax), and there are a lot more tools, documentation, and community support. So once again, I decided to try Cassandra.</p> \n   <p>This time, I need it to run in a cluster on AWS, so I went on to set up such a cluster. Googling how to do it gives several interesting results, like <a href=\"http://highscalability.com/blog/2016/8/1/how-to-setup-a-highly-available-multi-az-cassandra-cluster-o.html\" target=\"_blank\" rel=\"nofollow\">this</a>, <a href=\"https://github.com/cloudurable/cassandra-image/wiki/Cassandra-Tutorial-6:-Setting-up-Cassandra-Cluster-in-EC2-Part-2-Multi-AZs-with-Ec2Snitch\" target=\"_blank\" rel=\"nofollow\">this</a>, and <a href=\"https://wiki.apache.org/cassandra/CloudConfig\" target=\"_blank\" rel=\"nofollow\">this</a>, but they are incomplete, outdated, or have too many irrelevant details. So they are only of moderate help.</p> \n   <p>My goal is to use CloudFormation (or Terraform potentially) to launch a stack that has a Cassandra auto-scaling group (in a single region) that can grow as easily as increasing the number of nodes in the group.</p> \n   <p>Also, in order to have the web application connect to Cassandra without hardcoding the node IPs, I wanted to have a load balancer in front of all Cassandra nodes to do the round-robin for me. The alternative to that would be to have a <a href=\"http://docs.datastax.com/en/drivers/java/2.2/com/datastax/driver/core/policies/DCAwareRoundRobinPolicy.html\" target=\"_blank\" rel=\"nofollow\">client-side round-robin</a>, but that would mean some extra complexity on the client, which seems avoidable with a load balancer in front of the Cassandra auto-scaling group.</p> \n   <p>The relevant bits from my <a href=\"https://gist.github.com/Glamdring/5139bc49037f3b5c1f8cd008ba046df0\" target=\"_blank\" rel=\"nofollow\">CloudFormation JSON can be seen here</a>. Here's what it does:</p> \n   <ul><li>Sets up three private subnets (1 per availability zone in the eu-west region)</li> \n    <li>Creates a security group that allows incoming and outgoing ports that allow Cassandra to accept connections (9042) and for the nodes to gossip (7000/7001). Note that the ports are only accessible from within the VPC — no external connection is allowed. SSH goes only through a <a href=\"https://en.wikipedia.org/wiki/Bastion_host\" target=\"_blank\" rel=\"nofollow\">bastion host</a>.</li> \n    <li>Defines a TCP load balancer for port 9042 where all clients will connect. The load balancer requires a so-called “Target group,” which is defined as well.</li> \n    <li>Configures an auto-scaling group with a pre-configured number of nodes. The autoscaling group has a reference to the “target group”so that the load balancer always sees all nodes in the auto-scaling group.</li> \n    <li>Each node in the auto-scaling group is identical based on a launch configuration. The launch configuration runs a few scripts on initialization. These scripts will be run for every node – either initially, when case a node dies and another one is spawned in its place, or when the cluster has to grow. The scripts are fetched from S3, where you can publish them (and version them) either manually or with an automated process.</li> \n    <li>Note: This does not configure specific EBS volumes and, in reality, you may need to configure and attach them if the instance storage is insufficient. Don’t worry about nodes dying, though, as data is safely replicated.</li> \n   </ul><p>That was the easy part – a bunch of AWS resources and port configurations. The Cassandra-specific setup is a bit harder, as it requires understanding of how Cassandra functions.</p> \n   <p>The two scripts are <a href=\"https://gist.github.com/Glamdring/ee5f24dbef3795a860ac91c9c14255a2\" target=\"_blank\" rel=\"nofollow\">setup-cassandra.sh</a> and <a href=\"https://gist.github.com/Glamdring/d317ff191a223d2bcf7c92fa5fdf3476\" target=\"_blank\" rel=\"nofollow\">update-cassandra-cluster-config.py</a>, so bash and Python: bash for setting-up the machine, and Python for Cassandra-specific stuff. Instead of the bash script, one could use a pre-built AMI (image), e.g. with Packer, but since only two pieces of software are installed, I thought it was a bit of an overhead to support AMIs.</p> \n   <p><a href=\"https://gist.github.com/Glamdring/ee5f24dbef3795a860ac91c9c14255a2\" target=\"_blank\" rel=\"nofollow\">The bash script can be seen here</a>, and simply installs Java 8 and the latest Cassandra, runs the Python script, runs the Cassandra services, and creates (if needed) a keyspace with proper replication configuration. A few notes here – the cassandra.yaml.template could be supplied via the CloudFormation script instead of having it fetched via bash (and having to pass the bucket name); you could also have it fetched in the Python script itself – it’s a matter of preference.</p> \n   <p>Cassandra is not configured for use with SSL, which is generally a bad idea, but the <a href=\"https://github.com/cloudurable/cassandra-image/wiki/Cassandra-Tutorial-2:-Setting-up-client-and-cluster-SSL-transport-in-Cassandra\" target=\"_blank\" rel=\"nofollow\">SSL configuration</a> is out of the scope of this basic setup. Finally, the script waits for the Cassandra process to run (using a while/sleep loop) and then creates the keyspace if needed. The keyspace (=database) has to be created with a NetworkTopologyStrategy, and the number of replicas for the particular datacenter (=AWS region) has to be configured. The value is 3, for the 3 availability zones where we’ll have nodes. That means there’s a copy in each AZ (which is seen like a “rack”, although it’s exactly that).</p> \n   <p><a href=\"https://gist.github.com/Glamdring/d317ff191a223d2bcf7c92fa5fdf3476\" target=\"_blank\" rel=\"nofollow\">The Python script </a>does some very important configurations – without them, the cluster won’t work. (I don’t work with Python normally, so feel free to criticize my Python code). The script does the following:</p> \n   <ul><li>Gets the current auto-scaling group details (using AWS EC2 APIs).</li> \n    <li>Sorts the instances by time.</li> \n    <li>Fetches the first instance in the group in order to assign it as seed node.</li> \n    <li>Sets the seed node in the configuration file (by replacing a placeholder).</li> \n    <li>Sets the listen_address (and therefore rpc_address) to the private IP of the node in order to allow Cassandra to listen for incoming connections.</li> \n   </ul><p>Designating the seed node is important, as all cluster nodes have to join the cluster by specifying at least one seed. You can get the first two nodes instead of just one, but it shouldn’t matter. Note that the seed node is not always fixed – it’s just the oldest node in the cluster. If at some point the oldest node is terminated, each new node will use the second oldest as seed.</p> \n   <p>What I haven’t shown is the cassandra.yaml.template file. It is basically a copy of the cassandra.yaml file from a standard Cassandra installation, with a few changes:</p> \n   <ul><li><code>cluster_name</code> is modified to match your application name. This is just for human-readable purposes, so it doesn’t matter what you set it to.</li> \n    <li><code>allocate_tokens_for_keyspace: your_keyspace</code> is uncommented and the keyspace is set to match your main keyspace. This enables the <a href=\"https://www.datastax.com/dev/blog/token-allocation-algorithm\" target=\"_blank\" rel=\"nofollow\">new token distribution algorithm in Cassandra 3.0</a>. It allows for evenly distributing the data across nodes.</li> \n    <li><code>endpoint_snitch: Ec2Snitch</code> is set instead of the SimpleSnitch to make use of AWS metadata APIs. Note that this setup is in a single region. For multi-region, there’s another snitch and some additional complications of exposing ports and changing the broadcast address.</li> \n    <li>As mentioned above, ${private_ip} and ${seeds} placeholders are placed in the appropriate places (listen_address and rpc_address for the IP) in order to allow substitution.</li> \n   </ul><p>The lets you run a Cassandra cluster as part of your AWS stack, which is auto-scalable and doesn’t require any manual intervention – neither on setup nor on scaling up. Well, allegedly – there may be issues that have to be resolved once you hit the use cases of reality. And for clients to connect to the cluster, simply use the load balancer DNS name (you can print it in a config file on each application node).</p> \n  </div> \n </div> \n</article></div><div class=\"content-html\" itemprop=\"text\"><a>\n                        <img class=\"pub-image\" width=\"420\" itemprop=\"image\" src=\"src\" alt=\"image\" /></a></div>"}}]}},"pageContext":{"alternative_id":12464}}