{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cassandra Query Language (CQL) vs SQL","alternative_id":12000,"content":"<section class=\"section section--body section--middleCenter section-image--aspectRatioViewport is-imageBackgrounded is-backgrounded is-darkBackgrounded u-imageSpectrum section--first\"><div class=\"js-sectionPoint u-ignoreBlock u-textColorTransparentWhite u-absolute u-top0 u-left0\"><div class=\"section-background u-sizeFullWidth u-absolute u-top0 u-cursorDefault u-bottom0\" data-scroll=\"aspect-ratio-viewport\" contenteditable=\"false\" data-image-id=\"1*9gY7eT-NP2W2YIKQLqLSxw.png\" data-width=\"1415\" data-height=\"986\"><div class=\"section-backgroundImage u-absolute u-top0 u-left0 u-right0 u-backgroundCover u-bottom0\"><div class=\"u-ignoreBlock u-absolute0 u-borderRadius3\"><br /></div><div class=\"section-doubleWidthTable u-table u-ignoreBlock\"><div class=\"section-contentCell u-tableCell u-verticalAlignTop u-ignoreBlock\"><div class=\"section-aspectRatioViewportBottomSpacer u-ignoreBlock\"><div class=\"u-ignoreBlock\"></div><div class=\"section-doubleWidthTable u-table u-ignoreBlock\"><div class=\"section-contentCell u-tableCell u-ignoreBlock\"><div class=\"section-content\"><div class=\"section-inner sectionLayout--insetColumn\"><h1 id=\"3dac\" class=\"graf graf--h3 graf--leading graf--title\">Cassandra Query Language</h1><h2 id=\"fd00\" class=\"graf graf--h2 graf-after--h3 graf--trailing\">CQL vs SQL</h2></div></div></div><div class=\"u-tableCell u-verticalAlignTop u-ignoreBlock\"><div class=\"section-aspectRatioViewportPlaceholder u-ignoreBlock\"><div class=\"u-ignoreBlock\"></div><div class=\"section-aspectRatioViewportBottomPlaceholder u-ignoreBlock\"><div class=\"u-ignoreBlock\"></div></div></div></div><div class=\"u-tableCell u-ignoreBlock\"><div class=\"section-aspectRatioViewportCropPlaceholder u-ignoreBlock\"><div class=\"u-ignoreBlock\"></div></div></div><div class=\"section-captionContent u-ignoreBlock\"></div></div></div></div></div></div></div></div></section><section class=\"section section--body section--last\"><div class=\"section-divider\"><hr class=\"section-divider\" /></div><div class=\"section-content\"><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"50fc\" class=\"graf graf--p graf--leading\">When Apache Cassandra was originally released, it featured a command line interface for dealing with <a href=\"https://thrift.apache.org\" data-href=\"https://thrift.apache.org\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">thrift</a>. Manipulating data this way was cumbersome and required learning the details of the API. This introduced an additional hurdle for new users coming from a relational database background. Exposing this low level interface also meant that language-specific drivers often needed to make significant updates from version to version. Clearly, an abstraction was needed.</p><p id=\"803a\" class=\"graf graf--p graf-after--p\">The Cassandra Query Language (CQL) was created to provide the necessary abstraction. CQL is purposefully similar to Structured Query Language (SQL) used in relational databases like MySQL and Postgres. This similarity lowers the barrier of entry for users familiar with relational databases. Many queries are very similar between the two. In fact, a lot of basic things are even exactly the same. The following is both valid CQL and SQL:</p><h3 id=\"8c14\" class=\"graf graf--h3 graf-after--p\">Valid CQL and SQL</h3><pre id=\"0b36\" class=\"graf graf--pre graf-after--h3\"><strong class=\"markup--strong markup--pre-strong\">USE </strong>myDatabase;</pre><pre id=\"7ca6\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">/* Creating Tables */</em><br /><strong class=\"markup--strong markup--pre-strong\">CREATE TABLE IF NOT EXISTS</strong> myTable (id <strong class=\"markup--strong markup--pre-strong\">INT PRIMARY KEY</strong>);</pre><pre id=\"5ed5\" class=\"graf graf--pre graf-after--pre\">/* Altering Tables /*<br /><strong class=\"markup--strong markup--pre-strong\">ALTER</strong> <strong class=\"markup--strong markup--pre-strong\">TABLE</strong> myTable <strong class=\"markup--strong markup--pre-strong\">ADD</strong> myField <strong class=\"markup--strong markup--pre-strong\">INT</strong>;</pre><pre id=\"e95b\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">/* Creating Indexes */</em><br /><strong class=\"markup--strong markup--pre-strong\">CREATE INDEX </strong>myIndex <strong class=\"markup--strong markup--pre-strong\">ON</strong> myTable (myField);</pre><pre id=\"0753\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">/* Inserting Data */</em><br /><strong class=\"markup--strong markup--pre-strong\">INSERT INTO</strong> myTable (id, myField) <strong class=\"markup--strong markup--pre-strong\">VALUES </strong>(1, 7);</pre><pre id=\"ea87\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">/* Selecting Data */</em><br /><strong class=\"markup--strong markup--pre-strong\">SELECT </strong>* <strong class=\"markup--strong markup--pre-strong\">FROM </strong>myTable <strong class=\"markup--strong markup--pre-strong\">WHERE </strong>myField = 7;</pre><pre id=\"eb4e\" class=\"graf graf--pre graf-after--pre\">/* Counting Data */<br /><strong class=\"markup--strong markup--pre-strong\">SELECT COUNT</strong>(*) <strong class=\"markup--strong markup--pre-strong\">FROM </strong>myTable;</pre><pre id=\"e4bd\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">/* Deleting Data */</em><br /><strong class=\"markup--strong markup--pre-strong\">DELETE FROM </strong>myTable <strong class=\"markup--strong markup--pre-strong\">WHERE </strong>myField = 7;</pre><p id=\"cc89\" class=\"graf graf--p graf-after--pre\">From this, its easy to think that the two languages work just the same. But there are quite a few differences once you get beyond the basics.</p><h3 id=\"e296\" class=\"graf graf--h3 graf-after--p\">Differences</h3><p id=\"f43a\" class=\"graf graf--p graf-after--h3\">Cassandra is a non-relational database, and so uses different concepts to store and retrieve data. Simplistically, a Cassandra <em class=\"markup--em markup--p-em\">keyspace</em> is a SQL <em class=\"markup--em markup--p-em\">database</em>, and a Cassandra <em class=\"markup--em markup--p-em\">column family </em>is a SQL <em class=\"markup--em markup--p-em\">table</em> (CQL allows you to interchange the words “TABLE” and “COLUMNFAMILY” for convenience). This difference necessitates a different syntax for creating and manipulating data:</p><h4 id=\"b957\" class=\"graf graf--h4 graf-after--p\">Creating databases:</h4><pre id=\"f37e\" class=\"graf graf--pre graf-after--h4\"><em class=\"markup--em markup--pre-em\">/* Create a new keyspace in CQL */</em><br /><strong class=\"markup--strong markup--pre-strong\">CREATE KEYSPACE</strong> myDatabase <strong class=\"markup--strong markup--pre-strong\">WITH </strong>replication = <br />   {'class': 'SimpleStrategy', 'replication_factor': 1};<em class=\"markup--em markup--pre-em\">/* Create a new database in SQL */</em><br /><strong class=\"markup--strong markup--pre-strong\">CREATE DATABASE</strong> myDatabase;</pre><p id=\"1fec\" class=\"graf graf--p graf-after--pre\">Cassandra’s keyspaces require more specifications than a standard relational database. Note that the example above is the simplest form. In a production environment, likely spread across several data-centers, a keyspace would be created with a different strategy and replication factor.</p><h4 id=\"55f0\" class=\"graf graf--h4 graf-after--p\">Organizing Data</h4><p id=\"b782\" class=\"graf graf--p graf-after--h4\">None of the standard relational stuff is going to work in CQL. There is no support for things like <strong class=\"markup--strong markup--p-strong\">JOIN</strong>,<strong class=\"markup--strong markup--p-strong\"> GROUP BY</strong>, or <strong class=\"markup--strong markup--p-strong\">FOREIGN KEY</strong>. Leaving these features out is important because it makes writing and retrieving data from Cassandra much more efficient.</p><p id=\"ce8c\" class=\"graf graf--p graf-after--p\">But sets of data tend to have relationships with one another. So without the relational tools of SQL, we need another strategy to represent these relationships. The problem is that reads in Cassandra tend to be more expensive than you might be used to when dealing with a relational database. But there is a filp side to this. And if you take only one thing away from this post, let it be this:</p><p id=\"4748\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\"><em class=\"markup--em markup--p-em\">Writes are cheap. Write everything the way you want to read it.</em></strong></p><p id=\"8b6a\" class=\"graf graf--p graf-after--p\">In other words, any query you plan to do in the future should already be organized into a column family. You want to look up addresses that correspond to a person? Then make a column family that consists of people and addresses. You can still store them separately, but you should also store them together. Having a column family to represent every query makes reads much more efficient. You’re not just going to have to de-normalize, you’re going to have to forget about normalization all together.</p><h4 id=\"9cec\" class=\"graf graf--h4 graf-after--p\">Inserts vs Updates</h4><p id=\"10d8\" class=\"graf graf--p graf-after--h4\">The concept of cheap writes extends to updating data. This is because, unlike in SQL, a read is not performed during the update. The syntax is the same in CQL and SQL.</p><pre id=\"19c7\" class=\"graf graf--pre graf-after--p\"><em class=\"markup--em markup--pre-em\">/* Updating data */</em><strong class=\"markup--strong markup--pre-strong\"><br />UPDATE </strong>myTable <strong class=\"markup--strong markup--pre-strong\">SET </strong>myField = 2 <strong class=\"markup--strong markup--pre-strong\">WHERE </strong>id = 6;</pre><p id=\"9e08\" class=\"graf graf--p graf-after--pre\">However, if the row does not exist, it will still get created. Similarly as unintuitive, an <strong class=\"markup--strong markup--p-strong\">INSERT </strong>statement will actually replace data if it exists. Because again, CQL does not perform a read while inserting. Without a read, there is no way to know if the data being inserted is replacing an existing record. This means that both inserts and updates are extremely fast.</p><h4 id=\"1749\" class=\"graf graf--h4 graf-after--p\">Time to Live</h4><p id=\"3090\" class=\"graf graf--p graf-after--h4\">CQL enables you to set a TTL on a row. Meaning that you can set a row to expire 24 hours from the time it gets created. This is accomplished with the <strong class=\"markup--strong markup--p-strong\">USING TTL</strong> command (values are in seconds).</p><pre id=\"76d9\" class=\"graf graf--pre graf-after--p\"><em class=\"markup--em markup--pre-em\">/* Expiring Data in 24 Hours */</em><br /><strong class=\"markup--strong markup--pre-strong\">INSERT INTO </strong>myTable (id, myField) <strong class=\"markup--strong markup--pre-strong\">VALUES </strong>(2, 9) <strong class=\"markup--strong markup--pre-strong\">USING TTL</strong> 86400;</pre><p id=\"e4ca\" class=\"graf graf--p graf-after--pre\">Twenty-four hours after that query is executed, the data will be deleted. Well, actually…</p><h4 id=\"5cb3\" class=\"graf graf--h4 graf-after--p\">Deletions</h4><p id=\"f401\" class=\"graf graf--p graf-after--h4\">Executing a DELETE in CQL does not actually delete data. But deletions are a topic of their own. DataStax has a great <a href=\"http://www.datastax.com/documentation/cassandra/2.0/cassandra/dml/dml_about_deletes_c.html\" data-href=\"http://www.datastax.com/documentation/cassandra/2.0/cassandra/dml/dml_about_deletes_c.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">introduction to Cassandra deletions</a> that I would definitely recommend reading.</p><h3 id=\"73fe\" class=\"graf graf--h3 graf-after--p\">Performance Issues</h3><p id=\"a811\" class=\"graf graf--p graf-after--h3\">Scaling Cassandra can be daunting the first time around. But when you inevitably run into performance issues, there are a few things you can look at, in addition to the things mentioned above.</p><h4 id=\"85c8\" class=\"graf graf--h4 graf-after--p\">Tracing Queries</h4><p id=\"57a4\" class=\"graf graf--p graf-after--h4\">There is a command in CQL that allows you to trace queries across nodes and data centers, showing some useful debugging information.</p><pre id=\"d671\" class=\"graf graf--pre graf-after--p\"><em class=\"markup--em markup--pre-em\">/* Enable query traces */</em><br /><strong class=\"markup--strong markup--pre-strong\">TRACING ON</strong>;</pre><pre id=\"c40a\" class=\"graf graf--pre graf-after--pre\">/* Disable query traces */<br /><strong class=\"markup--strong markup--pre-strong\">TRACING OFF</strong>;</pre><p id=\"b040\" class=\"graf graf--p graf-after--pre\">This will show the full network path the query takes, along with the latency at each step. This is helpful for verifying assertions about the replication factor or the connectivity between nodes and data centers. Note that tracing is expensive and should be used sparingly. You definitely do not want it on for all your production queries.</p><h4 id=\"1403\" class=\"graf graf--h4 graf-after--p\">Filtering</h4><p id=\"6a6d\" class=\"graf graf--p graf-after--h4\">If you attempt to run a SELECT across a large range of values, you might end up with an error message.</p><pre id=\"58df\" class=\"graf graf--pre graf-after--p\"><em class=\"markup--em markup--pre-em\">/* Select Data within a range */</em><br /><strong class=\"markup--strong markup--pre-strong\">SELECT </strong>* <strong class=\"markup--strong markup--pre-strong\">FROM </strong>myTable <strong class=\"markup--strong markup--pre-strong\">WHERE </strong>myField &gt; 5000 <strong class=\"markup--strong markup--pre-strong\">AND </strong>myField &lt; 100000;</pre><pre id=\"6b50\" class=\"graf graf--pre graf-after--pre\"><em class=\"markup--em markup--pre-em\">Bad Request: Cannot execute this query as it might involve data<br />filtering and thus may have unpredictable performance. If you want<br />to execute this query despite the performance unpredictability,<br />use ALLOW FILTERING.</em></pre><p id=\"15d7\" class=\"graf graf--p graf-after--pre\">I think the error message here speaks for itself. If you’re allowing filtering on your CQL queries, think above whether or not you really need to do that.</p><h3 id=\"be01\" class=\"graf graf--h3 graf-after--p\">Conclusion</h3><p id=\"92d8\" class=\"graf graf--p graf-after--h3\">The similarity between CQL and SQL is really a double edged sword. While you should enjoy the easy-to-learn syntax, take the time to understand the differences. There is a lot more to Cassandra than I could possibly cover here. If you’re writing production queries for the first time, I would recommend reading up on the query you’re writing, even if it is something as simple as a SELECT. The <a href=\"http://www.datastax.com/documentation/cql/3.1/cql/cql_intro_c.html\" data-href=\"http://www.datastax.com/documentation/cql/3.1/cql/cql_intro_c.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">DataStax CQL documentation</a> is particularly helpful in calling out caveats and providing helpful examples.</p><h4 id=\"5cf6\" class=\"graf graf--h4 graf-after--p\">Further Reading</h4><ul class=\"postList\"><li id=\"959b\" class=\"graf graf--li graf-after--h4\"><a href=\"http://planetcassandra.org/what-is-apache-cassandra/\" data-href=\"http://planetcassandra.org/what-is-apache-cassandra/\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">What is Apache Cassandra?</a></li><li id=\"a9c6\" class=\"graf graf--li graf-after--li\"><a href=\"http://www.ebaytechblog.com/2012/07/16/cassandra-data-modeling-best-practices-part-1\" data-href=\"http://www.ebaytechblog.com/2012/07/16/cassandra-data-modeling-best-practices-part-1\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Cassandra Data Modeling Best Practices</a></li><li id=\"d7bc\" class=\"graf graf--li graf-after--li\"><a href=\"http://www.slideshare.net/johnny15676/introduction-to-cql-and-data-modeling\" data-href=\"http://www.slideshare.net/johnny15676/introduction-to-cql-and-data-modeling\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Introduction to CQL and Data Modeling</a></li><li id=\"27f1\" class=\"graf graf--li graf-after--li graf--trailing\"><a href=\"http://techblog.netflix.com/search/label/Cassandra\" data-href=\"http://techblog.netflix.com/search/label/Cassandra\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Cassandra posts on the Netflix Tech Blog</a></li></ul></div></div></section>"}}]}},"pageContext":{"alternative_id":12000}}