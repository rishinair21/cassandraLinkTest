{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Building a Performant API using Go and Cassandra","alternative_id":4872,"content":"<h2>Introduction</h2><p>Software performance is critical to a SaaS company like <a href=\"https://getstream.io/\">Stream</a> and while the majority of our infrastructure is written in Python, we are actively porting portions of our code base to Go.</p>\n<p>Stream is an API for building scalable feeds and now handles over 20 billion feed updates a month. While Python has been fast enough for many things, the additional speed and efficiency of Go is becoming important to us. (If you’ve never tried Stream, here’s a <a href=\"https://getstream.io/get_started/?utm_source=blog&amp;utm_campaign=growth&amp;utm_medium=go-api#intro\">5 minute interactive tutorial</a>)</p>\n<p>This migration from other scripting languages like Python to Go is becoming pretty commonplace in our industry. Before Stream I worked as a lead engineer at SendGrid for 4 years and the last 18 months was spent replacing sluggish code from Ruby and Python, and writing internal and external APIs, in more performant Go.</p>\n<p>This tutorial will teach you how to build a RESTful API using Go and Cassandra. Cassandra is a NoSQL database that automatically shards your data across a cluster of machines. Here at Stream we use Cassandra for the storage of news feeds and activity streams. it’s performance, linear scalability and reliability make it the #1 datastore for many large platforms such as Netflix, GitHub, Reddit, Instagram, Sony, Coursera, Spotify, and eBay.</p>\n<p>The source code for this tutorial can be found on our <a href=\"https://github.com/GetStream/Stream-Example-Go-Cassandra-API/\">GitHub repository</a>.</p>\n<h2>Step 1 – Cassandra</h2>\n<p>By far, the easiest way to get Cassandra installed and running is to use the <a href=\"https://github.com/pcmanus/ccm\">Cassandra Cluster Management script</a>, and we’ll use <a href=\"http://brew.sh\">homebrew</a> for setting up tooling on a Mac; setup on Linux should be very similar but your mileage may vary on Windows platforms. Running “brew install ccm” will get you started, and we’ll also need a Java environment, which is bundled in the “maven” package.</p>\n<h3>A. Cassandra Setup</h3>\n<pre class=\"language-bash\">$ brew install ccm maven</pre>\n<p>To query Cassandra from the command line we need a tool called cqlsh. You can easily install the cqlsh command with pip:</p>\n<pre class=\"language-bash\">$ pip install cqlsh==5.0.3</pre>\n<p>To begin, we need to install Cassandra and create a cluster. The following command downloads and install Cassandra v3.9 and creates a cluster named streamdemoapi</p>\n<pre class=\"language-bash\">$ ccm create -v 3.9 streamdemoapi</pre>\n<p>Next we need to add one or more nodes to our cluster. For the tutorial we only need a single node:</p>\n<pre class=\"language-bash\">$ ccm populate -n 1&#13;\n$ ccm start</pre>\n<p>You can verify the cluster booted correctly by running ccm status.</p>\n<pre class=\"language-bash\">$ ccm status</pre>\n<p>Finally we create a keyspace with single-node replication. If we had set up multiple nodes in the previous step, we could specify how many nodes we wanted to replicate data onto.</p>\n<pre class=\"language-bash\">$ echo \"CREATE KEYSPACE streamdemoapi WITH \\&#13;\nreplication = {'class': 'SimpleStrategy', 'replication_factor' : 1};\" | cqlsh --cqlversion 3.4.2</pre>\n<p>Congratulations, you now have a Cassandra cluster + keyspace up and running.</p>\n<p>Note: For a production Cassandra setup there are more things to keep in mind: We recommend starting at Datastax and browsing <a href=\"https://academy.datastax.com/tutorials?field_topics_tid=714\">their tutorial series</a> on using Cassandra.</p>\n<h3>B. Cassandra Schema</h3>\n<p>We will define two tables to hold our data for users and messages. We recommend using UUIDs for unique resource identifiers when sending an activity to Stream, so we’ve used UUIDs as our primary key in our table structures to identify each message and user in our system.</p>\n<pre class=\"language-bash\">$ echo \"&#13;\nuse streamdemoapi;&#13;\ncreate table messages (&#13;\nid UUID,&#13;\nuser_id UUID,&#13;\nMessage text,&#13;\nPRIMARY KEY(id)&#13;\n);\" | cqlsh --cqlversion 3.4.2</pre>\n<p>Our user table will contain some simple data about each person using our application, including their first name, last name, age, city and email address.</p>\n<pre class=\"language-bash\">$ echo \"&#13;\nuse streamdemoapi;&#13;\nCREATE TABLE users (&#13;\nid UUID,&#13;\nfirstname text,&#13;\nlastname text,&#13;\nage int,&#13;\nemail text,&#13;\ncity text,&#13;\nPRIMARY KEY (id)&#13;\n);\" | cqlsh --cqlversion 3.4.2</pre>\n<h2>Step 2 – Go</h2>\n<p>Installing Go on a Mac is super easy with homebrew. Installation instructions for Linux and Windows can be found at <a href=\"https://golang.org/dl/\">golang.org</a>. The current version as of this writing is Go 1.7.4.</p>\n<h3>A. Go setup</h3>\n<p>Let’s install the binaries and standard library for Go on our Mac:</p>\n<pre class=\"language-bash\">$ brew install go</pre>\n<p>With the binary installed, we will need to configure the “GOPATH” folder where we’ll install third-party Go libraries and packages. Within your terminal shell configuration (for example, .bashrc or .zshrc) we will add some new environment settings:</p>\n<pre class=\"language-bash\">export GOPATH=$HOME/golang&#13;\nexport GOROOT=/usr/local/opt/go/libexec</pre>\n<p>The GOROOT setting tells our shell where to find Go binaries and the standard libraries. This may not be required on your system if you’re using Go 1.7 or better, as it can find the path on its own if the main “go” binary itself in your PATH.</p>\n<p>Restart your shell, or source your shell configuration file, and then create this new path:</p>\n<pre class=\"language-bash\">$ mkdir $HOME/golang</pre>\n<h3>B. Go Dependencies</h3>\n<p>Go can be very peculiar about dependency management and the Golang team recommends “vendoring” your dependencies within the same folder as your project source code to ensure you don’t have to worry about running “go get” in the future and ending up with a newer version of a library than your code can utilize. Our tutorial will install all packages within our GOPATH for simplicity.</p>\n<p>With our GOPATH defined above, we can install third-party Go packages, such as the Cassandra client, by running the “go get” command followed by the origin of the package. To install the Cassandra driver for our project, we’ll issue the following command:</p>\n<pre class=\"language-bash\">$ go get github.com/gocql/gocql</pre>\n<p>You will find the new package installed under your home folder, in the “golang” folder we created above, in a subfolder called “src”. In that src folder, you’ll see another folder for github.com and so on for each of the packages you install.</p>\n<p>For our project we’ll also need the following libraries which we’ll describe later in this tutorial:</p>\n<pre class=\"language-bash\">$ go get github.com/gorilla/mux&#13;\n$ go get github.com/GetStream/stream-go</pre>\n<p>If you are creating a Go application that will not have subpackages, you can develop the code anywhere on your filesystem. However, since this application (and most other apps you will develop) will use subpackages, your code must live in your GOPATH folder.</p>\n<p>To make sure you’re in the correct folder to begin your code, navigate to your GOPATH/src folder with this command:</p>\n<pre class=\"language-bash\">$ cd $GOPATH/src</pre>\n<p>Since you will have your code in a repository somewhere, you will place your project code in a folder based on your username and project name. For example, if your username on GitHub was johnsmith and your project was awesomeproject, then you would create your project under the following path:</p>\n<pre class=\"language-bash\">$ mkdir $GOPATH/src/github.com/johnsmith/awesomeproject&#13;\n$ cd $GOPATH/src/github.com/johnsmith/awesomeproject</pre>\n<p>Technically, it doesn’t matter what this path is, but this is a common standard employed by other Go developers, so it will cause fewer problems if you conform to this standard.</p>\n<p>At this point, you can start writing your code!</p>\n<h2>Step 3 – Your first REST endpoint</h2>\n<p>When we’re all finished with this tutorial, our API contract will look something like this:</p>\n<blockquote><p>GET / — heartbeat check if our API is online</p>\n<p>GET /users — fetch all users from the database<br />GET /users/UUID — fetch an individual user from the database<br />POST /users/new — create a new user</p>\n<p>GET /messages — fetch all messages from Stream (with the database as a backup)<br />GET /messages/UUID — fetch an individual message from the database<br />POST /messages/new — create a new message</p></blockquote>\n<p>One big question faced by a lot of Go API developers is whether to use a third-party web framework or to use the standard libraries which ship with Go. In my experience building APIs with both standard libraries and third-party frameworks, I think it’s really a personal call. Certainly, rewriting advanced routing rules and dispatch/middleware handlers every time you create an application with the standard libraries is time-consuming, but using third-party frameworks can often place constraints on your code where you must do things “their” way. The standard library is certainly more than capable of managing a simple API setup, but sometimes it’s nice to have well-tested third-party code that make it easier and quicker to get started.</p>\n<p>In our example application, we opted to use the popular <a href=\"https://github.com/gorilla/mux\">gorilla/mux project</a> to build our API.</p>\n<p>Let’s start with the heartbeat endpoint.</p>\n<p><strong>Go #protip:</strong> Good project structure in Go means as little logic in your applications’ /main.go starting point, and breaking down other logic/branches into subfolders to separate your code’s concerns, so code we write after this part of the tutorial will all go into subfolders, which creates subpackages.</p>\n<p>The first line of your Go script is the name of your package, and Go will always expect the root level of your project to be a package called “main”. We must tell our Go script which other libraries we intend to use with the “import” command. To get started with gorilla/mux and a basic API endpoint for a status check (also called a “heartbeat”). Create a file called main.go at the base of your project folder (ie, johnsmith/awesomeproject/main.go) and add the following code:</p>\n<pre class=\"language-go\">package main&#13;\n&#13;\nimport (&#13;\n  \"net/http\"&#13;\n  \"log\"&#13;\n  \"encoding/json\"&#13;\n  \"github.com/gorilla/mux\"&#13;\n)</pre>\n<p>In order for gorilla/mux to return any payload, we must define the exact structure of the data. In our example we will send back a string for “status” and an integer for a status code. For example, if our API is running successfully, we could send back a status of “OK” and a code of 200, which is a typical HTTP response for a successful web connection.</p>\n<pre class=\"language-go\">type heartbeatResponse struct {&#13;\n  Status string `json:\"status\"`&#13;\n  Code int `json:\"code\"`&#13;\n}</pre>\n<p>The <code class=\"language-go\">`json:”status”`</code> portion of the field definition above will tell our JSON-encoder to rename the “Status” and “Code” fields during the encoding process to their lowercase versions.</p>\n<p>Next, we define our “main” function, which is a reserved name in Go for where your code will begin. Within our main function, we need to set up a new gorilla/mux router to handle our API endpoints according to the contract we described above. We can add a new API route after our router is declared, and give it the name of another function to execute when a request is made for that endpoint. In this case, we’ll call a new function called heartbeat:</p>\n<pre class=\"language-go\">func main() {&#13;\n  router := mux.NewRouter().StrictSlash(true)&#13;\n  router.HandleFunc(\"/\", heartbeat)&#13;\n  log.Fatal(http.ListenAndServe(\":8080\", router))&#13;\n}</pre>\n<p>The last line of code tells Go to listen on port 8080, which will also log any errors returned and throw a fatal error to crash our application.</p>\n<p>Finally, we must declare our <code>heartbeat()</code> function for the “/” endpoint, so we’ll add code this after our main() function:</p>\n<pre class=\"language-go\">func heartbeat(w http.ResponseWriter, r *http.Request) {&#13;\n  json.NewEncoder(w).Encode(heartbeatResponse{Status: \"OK\", Code: 200})&#13;\n}</pre>\n<p>The handler code inside heartbeat() tells gorilla/mux to use a JSON encoder on our output handle (our http.ResponseWriter variable simply called “w”), and encode our data structure that we defined above our main() function which we called heartbeatResponse, and to set our “OK” status string, and our status code of 200, indicating our API is running properly.</p>\n<p>Now we save our code, and we can execute it in our terminal by running the following command:</p>\n<pre class=\"language-bash\">$ go run main.go</pre>\n<p>If there are no errors, you won’t see any output, and the program will appear to “hang” but it’s actually running in the background, listening on port 8080. To test this, open your browser and go to the following address:</p>\n<p>http://localhost:8080/</p>\n<p>If all goes well, you should see some JSON text in your browser which says:</p>\n<pre class=\"language-json\">{“status”: “OK”, “code”: 200}</pre>\n<p>To stop the API from running, you can press CTRL-C to kill the Go application.</p>\n<p>Congratulations — you’ve created a Go-powered API! It’s not terribly useful yet, though, so we can continue adding code, such as the remaining routes for our API contract for getting or creating users and messages. In our final /main.go code, linked below, we’ll also connect to our local Cassandra instance and verify our Stream credentials allow us to connect.</p>\n<p>Final Source: <a href=\"https://github.com/GetStream/Stream-Example-Go-Cassandra-API/blob/master/main.go\">/main.go</a></p>\n<h2>Step 4 – Using Cassandra in Go</h2>\n<div class=\"protip\"><strong>Go #protip:</strong>When you import submodules in Go, any packages containing a method called<code>init()</code>will have all of those init() functions called immediately before the process’<code>main()</code>function. The caution here is that if you have several submodules with init() functions declared, there is no guarantee of run order so you must ensure you don’t inadvertently impose a required order by having mixed dependencies. If you must have these initializations happen in a specific order, it’s best to declare an exported method in each submodule and call them explicitly from your process’ main() function.</div>\n<p>Because the Cassandra code will live in a subfolder called Cassandra, it becomes a subpackage to our primary Go code, and therefore must have a new package name, declared on the first line of our code. Next, we will import the GoCQL library package. (we also import the “fmt” standard library to print a message when we are connected to Cassandra)</p>\n<p>Create a file Cassandra/main.go and add this code:</p>\n<pre class=\"language-go\">package Cassandra&#13;\n&#13;\nimport (&#13;\n  \"github.com/gocql/gocql\"&#13;\n  \"fmt\"&#13;\n)</pre>\n<p>In order to use our Cassandra connection elsewhere in our code, we will declare a variable called <code>Session</code>. To use a subpackage variable in other code outside of this subfolder, we must name the variable with the first letter as an uppercase letter. A variable named “session” (all lowercase) will not be visible to other packages.</p>\n<pre class=\"language-go\">var Session *gocql.Session</pre>\n<p>Next, we will declare our init() function which will run as soon as our API code executes (but before our application’s /main.go main() function is run):</p>\n<pre class=\"language-go\">func init() {&#13;\n  var err error&#13;\n&#13;\n  cluster := gocql.NewCluster(\"127.0.0.1\")&#13;\n  cluster.Keyspace = \"streamdemoapi\"&#13;\n  Session, err = cluster.CreateSession()&#13;\n  if err != nil {&#13;\n    panic(err)&#13;\n  }&#13;\n  fmt.Println(\"cassandra init done\")&#13;\n}</pre>\n<p>To connect to Cassandra, we use the GoSQL NewCluster() method and pass an IP address or hostname and store that connection in a variable called “cluster”. Next, we declare which cluster name we wish to use; in this case we define “streamdemoapi” as our cluster name. Finally, we create a session on the cluster and assign that to our exportable Session variable.</p>\n<p>The <a href=\"https://github.com/gocql/gocql\">GoCQL project</a> makes interfacing with Go super easy, and many queries can be written just like common SQL for selecting or inserting data into a database, which we’ll show in the next submodule.</p>\n<p>The last steps are to add one more import to our application’s /main.go (not in Cassandra/main.go):</p>\n<pre class=\"language-go\">package main&#13;\n&#13;\nimport (&#13;\n  ...&#13;\n  \"github.com/username/projectname/Cassandra\"&#13;\n  ...&#13;\n)</pre>\n<p>And finally we tell our application’s /main.go main() function to defer closing our Cassandra connection:</p>\n<pre class=\"language-go\">func main() {&#13;\n  CassandraSession := Cassandra.Session&#13;\n  defer CassandraSession.Close()&#13;\n&#13;\n  router := mux.NewRouter().StrictSlash(true)&#13;\n  ...&#13;\n}</pre>\n<p>The first line will utilize our Cassandra session from our subpackage and store that in a new local variable. The <code>defer</code> line tells Go to disconnect from Cassandra if the application’s /main.go main() function exits for any reason.</p>\n<p>You can verify everything worked by running:</p>\n<pre class=\"language-bash\">$ go run main.go</pre>\n<p>And you should see a message in your terminal that the Cassandra initialization is done.</p>\n<p>Final source: <a href=\"https://github.com/GetStream/Stream-Example-Go-Cassandra-API/blob/master/Cassandra/main.go\">Cassandra/main.go</a></p>\n<h2>Step 5 – Creating and Reading Users</h2>\n<h3>A. Creating Users</h3>\n<p>To create or fetch user data from Cassandra, we create a sub-package (and folder) called Users and have our data structures and logic split into separate files within that folder. All files within this folder must also have a matching package declaration that is different from all other subpackages in our application.</p>\n<pre class=\"language-go\">package Users</pre>\n<p>Create a file, Users/structs.go, to contain our data structures, and Users/processing.go for handling form data. You can refer to our GitHub source for the exact code, links are below, and we’ll describe these in detail later. To simplify getting started right now:</p>\n<p>&gt;&gt; Copy <a href=\"https://raw.githubusercontent.com/GetStream/Stream-Example-Go-Cassandra-API/master/Users/structs.go\">this file</a> to your project as Users/structs.go<br />&gt;&gt; Copy <a href=\"https://raw.githubusercontent.com/GetStream/Stream-Example-Go-Cassandra-API/master/Users/processing.go\">this file</a> to your project as Users/processing.go</p>\n<p>To add data to Cassandra, we will create a file called Users/post.go to handle our POST operation on our API.</p>\n<p>In our imports, we will include a reference to our Cassandra subpackage</p>\n<pre class=\"language-go\">package Users&#13;\n&#13;\nimport (&#13;\n\"net/http\"&#13;\n\"github.com/gocql/gocql\"&#13;\n\"encoding/json\"&#13;\n\"github.com/username/projectname/Cassandra\"&#13;\n\"fmt\"&#13;\n)</pre>\n<p>We will make a function called Post() which take a request and response variable from gorilla/mux. Let’s explain what happens within the function:</p>\n<pre class=\"language-go\">func Post(w http.ResponseWriter, r *http.Request) {&#13;\n  var errs []string&#13;\n  var gocqlUuid gocql.UUID&#13;\n&#13;\n  // FormToUser() is included in Users/processing.go&#13;\n  // we will describe this later&#13;\n  user, errs := FormToUser(r)&#13;\n&#13;\n  // have we created a user correctly&#13;\n  var created bool = false&#13;\n&#13;\n  // if we had no errors from FormToUser, we will&#13;\n  // attempt to save our data to Cassandra&#13;\n  if len(errs) == 0 {&#13;\n    fmt.Println(\"creating a new user\")&#13;\n&#13;\n    // generate a unique UUID for this user&#13;\n    gocqlUuid = gocql.TimeUUID()&#13;\n&#13;\n    // write data to Cassandra&#13;\n    if err := Cassandra.Session.Query(`&#13;\n      INSERT INTO users (id, firstname, lastname, email, city, age) VALUES (?, ?, ?, ?, ?, ?)`,&#13;\n      gocqlUuid, user.FirstName, user.LastName, user.Email, user.City, user.Age).Exec(); err != nil {&#13;\n      errs = append(errs, err.Error())&#13;\n    } else {&#13;\n      created = true&#13;\n    }&#13;\n  }&#13;\n&#13;\n  // depending on whether we created the user, return the&#13;\n  // resource ID in a JSON payload, or return our errors&#13;\n  if created {&#13;\n    fmt.Println(\"user_id\", gocqlUuid)&#13;\n    json.NewEncoder(w).Encode(NewUserResponse{ID: gocqlUuid})&#13;\n  } else {&#13;\n    fmt.Println(\"errors\", errs)&#13;\n    json.NewEncoder(w).Encode(ErrorResponse{Errors: errs})&#13;\n  }&#13;\n}</pre>\n<p>Next, if our application’s main.go, we need to add the Users subpackage to our imports and add a new REST endpoint to our gorilla/mux router to call this Post() method:</p>\n<pre class=\"language-go\">import (&#13;\n  ...&#13;\n  \"github.com/username/projectname/Cassandra\"&#13;\n  \"github.com/username/projectname/Users\"&#13;\n  ...&#13;\n)&#13;\n&#13;\nfunc main() {&#13;\n  ...&#13;\n  router := mux.NewRouter().StrictSlash(true)&#13;\n  router.HandleFunc(\"/\", Heartbeat)&#13;\n  router.HandleFunc(\"/users/new\", Users.Post)&#13;\n  ...&#13;\n}</pre>\n<h3>Testing our new endpoint</h3>\n<p>&gt;&gt;&gt; Curl example of posting to the User endpoint</p>\n<pre class=\"language-bash\">curl -X POST \\&#13;\n-H \"Content-Type: application/x-www-form-urlencoded\" \\&#13;\n-d 'firstname=Ian&amp;lastname=Douglas&amp;city=Boulder&amp;email=ian@getstream.io&amp;age=42' \\&#13;\n\"http://localhost:8080/users/new\"</pre>\n<p>The response you get should look similar to:</p>\n<pre class=\"language-json\">{\"id\":\"75a243c1-e356-11e6-81c2-c4b301bb0fa9\"}</pre>\n<p>Now that we’ve tested that our POST operation works, let’s rewind and describe what Users/processing.go is actually doing.</p>\n<p>At a high level, gorilla/mux provides a method on your request interface called PostFormValue which takes a string parameter and returns a string of data (or empty string if the parameter was not present in the form data). We check the string length for each parameter that we require and if the length is 0 we push an error onto an array and return those errors to the user. We cycle through all form variables we expect to find and also validate that the age parameter is an integer.</p>\n<p>Let’s look at this closer:</p>\n<p>Our Users/processing.go file is part of our Users subpackage, and imports a few standard libraries.</p>\n<pre class=\"language-go\">package Users&#13;\n&#13;\nimport (&#13;\n  \"net/http\"&#13;\n  \"strconv\"&#13;\n)</pre>\n<p>Next, we have a function which allows us to append a string onto an existing array of strings. Go does not have a built-in mechanism for this, so we wrote our own:</p>\n<pre class=\"language-go\">func appendError(errs []string, errStr string) ([]string) {&#13;\n  if len(errStr) &gt; 0 { &#13;\n    errs = append(errs, errStr)&#13;\n  }&#13;\n  return errs&#13;\n}</pre>\n<p>Now we’ll define a function which will take our request interface, and a string, and return the field data or an error in one of two return positions. As mentioned above, gorilla/mux has a PostFormValue() method defined for us to fetch form data from an HTTP request.</p>\n<pre class=\"language-go\">func processFormField(r *http.Request, field string) (string, string) {&#13;\n  fieldData := r.PostFormValue(field)&#13;\n  if len(fieldData) == 0 {&#13;\n    return \"\", \"Missing '\" + field + \"' parameter, cannot continue\"&#13;\n  }&#13;\n  return fieldData, \"\"&#13;\n}</pre>\n<p>Finally, we have our code that cycles through each of the fields we deem to be “required” fields on our form data:</p>\n<pre class=\"language-go\">func FormToUser(r *http.Request) (User, []string) {&#13;\n  var user User&#13;\n  var errStr, ageStr string&#13;\n  var errs []string&#13;\n  var err error&#13;\n&#13;\n  user.FirstName, errStr = processFormField(r, \"firstname\")&#13;\n  errs = appendError(errs, errStr)&#13;\n  user.LastName, errStr = processFormField(r, \"lastname\")&#13;\n  errs = appendError(errs, errStr)&#13;\n  user.Email, errStr = processFormField(r, \"email\")&#13;\n  errs = appendError(errs, errStr)&#13;\n  user.City, errStr = processFormField(r, \"city\")&#13;\n  errs = appendError(errs, errStr)&#13;\n  &#13;\n  ageStr, errStr = processFormField(r, \"age\")&#13;\n  if len(errStr) != 0 {&#13;\n    errs = append(errs, errStr)&#13;\n  } else {&#13;\n    user.Age, err = strconv.Atoi(ageStr)&#13;\n    if err != nil {&#13;\n      errs = append(errs, \"Parameter 'age' not an integer\")&#13;\n    }&#13;\n  }&#13;\n  return user, errs&#13;\n}</pre>\n<h3>B. Reading users</h3>\n<p>The Users/get.go script handles our two GET requests: Get() is called for fetching all users (http://localhost:8080/users), and GetOne() to fetch a single user with a resource ID (http://localhost:8080/users/UUID).</p>\n<p>We start out by declaring our package name and our imports. Because we’ll be pulling data from Cassandra using the GoCQL library, we must make sure to include those. We also include the gorilla/mux library to access the UUID value from our GetOne() endpoint.</p>\n<pre class=\"language-go\">package Users&#13;\n&#13;\nimport (&#13;\n  \"net/http\"&#13;\n  \"github.com/gocql/gocql\"&#13;\n  \"encoding/json\"&#13;\n  \"github.com/username/projectname/Cassandra\"&#13;\n  \"github.com/gorilla/mux\"&#13;\n  \"fmt\"&#13;\n)</pre>\n<p>To begin, we’ll outline our code to fetch all users. A best practice on this, of course, would restrict the number of results per call and to take in limit/offset parameters, but we will skip that in this tutorial.</p>\n<p>Querying Cassandra data using GoCQL looks just like SQL you would write for MySQL or PostgreSQL. We pass the query as a string to our session’s Cassandra.Query() function. The Query() function returns an iterable, and we use the iterable’s MapScan() function to copy data into a map[string]interface (we use a map[string]<strong>interface</strong> because perhaps not all data in the table is string data to use map[string]<strong>string</strong>).</p>\n<div class=\"protip\"><strong>Go #protip:</strong>When you’re dealing with alternate data types, you can use prefix-style casting like<code class=\"language-go\">int(myVariable)</code>similar to C, Python, etc.. However, when you have data in a Go interface, you must use a suffix-style casting, which looks like<code class=\"language-go\">myVariable.(int)</code></div>\n<p>We append each User structure to an array as we iterate through each user. One quirk of the GoCQL iterable is that we must empty the map before the next call to MapScan(), which is the last step in our for loop. Finally, we package up our array of User structures and return it as JSON. Here’s the code:</p>\n<pre class=\"language-go\">func Get(w http.ResponseWriter, r *http.Request) {&#13;\n  var userList []User&#13;\n  m := map[string]interface{}{}&#13;\n&#13;\n  query := \"SELECT id,age,firstname,lastname,city,email FROM users\"&#13;\n  iterable := Cassandra.Session.Query(query).Iter()&#13;\n  for iterable.MapScan(m) {&#13;\n    userList = append(userList, User{&#13;\n      ID: m[\"id\"].(gocql.UUID),&#13;\n      Age: m[\"age\"].(int),&#13;\n      FirstName: m[\"firstname\"].(string),&#13;\n      LastName: m[\"lastname\"].(string),&#13;\n      Email: m[\"email\"].(string),&#13;\n      City: m[\"city\"].(string),&#13;\n    })&#13;\n    m = map[string]interface{}{}&#13;\n  }&#13;\n&#13;\n  json.NewEncoder(w).Encode(UsersResponse{Users: userList})&#13;\n}</pre>\n<p>Our endpoint code in our application’s /main.go main() function will look like this, and be placed next to our other routes:</p>\n<pre class=\"language-go\">router.HandleFunc(\"/users\", Users.Get)</pre>\n<p>Next, our code to fetch a single user by their UUID. Let’s start by showing you the endpoint route that goes in our application’s /main.go main() function:</p>\n<pre class=\"language-go\">router.HandleFunc(\"/users/{user_uuid}\", Users.GetOne)</pre>\n<p>You’ll notice that unlike our other routes, we have a string wrapped in curly braces called <code>user_uuid</code>. This string declares a variable route name through which we can extract the user’s UUID from the requested URL.</p>\n<p>To begin, we extract all URL variables (declared in those curly braces) into a map called vars, and then access user_uuid from that map. Next, we validate that string by passing it to to GoCQL’s parser for Cassandra UUID values to determine if the value is in fact a UUID. If the validation passes, we fetch that user’s data from Cassandra similar to how we fetched all users in the code above. The difference in this call is the <code>?</code> placeholder in our query for binding parameters to avoid injection attacks. When we call the Cassandra session’s Query() method, we not only pass the string of the query, but each parameter to pass into the query to fill each question mark. In this example we also show how you can tell Cassandra to have single-node consistency when fetching data; this is, of course, redundant since we’re only running on a single node. We then iterate over our result set (even though we set a limit of one row) and return the User structure or an error.</p>\n<pre class=\"language-go\">func GetOne(w http.ResponseWriter, r *http.Request) {&#13;\n  var user User&#13;\n  var errs []string&#13;\n  var found bool = false&#13;\n&#13;\n  vars := mux.Vars(r)&#13;\n  id := vars[\"user_uuid\"]&#13;\n&#13;\n  uuid, err := gocql.ParseUUID(id)&#13;\n  if err != nil {&#13;\n    errs = append(errs, err.Error())&#13;\n  } else {&#13;\n    m := map[string]interface{}{}&#13;\n    query := \"SELECT id,age,firstname,lastname,city,email FROM users WHERE id=? LIMIT 1\"&#13;\n    iterable := Cassandra.Session.Query(query, uuid).Consistency(gocql.One).Iter()&#13;\n    for iterable.MapScan(m) {&#13;\n      found = true&#13;\n      user = User{&#13;\n        ID: m[\"id\"].(gocql.UUID),&#13;\n        Age: m[\"age\"].(int),&#13;\n        FirstName: m[\"firstname\"].(string),&#13;\n        LastName: m[\"lastname\"].(string),&#13;\n        Email: m[\"email\"].(string),&#13;\n        City: m[\"city\"].(string),&#13;\n      }&#13;\n    }&#13;\n    if !found {&#13;\n      errs = append(errs, \"User not found\")&#13;\n    }&#13;\n  }&#13;\n&#13;\n  if found {&#13;\n    json.NewEncoder(w).Encode(GetUserResponse{User: user})&#13;\n  } else {&#13;\n    json.NewEncoder(w).Encode(ErrorResponse{Errors: errs})&#13;\n  }&#13;\n}</pre>\n<p>Finally in our Users/get.go code, we have a function to fetch a user’s first and last name to “enrich” some data. We will use this function in our Messages code shortly, and so we must declare the function with a capital E so it is visible to other subpackages in our project.</p>\n<p>As a best practice, enrichment code would usually retrieve an entire User structure not just a few fields, but we’re taking an easy approach on this for our example application. The Enrich() function takes an array of UUID values, does a single database lookup, and creates a map of the UUID (as a string, this is important later) and the user’s concatenated first and last name. If an empty list of UUIDs is passed, an empty map is returned, otherwise it will return any results it finds in Cassandra.</p>\n<pre class=\"language-go\">func Enrich(uuids []gocql.UUID) map[string]string {&#13;\n  if len(uuids) &gt; 0 {&#13;\n    names := map[string]string{}&#13;\n    m := map[string]interface{}{}&#13;\n&#13;\n    query := \"SELECT id,firstname,lastname FROM users WHERE id IN ?\"&#13;\n    iterable := Cassandra.Session.Query(query, uuids).Iter()&#13;\n    for iterable.MapScan(m) {&#13;\n      fmt.Println(\"m\", m)&#13;\n      user_id := m[\"id\"].(gocql.UUID)&#13;\n      names[user_id.String()] = fmt.Sprintf(\"%s %s\", m[\"firstname\"].(string), m[\"lastname\"].(string))&#13;\n      m = map[string]interface{}{}&#13;\n    }&#13;\n    return names&#13;\n  }&#13;\n  return map[string]string{}&#13;\n}</pre>\n<p>Full Source: <a href=\"https://github.com/GetStream/Stream-Example-Go-Cassandra-API/tree/master/Users\">Users/*.go</a></p>\n<h2>Step 6 – Connecting to Stream</h2>\n<p>Great, we’ve learned how to set up the beginnings of our RESTful API with Go and Cassandra. As a next step let’s see how we can integrate Stream, our API for building scalable feeds and activity streams. We’ll use Stream to store a copy of our messages, so when our application goes viral it will be Stream’s job to handle the scalability of handling our activity feed.</p>\n<p>Our Stream code will live in a separate subfolder as well, called “Stream” with its own main.go. Like the Cassandra code, it must have its own unique package name as well. We will import the Stream Go SDK library as well as the standard library for reporting errors. Inside Stream/main.go place the following code:</p>\n<pre class=\"language-go\">package Stream&#13;\n&#13;\nimport (&#13;\n  getstream \"github.com/GetStream/stream-go\"&#13;\n  \"errors\"&#13;\n)</pre>\n<p>Next, we will declare an exportable variable called Client which we will use elsewhere in our code:</p>\n<pre class=\"language-go\">var Client *getstream.Client</pre>\n<p>Unlike our Cassandra code, this subpackage will not use the init() method so that the Connect() method will be called from our API application’s /main.go main() function. It will validate that we’ve passed in our API credentials and a region for the Stream SDK client and return an error if any of those items are missing. Next, the Stream SDK will create a new connection and assign that to our Client variable, or return an error if the connection failed.</p>\n<pre class=\"language-go\">func Connect(apiKey string, apiSecret string, apiRegion string) error {&#13;\n  var err error&#13;\n  if apiKey == \"\" || apiSecret == \"\" || apiRegion == \"\" {&#13;\n    return errors.New(\"Config not complete\")&#13;\n  }&#13;\n&#13;\n  Client, err = getstream.New(&amp;getstream.Config{&#13;\n    APIKey: apiKey,&#13;\n    APISecret: apiSecret,&#13;\n    Location: apiRegion,&#13;\n  })&#13;\n  return err&#13;\n}</pre>\n<p>Since we’re not using an init() call, we will require our application’s /main.go main() function to manually connect to Stream, and here’s what that code could look like:</p>\n<pre class=\"language-go\">func main() {&#13;\n  err := Stream.Connect(&#13;\n    \"api_key_goes_here\",&#13;\n    \"api_secret_goes_here\",&#13;\n    \"us-east\")&#13;\n  if err != nil {&#13;\n    log.Fatal(\"Could not connect to Stream, abort\")&#13;\n  }&#13;\n&#13;\n  CassandraSession := Cassandra.Session&#13;\n  defer CassandraSession.Close()&#13;\n&#13;\n  router := mux.NewRouter().StrictSlash(true)&#13;\n  ...&#13;\n}&#13;\n&#13;\n</pre>\n<p>Final source: <a href=\"https://github.com/GetStream/Stream-Example-Go-Cassandra-API/blob/master/Stream/main.go\">Stream/main.go</a></p>\n<h2>Step 8 – Messages</h2>\n<p>We won’t go into the code for our messages as deeply as users because much of the structure is the same. Of course, all of our Messages scripts need to be declared with another unique package name:</p>\n<pre class=\"language-go\">package Messages</pre>\n<p>Our imports will also look the same, importing some standard libraries, gorilla/mux, and our Cassandra code. The GET and POST operations will also import our Stream submodules (not all scripts will need both):</p>\n<pre class=\"language-go\">import (&#13;\n  ...&#13;\n  \"github.com/username/projectname/Stream\"&#13;\n  getstream \"github.com/GetStream/stream-go\"&#13;\n  ...&#13;\n)</pre>\n<p><strong>Go #protip:</strong> Adding a word in front of an import like the Stream Go SDK above (“getstream”) will allow you to alias the subpackage namespace. In our tutorial, our Stream code uses a package name of “Stream” which conflicts with the SDK package, so we can use “getstream” as an alias when we reference the SDK calls.</p>\n<h3>A. Creating Messages</h3>\n<p>Like our Users code, we have a Messages/structs.go script which declares our data structures. Our first structure holds the message details from Cassandra, plus one extra field for the user’s full name (more on this later). The next two structures are for requesting one or all messages.</p>\n<p>The processing.go file is a much simpler version of the user’s processing script and handles incoming form data for the POST request to save a new message. It only declares whether a required field is missing in the form data.</p>\n<p>Before we get into the code, let’s review at a high level what our Message/post.go script will do for us, because creating a new message becomes more complex than just creating a user. First, we must validate our data points and save it in Cassandra, but then we’ll also forward the activity to Stream as an activity on a flat feed called “messages” to retrieve later.</p>\n<pre class=\"language-go\">package Messages&#13;\n&#13;\nimport (&#13;\n  \"net/http\"&#13;\n  \"github.com/gocql/gocql\"&#13;\n  \"encoding/json\"&#13;\n  \"github.com/username/projectname/Stream\"&#13;\n  \"github.com/username/projectname/Cassandra\"&#13;\n  getstream \"github.com/GetStream/stream-go\"&#13;\n)</pre>\n<p>Our message POST will require a user’s UUID to be part of our form data, as well as the text of the message itself. The validations below will check that the user_id passed to our code is a UUID, and that the message text has a length greater than 0. Of course, for simplicity, we skip validating that the user_id UUID is valid, and we also skip validating a maximum length on our message or perhaps other techniques to detect spam or unwanted behavior.</p>\n<pre class=\"language-go\">func Post(w http.ResponseWriter, r *http.Request) {&#13;\n  var errs []string&#13;\n  var errStr, userIdStr, message string&#13;\n&#13;\n  if userIdStr, errStr = processFormField(r, \"user_id\"); len(errStr) != 0 {&#13;\n    errs = append(errs, errStr)&#13;\n  }&#13;\n  user_id, err := gocql.ParseUUID(userIdStr)&#13;\n  if err != nil {&#13;\n    errs = append(errs, \"Parameter 'user_id' not a UUID\")&#13;\n  }&#13;\n&#13;\n  if message, errStr = processFormField(r, \"message\"); len(errStr) != 0 {&#13;\n    errs = append(errs, errStr)&#13;\n  }</pre>\n<p>Once our validation is proven, we generate a unique UUID for our message and insert the message into Cassandra similar to how we inserted our user record.</p>\n<pre class=\"language-go\">  gocqlUuid := gocql.TimeUUID()&#13;\n&#13;\n  var created bool = false&#13;\n  if len(errs) == 0 {&#13;\n    if err := Cassandra.Session.Query(`&#13;\n      INSERT INTO messages (id, user_id, message) VALUES (?, ?, ?)`,&#13;\n      gocqlUuid, user_id, message).Exec(); err != nil {&#13;\n      errs = append(errs, err.Error())&#13;\n    } else {&#13;\n      created = true&#13;\n    }&#13;\n  }</pre>\n<p>If our message was created successfully in Cassandra, we can now build an Activity and send it to Stream. We start out by identifying our flat feed group called “messages” and passing an identifier as the word “global”; as mentioned earlier, we recommend passing a UUID value to avoid collisions, but this is common for global feeds of data that you want all users to see. We build the feed reference by calling our exported Client variable in our Stream subpackage, and calling the .FlatFeed() method.</p>\n<pre class=\"language-go\">  if created {&#13;\n    // send message to Stream&#13;\n    globalMessages, err := Stream.Client.FlatFeed(\"messages\", \"global\")</pre>\n<p>With our feed in place, we now create an Activity structure and pass it to Stream. At the very minimum, the Stream API requires three pieces of data to build an activity: an Actor, a Verb, and an Object. The actor is usually set to the user who is creating the activity. The verb can be any string up to 20 characters in length, and we’ll set that to “post” for users posting a message. The object reference in this case is the UUID of the message we just saved in Cassandra.</p>\n<p>The Stream API also allows metadata to be passed in activities, and the total payload of a message can be about 1kb of key/value pairs of string data. Normally, your application would use the Object ID described above to fetch the message structure, but on an application like this, the messages table could be quite large. So, to save us a database lookup later on our messages table, we will assume that messages sent to our API are short (say, Twitter-length in size), and store the text of the message in the activity metadata. This way, when we retrieve the feed from Stream later, we have less database activity.</p>\n<pre class=\"language-go\">    if err == nil {&#13;\n      globalMessages.AddActivity(&amp;getstream.Activity{&#13;\n        Actor: getstream.FeedID(user_id.String()),&#13;\n        Verb: \"post\",&#13;\n        Object: getstream.FeedID(gocqlUuid.String()),&#13;\n        MetaData: map[string]string{&#13;\n          // add as many custom keys/values here as you like&#13;\n          \"message\": message,&#13;\n        },&#13;\n      })&#13;\n    }&#13;\n&#13;\n    json.NewEncoder(w).Encode(NewMessageResponse{ID: gocqlUuid})&#13;\n  } else {&#13;\n    json.NewEncoder(w).Encode(ErrorResponse{Errors: errs})&#13;\n  }&#13;\n}</pre>\n<h3>B. Reading Messages</h3>\n<p>Our Messages/get.go script will also be more complex than our Users code. Fetching a single message will pull it from the database but fetching all messages will first attempt to pull the messages from Stream; if Stream fails, we will look them up in the database.</p>\n<pre class=\"language-go\">package Messages&#13;\n&#13;\nimport (&#13;\n  \"net/http\"&#13;\n  \"github.com/gocql/gocql\"&#13;\n  \"encoding/json\"&#13;\n  \"github.com/gorilla/mux\"&#13;\n  \"fmt\"&#13;\n  \"github.com/username/projectname/Stream\"&#13;\n  \"github.com/username/projectname/Cassandra\"&#13;\n  \"github.com/username/projectname/Users\"&#13;\n)</pre>\n<p>Our GetOne() method will be called only when our API is fetching a single message. It will use the gorilla/mux Vars() call again (like we did with users) to parse a value out of our URL string, in this case something called {message_uuid}. We validate that the value is indeed a UUID, and then fetch that from our database.</p>\n<p>Our GetOne() and Get() calls will also “enrich” some data from the messages. This is typical behavior with applications using Stream since our Activity payload is relatively small. Most of the time, your application will only send us references to users, messages, posts, and other object types, which are then retrieved in an efficient manner from your database. In our example, we will take the user_id UUID from our message and turn that into a string of just the user’s first and last name; more typically, your application would pull the entire user record to access any of the fields.</p>\n<p>We’ve included our Users subpackage in the imports above so we have access to the Enrich() code in the Users/get.go script. This method takes a list of user_id UUIDs and returns a map of firstname/lastname strings.</p>\n<pre class=\"language-go\">func GetOne(w http.ResponseWriter, r *http.Request) {&#13;\n  var message Message&#13;\n  var errs []string&#13;\n  var found bool = false&#13;\n&#13;\n  vars := mux.Vars(r)&#13;\n  id := vars[\"message_uuid\"]&#13;\n&#13;\n  uuid, err := gocql.ParseUUID(id)&#13;\n  if err != nil {&#13;\n    errs = append(errs, err.Error())&#13;\n  } else {&#13;\n    m := map[string]interface{}{}&#13;\n    query := \"SELECT id,user_id,message FROM messages WHERE id=? LIMIT 1\"&#13;\n    iterable := Cassandra.Session.Query(query, uuid).Consistency(gocql.One).Iter()&#13;\n    for iterable.MapScan(m) {&#13;\n      found = true&#13;\n      user_id := m[\"user_id\"].(gocql.UUID)&#13;\n      names := Users.Enrich([]gocql.UUID{user_id})&#13;\n      fmt.Println(\"names\", names)&#13;\n      message = Message{&#13;\n        ID: user_id,&#13;\n        UserID: m[\"user_id\"].(gocql.UUID),&#13;\n        UserFullName: names[user_id.String()],&#13;\n        Message: m[\"message\"].(string),&#13;\n      }&#13;\n    }&#13;\n    if !found {&#13;\n      errs = append(errs, \"Message not found\")&#13;\n    }&#13;\n  }&#13;\n&#13;\n  if found {&#13;\n    json.NewEncoder(w).Encode(GetMessageResponse{Message: message})&#13;\n  } else {&#13;\n    json.NewEncoder(w).Encode(ErrorResponse{Errors: errs})&#13;\n  }&#13;\n}</pre>\n<p>Finally, our Get() method will fetch all messages in our “messages” feed at Stream. If something goes wrong, we need a backup and so we’ll retrieve the messages from Cassandra. Either way, we’ll strip out all user_id UUIDs while we iterate over the data, fetch their firstname/lastname strings, and enrich the message data to include the author’s name in our outgoing payload.</p>\n<pre class=\"language-go\">func Get(w http.ResponseWriter, r *http.Request) {&#13;\n  var messageList []Message&#13;\n  var enrichedMessages []Message&#13;\n  var userList []gocql.UUID&#13;\n  var err error&#13;\n  m := map[string]interface{}{}</pre>\n<p>Next, we create our reference to our flat feed as we did in Messages/post.go using our exported Client variable from our Stream subpackage.</p>\n<pre class=\"language-go\">  globalMessages, err := Stream.Client.FlatFeed(\"messages\", \"global\")</pre>\n<p>Now we’ll attempt to fetch our flat feed from Stream by calling the .Activities() method on our feed reference, and print a message saying that we have successfully fetched the feed. Then we iterate over the list of activities, and extract all of the user_id UUIDs.</p>\n<pre class=\"language-go\">  // fetch from Stream&#13;\n  if err == nil {&#13;\n    activities, err := globalMessages.Activities(nil)&#13;\n    if err == nil {&#13;\n      fmt.Println(\"Fetching activities from Stream\")&#13;\n      for _, activity := range activities.Activities {&#13;\n        fmt.Println(activity)&#13;\n        user_id, _ := gocql.ParseUUID(activity.Actor.Value())&#13;\n        message_id, _ := gocql.ParseUUID(activity.Object.Value())&#13;\n        messageList = append(messageList, Message{&#13;\n          ID: message_id,&#13;\n          UserID: user_id,&#13;\n          Message: activity.MetaData[\"message\"],&#13;\n        })&#13;\n        userList = append(userList, user_id)&#13;\n      }&#13;\n    }&#13;\n  }</pre>\n<p>However, this is the internet we’re talking about and sometimes things fail. We could build in a retry mechanism with exponential back-off, but our users want to see messages as soon as possible, so let’s fetch them from Cassandra as our backup plan. While we iterate over those messages, we’ll also pull out the user_id UUIDs into a list.</p>\n<pre class=\"language-go\">  // if Stream fails, pull from database instead&#13;\n  if err != nil {&#13;\n    fmt.Println(\"Fetching activities from Database\")&#13;\n    query := \"SELECT id,user_id,message FROM messages\"&#13;\n    iterable := Cassandra.Session.Query(query).Iter()&#13;\n    for iterable.MapScan(m) {&#13;\n      user_id := m[\"user_id\"].(gocql.UUID)&#13;\n      messageList = append(messageList, Message{&#13;\n        ID: m[\"id\"].(gocql.UUID),&#13;\n        UserID: user_id,&#13;\n        Message: m[\"message\"].(string),&#13;\n      })&#13;\n      userList = append(userList, user_id)&#13;\n      m = map[string]interface{}{}&#13;\n    }&#13;\n  }</pre>\n<p>Now we’ll take that list of user_id UUIDs from above, turn that into our map of UUID-&gt;”firstname lastname” and enrich our messages. Since we cannot inject data into our old messages list, we append the now-enriched messages into a new list, and return that as our payload.</p>\n<pre class=\"language-go\">  names := Users.Enrich(userList)&#13;\n  for _, message := range messageList {&#13;\n    message.UserFullName = names[message.UserID.String()]&#13;\n    enrichedMessages = append(enrichedMessages, message)&#13;\n  }&#13;\n&#13;\n  json.NewEncoder(w).Encode(MessagesResponse{Messages: enrichedMessages})&#13;\n}</pre>\n<p>Final Source: <a href=\"https://github.com/GetStream/Stream-Example-Go-Cassandra-API/tree/master/Messages\">Messages/*.go</a></p>\n<h2>Conclusion</h2>\n<p>Building a performant API isn’t hard when you’ve learned the REST principles of keeping your data payloads simple, with one responsibility, and having appropriate JSON responses for payloads. Our example API application showed you how to create a simple API in Go built on gorilla/mux and using Cassandra as a datastore. We also showed an example of using the <a href=\"https://github.com/GetStream/stream-go\">Stream Go SDK</a> to save and retrieve message data with Stream’s flat feeds.</p>\n<p>If you’d like to see more of our open-source projects, you can find them at <a href=\"https://github.com/GetStream\">github.com/GetStream</a> and you can go through our <a href=\"https://getstream.io/get_started/?utm_source=blog&amp;utm_campaign=growth&amp;utm_medium=go-api#intro\">Getting Started tutorial</a> to learn more about our flat feeds and other feed types!</p>\n<hr /><p>\n  <em>\n  Also published on <a href=\"https://medium.com/@iandouglas736/building-a-performant-api-using-go-and-cassandra-b7b11b7d58\">Medium</a>.  </em>\n</p>"}}]}},"pageContext":{"alternative_id":4872}}