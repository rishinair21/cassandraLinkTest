{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Third Contact with a Monolith: Part C - In the Pod - Instaclustr","alternative_id":12149,"content":"<p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/In-the-pod-Instaclustr.jpg\"> </a></p><aside class=\"content-cta\"><div class=\"primary\"><h4>Related Articles:</h4></div></aside><br /><img class=\"aligncenter wp-image-6883 size-full\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/In-the-pod-Instaclustr.jpg\" alt=\"Third Contact with a Monolith PArt C In the Pod Instaclustr\" width=\"640\" height=\"601\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/In-the-pod-Instaclustr.jpg 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/In-the-pod-Instaclustr-300x282.jpg 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/In-the-pod-Instaclustr-51x48.jpg 51w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/In-the-pod-Instaclustr-115x108.jpg 115w\" /><h2>A simple classification problem: Will the Monolith react? Is it safe?!</h2><p>Maybe a cautious approach to a bigger version of the Monolith (2km long) in a POD that is only 2m in diameter is advisable.   What do we know about how Monoliths react to stimuli? A simple classification problem consists of the category (label) “no reaction” (0) or “reaction” (1), and the stimuli tried (features which will be used to predict the label).  In the following table, the first column in the label to be predicted (positive, 1, or negative, 0), the remaining columns are the features, and each row is an example:</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr.png\"><img class=\"aligncenter wp-image-6886 size-medium\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr-300x292.png\" alt=\"classification problem table Instaclustr\" width=\"300\" height=\"292\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr-300x292.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr-768x747.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr-1024x996.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr-633x616.png 633w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr-640x622.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr-49x48.png 49w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr-111x108.png 111w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Classification-problem-table-instaclustr.png 1088w\" /></a></p><p>This problem is trivial as a positive reaction only occurred for Touch OR Sunlight (the camera flash was a co-incidence), the features are all binary, and only a single feature at a time is true. As a result of extensive tests on the Monolith imagine that there are lots more examples and data available, each feature is a floating point number, all features don’t have values for all examples, there are potentially 1,000s of features, and a sufficiently accurate classification rule may require an arbitrary number of features.</p><p>Given that HAL has been unplugged we have to analyse the data ourselves. What do we have available in the POD?</p><p>One approach is to use an appropriately 1960’s-vintage machine learning algorithm suitable for simple binary classification problems. Decision tree algorithms were invented in the 1960’s (Concept Learning System, by a Psychologist, Earl Hunt), were improved in the 1980’s (e.g. ID3, C4.5, and <a href=\"https://link.springer.com/content/pdf/10.1023%2FA%3A1022699322624.pdf\">FOIL</a>, which references my 1988 machine learning algorithm, <i>Gargantubrain</i>), and are still useful. Spark’s Machine Learning Library (MLLib) has a number of regression and classification algorithms, including decision trees, that improve on the originals by running them “transparently” in parallel on multiple servers for scalability. </p><p><a href=\"https://spark.apache.org/mllib/\">Spark’s scalable ML library is available here</a>. It’s easy to download Spark and run MLLib examples locally, but the scalability benefits are best realised after deployment to an <a href=\"https://www.instaclustr.com/solutions/managed-apache-spark/\">Instaclustr managed Spark cluster.</a> Here’s the documentation on the <a href=\"https://spark.apache.org/docs/latest/mllib-decision-tree.html\">MLLib decision tree</a> algorithm.</p><h2>Training</h2><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/download-1.jpeg\"><img class=\"aligncenter wp-image-6888 size-full\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/download-1.jpeg\" alt=\"Training Instaclustr\" width=\"198\" height=\"254\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/download-1.jpeg 198w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/download-1-37x48.jpeg 37w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/download-1-84x108.jpeg 84w\" /></a></p><p>We’ll have a look at the example Java code, starting from the call to the decision tree algorithm to build the model from the examples, and working out from there. <a href=\"https://spark.apache.org/docs/latest/api/java/org/apache/spark/mllib/tree/DecisionTree.html\">DecisionTree</a> and <a href=\"https://spark.apache.org/docs/latest/api/java/org/apache/spark/mllib/tree/model/DecisionTreeModel.html\">DecisionTreeModel</a> documents are relevant.  Here’s the code.  Note the API for trainClassifier:</p><p>trainClassifier(JavaRDD&lt;LabeledPoint&gt; input, int numClasses,<br />java.util.Map&lt;Integer,Integer&gt; categoricalFeaturesInfo, String<br />impurity, int maxDepth, int maxBins)</p><p>The first argument is a JavaRDD of LabeledPoint. The other arguments are for control of the algorithm:</p><p>// Set parameters for DecisionTree learning.</p><p>// Empty categoricalFeaturesInfo indicates all features are continuous.</p><p>Integer numClasses = 2;</p><p>Map&lt;Integer, Integer&gt; categoricalFeaturesInfo = new HashMap&lt;&gt;();</p><p>String impurity = “gini”; // or “entropy”</p><p>Integer maxDepth = 5;</p><p>Integer maxBins = 32;</p><p>// Train DecisionTree model</p><p>DecisionTreeModel model = <b>DecisionTree.trainClassifier</b>(<b>trainingData</b>, numClasses, categoricalFeaturesInfo, impurity, maxDepth, maxBins);</p><p>System.out.println(“Learned classification tree model:\\n” + model.toDebugString());</p><p>What is a JavaRDD and LabeledPoint?</p><h2>LabeledPoint</h2><h2><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/pinch-point-arrow-shape-label-lb-2785.png\"><img class=\"size-medium wp-image-6889 aligncenter\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/pinch-point-arrow-shape-label-lb-2785-154x300.png\" alt=\"Pinch point Instaclustr\" width=\"154\" height=\"300\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/pinch-point-arrow-shape-label-lb-2785-154x300.png 154w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/pinch-point-arrow-shape-label-lb-2785-316x616.png 316w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/pinch-point-arrow-shape-label-lb-2785-328x640.png 328w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/pinch-point-arrow-shape-label-lb-2785-25x48.png 25w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/pinch-point-arrow-shape-label-lb-2785-55x108.png 55w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/pinch-point-arrow-shape-label-lb-2785.png 410w\" /><br /></a>             .</h2><p><a href=\"https://spark.apache.org/docs/latest/mllib-data-types.html#labeled-point\" target=\"_blank\" rel=\"noopener\">https://spark.apache.org/docs/latest/mllib-data-types.html#labeled-point</a></p><p><a href=\"https://spark.apache.org/docs/latest/api/java/org/apache/spark/mllib/regression/LabeledPoint.html\" target=\"_blank\" rel=\"noopener\">https://spark.apache.org/docs/latest/api/java/org/apache/spark/mllib/regression/LabeledPoint.html</a></p><p>Decision trees are a type of supervised learner, so we need a way of telling the algorithm what class (positive or negative for binary classifiers) each training example is.  LabeledPoint is a single labelled example (a “point” in n-dimensional space). It’s a tuple consisting of a Double label (either 0 or 1 for negative or positive examples), and a Vector of features, either dense or sparse.  Features are numbered from 0 to n. These are the examples from the documentation. Note the Vectors import. This is important as the default Spark Vector is NOT CORRECT.</p><p>import org.apache.spark.mllib.linalg.Vectors;<br />import org.apache.spark.mllib.regression.LabeledPoint;</p><p>// Create a labeled point with a positive label and a dense feature vector.</p><p>// There are three features, with values 1, 0, 3.<br />LabeledPoint pos = new LabeledPoint(1.0, Vectors.dense(1.0, 0.0, 3.0));</p><p>// Create a labeled point with a negative label and a sparse feature vector.</p><p>// There are two features, 0 and 2, with values 1 and 3 respectively.</p><p>LabeledPoint neg = new LabeledPoint(0.0, Vectors.sparse(3, new int[] {0, 2}, new double[] {1.0, 3.0}));</p><h2>Resilient Distributed Datasets (RDDs)</h2><p><a href=\"https://spark.apache.org/docs/latest/rdd-programming-guide.html\" target=\"_blank\" rel=\"noopener\">https://spark.apache.org/docs/latest/rdd-programming-guide.html</a></p><p><a href=\"https://spark.apache.org/docs/latest/api/java/org/apache/spark/api/java/JavaRDD.html\" target=\"_blank\" rel=\"noopener\">https://spark.apache.org/docs/latest/api/java/org/apache/spark/api/java/JavaRDD.html</a></p><h6>From the documentation: </h6><p><em>“Spark revolves around the concept of a resilient distributed dataset (RDD), which is a fault-tolerant collection of elements that can be operated on in parallel. There are two ways to create RDDs: parallelizing</em><em> an existing collection in your driver </em>program<em> or referencing a dataset in an external storage system… “</em> (such as Cassandra)</p><p><a href=\"https://jaceklaskowski.gitbooks.io/mastering-apache-spark/spark-rdd.html\" target=\"_blank\" rel=\"noopener\">This blog has a good explanation of the Spark architecture</a>, and explains that the features of RDDs are:</p><ul><li>Resilient, i.e. fault-tolerant with the help of <a href=\"https://jaceklaskowski.gitbooks.io/mastering-apache-spark/spark-rdd.html#lineage\">RDD lineage graph</a> and so able to recompute missing or damaged partitions due to node failures.</li>\n<li>Distributed with data residing on multiple nodes in a <a href=\"https://jaceklaskowski.gitbooks.io/mastering-apache-spark/spark-cluster.html\">cluster</a>.</li>\n<li>Dataset is a collection of <a href=\"https://jaceklaskowski.gitbooks.io/mastering-apache-spark/spark-rdd-partitions.html\">partitioned data</a> with primitive values or values of values, e.g. tuples or other objects (that represent records of the data you work with).</li>\n</ul><p>RDD’s are also immutable and can be cached. Fault-tolerance depends on the execution model which computes a Directed Acyclic Graph (DAG) of stages for each job, runs stages in optimal locations based on data location, shuffles data as required, and re-runs failed stages. </p><h2>LIBSVM – sparse data format</h2><p><a href=\"https://spark.apache.org/docs/2.0.2/mllib-data-types.html\">https://spark.apache.org/docs/2.0.2/mllib-data-types.html</a></p><p><a href=\"https://spark.apache.org/docs/latest/api/java/org/apache/spark/mllib/util/MLUtils.html\">https://spark.apache.org/docs/latest/api/java/org/apache/spark/mllib/util/MLUtils.html</a></p><p>Where does the RDD training data come from? In the example code I read it from a local file using MLUtils.loadLibSVMFile() (I’ll come back to the parameters later):</p><p>JavaRDD&lt;LabeledPoint&gt; data = MLUtils.loadLibSVMFile(sc, path).toJavaRDD();</p><h6>From the documentation:</h6><p><em>“It is very common in practice to have sparse training data. MLlib supports reading training examples stored in LIBSVM format, which is the default format used by LIBSVM and LIBLINEAR. It is a text format in which each line represents a labeled sparse feature vector using the following format:</em></p><p><em>label index1:value1 index2:value2 …</em></p><p><em>where the indices are one-based and in ascending order. After loading, the feature indices are converted to zero-based.”</em></p><p>For the above Monolith example the LIBSVM input file looks like this (assuming that feature values of “0” indicate non-existent data):</p><p><strong>1.0 1:1.0<br />0.0 2:1.0</strong><br /><strong>0.0 3:1.0</strong><br /><strong>0.0 4:1.0</strong><br /><strong>0.0 5:1.0</strong><br /><strong>0.0 6:1.0</strong><br /><strong>0.0 7:1.0</strong><br /><strong>1.0 8:1.0</strong><br /><strong>0.0 9:1.0</strong><br /><strong>0.0 10:1.0</strong></p><p>This doesn’t seem very “user friendly” as we have lost the feature names. I wonder if there is a better data format?</p><h2>Splitting (the data, not the atom)</h2><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Splitting-the-data-not-the-atom-instaclustr.jpg\"><img class=\"aligncenter wp-image-6890 size-full\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Splitting-the-data-not-the-atom-instaclustr.jpg\" alt=\"splitting the data, not the atom instaclustr\" width=\"356\" height=\"199\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Splitting-the-data-not-the-atom-instaclustr.jpg 356w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Splitting-the-data-not-the-atom-instaclustr-300x168.jpg 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Splitting-the-data-not-the-atom-instaclustr-86x48.jpg 86w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Splitting-the-data-not-the-atom-instaclustr-193x108.jpg 193w\" /></a></p><p>Once we have the training data in the correct format for the algorithm (JavaRDD&lt;LabeledPoint&gt;), but before we train the model, we need to split it into two random subsets for training and testing. JavaRDD.randomSplit() does this and takes parameters:</p><p>double[] weights – weights for splits, will be normalized if they don’t sum to 1</p><p>long seed – random seed</p><p>// Split sample RDD into two sets, 60% training data, 40% testing data. 11 is a seed.</p><p>   JavaRDD&lt;LabeledPoint&gt;[] splits = data.randomSplit(new double[]{0.6, 0.4}, 11L);</p><p>   JavaRDD&lt;LabeledPoint&gt; trainingData = splits[0].cache();  // cache the data</p><p>   JavaRDD&lt;LabeledPoint&gt; testData = splits[1];</p><p>Notice the cache() call for trainingData.  What does it do? Spark is Lazy, it doesn’t evaluate RDD’s until an action forces it to. Hence RDD’s can be evaluated multiple times which is expensive. cache() creates an in memory cache “checkpoint” of an RDD which can be reused. The most obvious case is when an RDD is used multiple times (i.e. iteration), or for branching transformations (i.e. multiple different RDD’s are computed from an original RDD), in which case the original should be cached.<br /><a href=\"https://stackoverflow.com/questions/28981359/why-do-we-need-to-call-cache-or-persist-on-a-rdd\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/28981359/why-do-we-need-to-call-cache-or-persist-on-a-rdd</a><br /></p><p>Note that for this example the <i>initial data </i>should be cached as we use it later to count the total, positive and negative examples.</p><h2>Evaluating the Model on the Test Data – Thumbs down or up?</h2><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-Data-2-Instaclustr.png\"><img class=\"aligncenter wp-image-6892 size-medium_large\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-Data-2-Instaclustr-768x521.png\" alt=\"Evaluating the model on the test data Instaclustr\" width=\"768\" height=\"521\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-Data-2-Instaclustr-768x521.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-Data-2-Instaclustr-300x204.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-Data-2-Instaclustr-1024x695.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-Data-2-Instaclustr-907x616.png 907w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-Data-2-Instaclustr-640x434.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-Data-2-Instaclustr-71x48.png 71w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-Data-2-Instaclustr-159x108.png 159w\" /></a></p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-data-1-Instaclustr.png\"><img class=\"aligncenter wp-image-6893 size-medium_large\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-data-1-Instaclustr-768x394.png\" alt=\"Evaluating the model on the test data Instaclustr\" width=\"768\" height=\"394\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-data-1-Instaclustr-768x394.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-data-1-Instaclustr-300x154.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-data-1-Instaclustr-1024x525.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-data-1-Instaclustr-966x496.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-data-1-Instaclustr-640x328.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-data-1-Instaclustr-94x48.png 94w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Evaluating-the-model-on-the-test-data-1-Instaclustr-210x108.png 210w\" /></a></p><p>We trained a decision tree model above. What can we do with it? We trained it on the trainingData subset of examples leaving us with the testData to evaluate it on. MLLib computes some useful evaluation metrics which are documented here:</p><p><a href=\"https://spark.apache.org/docs/latest/mllib-evaluation-metrics.html\" target=\"_blank\" rel=\"noopener\">https://spark.apache.org/docs/latest/mllib-evaluation-metrics.html</a></p><p><a href=\"https://spark.apache.org/docs/latest/api/java/org/apache/spark/mllib/evaluation/BinaryClassificationMetrics.html\" target=\"_blank\" rel=\"noopener\">https://spark.apache.org/docs/latest/api/java/org/apache/spark/mllib/evaluation/BinaryClassificationMetrics.html</a></p><p>Here’s the code which computes the evaluation metrics:</p><p>// Compute evaluation metrics.<br />BinaryClassificationMetrics metrics = new BinaryClassificationMetrics(predictionAndLabels.rdd());</p><p>The highlighted parameter is an RDD of (prediction, label) pairs for a subset of examples. I.e. (0, 0) (0, 1) (1, 0) (1, 0). I.e. for each example, run the model and return a tuple of predicted label and actual example label. Here’s the complete code that does this on the testData and then computes the evaluation metrics:</p><p>// For every example in testData, p, replace it by a Tuple of (predicted category, labelled category)</p><p>// E.g. (1.0,0.0) (0.0,0.0) (0.0,0.0) (0.0,1.0)</p><p>JavaPairRDD&lt;Object, Object&gt; predictionAndLabels = testData.mapToPair(p -&gt;</p><p>    new Tuple2&lt;&gt;(model.predict(p.features()), p.label()));</p><p>// Compute evaluation metrics.</p><p>BinaryClassificationMetrics metrics = new BinaryClassificationMetrics(predictionAndLabels.rdd());</p><p>How does this work? There may be a few unfamiliar things in this code which we’ll explore: Tuple2, JavaPairRDD, mapToPair, features() and label(). </p><h4>Tuple(ware)</h4><p>Java doesn’t have a built-in Tuple type, so you have to use the scala.Tuple2 class. </p><h4>MAP</h4><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Here-be-dragons-Instaclustr.jpg\"><img class=\"aligncenter wp-image-6894 size-full\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Here-be-dragons-Instaclustr.jpg\" alt=\"MAP RDD transformation Instaclustr\" width=\"363\" height=\"234\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Here-be-dragons-Instaclustr.jpg 363w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Here-be-dragons-Instaclustr-300x193.jpg 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Here-be-dragons-Instaclustr-74x48.jpg 74w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Here-be-dragons-Instaclustr-168x108.jpg 168w\" /></a></p><p>Map is an RDD transformation. Transformations pass each dataset element through a function and return a new RDD representing the result. Actions return a result after running a computation on a dataset. Transformations are lazy and are not computed until required by an action. In the above example, for every example in testData, p, it is replaced by a Tuple of (predicted category, labelled category). These values are computed by running model.predict() on all the features in the example, and using the label() of the example.</p><p>See LabeledPoint <a href=\"https://spark.apache.org/docs/latest/api/java/org/apache/spark/mllib/regression/LabeledPoint.html\" target=\"_blank\" rel=\"noopener\">documentation</a> for features() and label() methods.</p><p><a href=\"https://spark.apache.org/docs/latest/api/java/index.html?org/apache/spark/api/java/JavaPairRDD.html\" target=\"_blank\" rel=\"noopener\">JavaPairRDD</a> is a (key, value) version of RDD. Instead of the general map function you need to use mapToPair.</p><p><i>Map</i> (and <i>mapToPair</i>) are examples of “Higher Order Functions”. These are used a lot in Spark but are really pretty ancient and were first practically used in 1960 in <a href=\"http://www-formal.stanford.edu/jmc/recursive.pdf\" target=\"_blank\" rel=\"noopener\">LISP</a>. Disturbingly the abstract sounds like an early attempt at HAL:</p><p><i>“A programming system called LISP … was designed to facilitate experiments … whereby a machine could be instructed to … exhibit “common sense” in carrying out its instructions.”</i></p><p>I used LISP for a real AI project (once), but (it ((had too) (many) brackets) (for (((me (Lots of Idiotic Spurious Parentheses))) ???!!! (are these balanced?!).</p><p>preferred(I, Prolog).</p><p>The following code prints out the main evaluation metrics, precision, recall and F.</p><p>JavaRDD&lt;Tuple2&lt;Object, Object&gt;&gt; precision = metrics.precisionByThreshold().toJavaRDD();</p><p>   System.out.println(“Precision by threshold: ” + precision.collect());</p><p>   JavaRDD&lt;Tuple2&lt;Object, Object&gt;&gt; recall = metrics.recallByThreshold().toJavaRDD();</p><p>   System.out.println(“Recall by threshold: ” + recall.collect());</p><p>   JavaRDD&lt;Tuple2&lt;Object, Object&gt;&gt; f = metrics.fMeasureByThreshold().toJavaRDD();</p><p>   System.out.println(“F by threshold: ” + f.collect());</p><p>Note that the metrics are designed for algorithms that can have multiple threshold values (i.e. the classification can have an associated probability).  However, the decision tree algorithm we are using is a simple yes/no binary classification.  A “confusion matrix” is a simple way of understanding the evaluation metrics. For each of the two states of reality (no reaction or reaction from the monolith) the model can make a true or false prediction giving four possible outcomes: Correct: TN = True Negative (the model correctly predicted no reaction), TP = True Positive (correctly predicted a reaction). And Incorrect: FP = False Positive (predicted a reaction but there was no reaction), FN = False Negative (predicted no reaction but there was a reaction).  FP is often called a Type I error, and FN a type II error. </p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr.png\"><img class=\"aligncenter wp-image-6895 size-large\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr-1024x382.png\" alt=\"Model Prediction Instaclustr\" width=\"1024\" height=\"382\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr-1024x382.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr-300x112.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr-768x287.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr-966x360.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr-640x239.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr-129x48.png 129w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr-290x108.png 290w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/Model-prediction-Instaclustr.png 1544w\" /></a></p><p><b>Precision</b> = (TP)/(TP+FP), the proportion of <i>predicted</i> <i>positives</i> that were actually positive (the right column).</p><p><b>Recall = </b>(TP)/(TP+FN), the proportion of <i>actual</i> <i>positives</i> that were correctly predicted as positive (the bottom row). </p><p><a href=\"https://en.wikipedia.org/wiki/F1_score\" target=\"_blank\" rel=\"noopener\">F is the average of precision and recall.</a></p><p>And the results (on the extended When Will the Monolith React? data) were as follows:</p><p>Precision = 71%</p><p>Recall = 45%</p><p>F = 56%</p><p>Precision is better than recall. 71% of the models predicted “Reaction” cases were in fact a “Reaction”. However, the model only correctly predicted 45% of all the actual “Reaction” cases correctly. The reason for using precision and recall metrics is to check if the model performance is purely the result of guessing. For example, if only 20% of examples are positive, then just guessing will result in a model “accuracy” approaching 80%.</p><h4>FILTER</h4><p>Another common Spark transformation is filter.   We’ll use filter to count the number of positive and negative examples in the data to check if our model is any better than guessing. filter() takes a function as the argument, applies it to each element in the dataset, and only returns the element if the function evaluates to true. </p><p>This code calculates that there are 884 examples, 155 positive and 729 negative, giving:</p><p>probability of positive example = 0.1753393665158371</p><p>probability of negative example = 0.8246606334841629</p><p>This tells us that just guessing would result in close to 82% accuracy. The actual model accuracy for the example is 85% (which requires extra code, not shown).</p><h2>Spark Context</h2><p><a href=\"http://spark.apache.org/docs/latest/rdd-programming-guide.html\" target=\"_blank\" rel=\"noopener\">http://spark.apache.org/docs/latest/rdd-programming-guide.html</a></p><p><a href=\"https://spark.apache.org/docs/latest/api/java/org/apache/spark/SparkContext.html\" target=\"_blank\" rel=\"noopener\">https://spark.apache.org/docs/latest/api/java/org/apache/spark/SparkContext.html</a></p><p>This leaves us with the final but “important bit” of the code at the start.  How is Spark actually run?  A SparkContext object tells Spark how to access a cluster, and a SparkConf has information about your application.  Given that we are just running Spark locally just pass “local” to setMaster.</p><p>SparkConf conf = new SparkConf().setAppName(“Java Decision Tree Classification Example”);<br />conf.setMaster(“local”);<br />SparkContext sc = new SparkContext(conf);<br />String path = “WillTheMonolithReact.txt”;</p><p><a href=\"https://spark.apache.org/docs/latest/cluster-overview.html\" target=\"_blank\" rel=\"noopener\">To run Spark on a cluster</a> you need (a) a cluster with Spark set-up (e.g. an Instaclustr cluster with Spark add-on), and (b) <a href=\"https://support.instaclustr.com/hc/en-us/articles/213097877-Getting-Started-with-Instaclustr-Spark-Cassandra\" target=\"_blank\" rel=\"noopener\">to know more about the Spark architecture and how to package and submit applications</a>.</p><p>How does this help with our approach to the Monolith? Maybe raising the POD’s manipulators in “greeting”? Will it be friends?</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/2001-4d.jpeg\"><img class=\"alignnone size-medium wp-image-6896\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/2001-4d-300x140.jpeg\" alt=\"\" width=\"300\" height=\"140\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4d-300x140.jpeg 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4d-103x48.jpeg 103w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4d-232x108.jpeg 232w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4d.jpeg 638w\" /></a></p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/2001-4e.jpeg\"><img class=\"alignnone size-medium wp-image-6897\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/2001-4e-300x140.jpeg\" alt=\"\" width=\"300\" height=\"140\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4e-300x140.jpeg 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4e-103x48.jpeg 103w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4e-232x108.jpeg 232w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4e.jpeg 638w\" /></a></p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2017/09/2001-4f.jpeg\"><img class=\"alignnone size-medium wp-image-6898\" src=\"https://www.instaclustr.com/wp-content/uploads/2017/09/2001-4f-300x140.jpeg\" alt=\"\" width=\"300\" height=\"140\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4f-300x140.jpeg 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4f-103x48.jpeg 103w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4f-232x108.jpeg 232w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2017/09/2001-4f.jpeg 638w\" /></a></p><h4>NOTE 1</h4><p>The actual data I used for this example was from the Instametrics example introduced in previous blogs, with the goal of predicting long JVM Garbage Collections in advance. I took a small sample of JVM-related metrics, and computed the min, avg and max for each 5 minute bucket. These became the features. For the label I determined if there was a long GC in the next 5 minute bucket (1) or not (0).  The real data has 1,000s of metrics, so next blog we’re going to need some serious Spark processing even just to produce the training data, and explore the interface to Cassandra, and the suitability of Cassandra for Sparse data.</p><h4>NOTE 2</h4><p>Space travel is sooooo slow, in the years we’ve been on board Spark has changed from RDD to DataFrames. I’ll revise the code for the next blog.</p><p><i>Guide </i><a href=\"https://spark.apache.org/docs/latest/ml-guide.html\" target=\"_blank\" rel=\"noopener\"><i>https://spark.apache.org/docs/latest/ml-guide.html</i></a></p><p><i>As of Spark 2.0, the </i><a href=\"https://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds\" target=\"_blank\" rel=\"noopener\"><i>RDD</i></a><i>-based APIs in the </i><i>spark.mllib</i><i> package have entered maintenance mode. The primary Machine Learning API for Spark is now the </i><a href=\"https://spark.apache.org/docs/latest/sql-programming-guide.html\" target=\"_blank\" rel=\"noopener\"><i>DataFrame</i></a><i>-based API in the </i><i>spark.ml</i><i> package.</i></p>"}}]}},"pageContext":{"alternative_id":12149}}