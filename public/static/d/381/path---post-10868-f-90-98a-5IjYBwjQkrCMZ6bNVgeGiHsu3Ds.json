{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Cassandra Data Modeling: Primary, Clustering, Partition, and Compound Keys - DZone Database","alternative_id":10868,"content":"<div class=\"content-html\" itemprop=\"text\"><p>In this post, we are going to discuss the different keys available in Cassandra. The primary key concept in Cassandra is different from relational databases. Therefore, it is worth spending some time to understand it.</p>\n<p>Let's take an example and create a student table which has <code>student_id</code> as a primary key column.</p>\n<h2><strong>1) Primary Key </strong></h2>\n<pre lang=\"text/x-cassandra\">create table person (student_id int primary key, fname text, lname text, \n                     dateofbirth timestamp, email text, phone text );</pre>\n<p>In Cassandra, a table can have a number of rows. Each row is referenced by a primary key, also called the row key. There are a number of columns in a row but the number of columns can vary in different rows.</p>\n<p>For example, one row in a table can have three columns whereas another row in the same table can have 10 columns. It is also important to note that in Cassandra, both column names and values have binary types. That means column names can have binary values, such as strings, timestamps, or an integer, etc. This is different from SQL databases, where each row in a SQL table has a fixed number of columns, and column names can only be text.</p>\n<p>We saw that <code>student_id</code> was used as a row key to refer to <code>person</code> data.</p>\n<h2><strong>2) Compound Primary Key</strong></h2>\n<p>As the name suggests, a compound primary key is comprised of one or more columns that are referenced in the primary key. One component of the compound primary key is called partition key, whereas the other component is called the clustering key. The following are different variations of primary keys. Please note that C1, C2, C3,… and so on represent columns in the table.</p>\n<ul><li><p><strong>C1</strong>: Primary key has only one partition key and no cluster key.</p></li>\n <li><p><strong>(C1, C2)</strong>: Column C1 is a partition key and column C2 is a cluster key.</p></li>\n <li><p><strong>(C1,C2,C3,…)</strong>: Column C1 is a partition key and columns C2, C3, and so on make the cluster key.</p></li>\n <li><p><strong>(C1, (C2, C3,…))</strong>: It is same as 3, i.e., column C1 is a partition key and columns C2,C3,… make the cluster key.</p></li>\n <li><p><strong>((C1, C2,…), (C3,C4,…))</strong>: columns C1, C2 make partition key and columns C3,C4,… make the cluster key.</p></li>\n</ul><p>It is important to note that when the compound key is C1, C2, C3, then the first key, C1, becomes the partition key, and the rest of the keys become part of the cluster key. In order to make composite partition keys, we have to specify keys in parenthesis such as: ( ( C1,C2) , C3, C4). In this case, C1 and C2 are part of the partition keys, and C3 and C4 are part of the cluster key.</p>\n<h2><strong>3) Partition Key</strong></h2>\n<p>The purpose of a partition key is to identify the partition or node in the cluster that stores that row. When data is read or written from the cluster, a function called Partitioner is used to compute the hash value of the partition key. This hash value is used to determine the node/partition which contains that row. For example, rows whose partition key values range from 1000 to 1234 may reside in node A, and rows with partition key values range from 1235 to 2000 may reside in node B, as shown in figure 1. If a row contains partition key whose hash value is 1233 then it will be stored in node A.</p>\n<p><img alt=\"cluster\" class=\"alignnone size-full wp-image-20848 fr-fin fr-dib\" src=\"https://knoldus.files.wordpress.com/2016/10/cluster.gif?w=640\" /></p>\n<h2><strong>4) Clustering Key</strong></h2>\n<p>The purpose of the clustering key is to store row data in a sorted order. The sorting of data is based on columns, which are included in the clustering key. This arrangement makes it efficient to retrieve data using the clustering key.</p>\n<h2><strong>Example</strong></h2>\n<p>To make these concepts clear, we will consider the example of a school system.</p>\n<p>Create a keyspace with replication strategy ‘SimpleStrategy’ and replication_factor 1.</p>\n<pre lang=\"text/x-cassandra\">create keyspace Students_Details with replication = {‘class’ : ‘SimpleStrategy’, ‘replication_factor’:1};</pre>\n<p>Now switch to the students_details keyspace:</p>\n<pre lang=\"text/x-cassandra\">use students_details;\n</pre>\n<p>Check the number of tables present in the keyspace:</p>\n<pre lang=\"text/x-cassandra\">students_details&gt; desc TABLES;</pre>\n<p>We will create a table, <code>student</code> , that contains general information about any student.</p>\n<pre lang=\"text/x-cassandra\">create table student (stuid int, avg_marks float, description text, \n                      primary key (stuid));</pre>\n<p>Type the following insert statements to enter some data into this table.</p>\n<pre lang=\"text/x-cassandra\">insert into student (stuid, avg_marks, description) values (1,25.5,’student 1′);\ninsert into student (stuid, avg_marks, description) values (2,35.5,’student 2′);</pre>\n<p>To view the details just inserted...</p>\n<pre lang=\"text/x-cassandra\">students_details&gt; select * from student;</pre>\n<pre lang=\"text/x-sh\">stuid | avg_marks | description\n——-+———–+————-\n1 |      25.5 |   student 1\n2 |      35.5 |   student 2</pre>\n<p>We can see how Cassandra has stored this data under the hood by using the <code>cassandra-cli</code> tool. Run <code>cassandra-cli</code> in a separate terminal windo.</p>\n<p><strong>Important</strong>: The CLI utility is deprecated and will be removed in Cassandra 3.0. For ease of use and performance, switch from Thrift and CLI to CQL and cqlsh.)</p>\n<p>So if you're using a Cassandra verison above 3.0, then use the below commands.</p>\n<p>Using the <strong>EXPAND</strong> Command in cqlsh , we can view the details info for the queries . EXPAND with no arguments shows the current value of the expanded setting.</p>\n<p><code>cqlsh:students_details&gt; EXPAND</code> </p>\n<p>If expanded output is disabled. Use <code>EXPAND ON</code> to enable it.</p>\n<p>Now view the details inserted above (the studid will be present in a red color in cqlsh, representing the primary key/row key)</p>\n<p><code>cqlsh:students_details&gt; select * from student;</code></p>\n<pre lang=\"text/x-cassandra\">@ Row 1\n————-+———–\nstuid       | 1\navg_marks   | 25.5\ndescription | student 1\n@ Row 2\n————-+———–\nstuid       | 2\navg_marks   | 35.5\ndescription | student 2\n(2 rows)</pre>\n<p>We can see from the above output that the stuid has become the row key, and it identifies individual rows.</p>\n<p><code>cqlsh:students_details&gt; select token(stuid) from student;</code></p>\n<pre lang=\"text/x-sh\">@ Row 1\n———————+———————-\nsystem.token(stuid) | -4069959284402364209\n@ Row 2\n———————+———————-\nsystem.token(stuid) | -3248873570005575792</pre>\n<p>Also, you can see that there are two tokens.</p>\n<p>We can use columns in the primary key to filter data in the select statement. Type the following command in the cqlsh window:</p>\n<p><code>select * from student where stuid = 1;</code> </p>\n<p>Now we will create another table called marks, which records marks of each student every day (say every day, new exams and marks are recorded). Type the following command on cqlsh:</p>\n<pre lang=\"text/x-cassandra\">create table marks(stuid int,exam_date timestamp,marks float, exam_name text, \n                   primary key (stuid,exam_date));</pre>\n<p>This statement creates the marks table with a primary key (stuid , exam_date ). As the primary key has two components, the first component is considered a partition key, and the second component becomes the cluster key. Add some data into the table:</p>\n<pre lang=\"text/x-cassandra\">insert into marks(stuid ,exam_date ,marks ,exam_name) values (1,’2016-11-10′,76 ,’examA’);\ninsert into marks(stuid ,exam_date ,marks ,exam_name) values (1,’2016-11-11′,90 ,’examB’);\ninsert into marks(stuid ,exam_date ,marks ,exam_name) values (1,’2016-11-12′,68 ,’examC’);</pre>\n<p><code>cqlsh:students_details&gt; select * from marks;</code></p>\n<pre lang=\"text/x-cassandra\">@ Row 1\n———–+————————–\nstuid     | 1\nexam_date | 2016-11-09 18:30:00+0000\nexam_name | examA\nmarks     | 76\n@ Row 2\n———–+————————–\nstuid     | 1\nexam_date | 2016-11-10 18:30:00+0000\nexam_name | examB\nmarks     | 90\n@ Row 3\n———–+————————–\nstuid     | 1\nexam_date | 2016-11-11 18:30:00+0000\nexam_name | examC\nmarks     | 68</pre>\n<p>Now, let's see how the partition concept has been applied:</p>\n<p><code>cqlsh:students_details&gt; select token(stuid) from marks;</code></p>\n<pre lang=\"text/x-cassandra\">@ Row 1\n———————+———————-\nsystem.token(stuid) | -4069959284402364209\n@ Row 2\n———————+———————-\nsystem.token(stuid) | -4069959284402364209\n@ Row 3\n———————+———————-\nsystem.token(stuid) | -4069959284402364209</pre>\n<p>We can see all the three rows have the <strong>same partition token</strong>, hence Cassandra stores only one row for each partition key. All the data associated with that partition key is stored as columns in the datastore. The data that we have stored through three different insert statements have the same stuid value, i.e. 1, therefore, all the data is saved in that row as columns, i.e under one partition.</p>\n<p>If you remember, we discussed before that the second component of a primary key is called the clustering key. The role of the clustering key is to group related items together. All the data that is inserted against same clustering key is grouped together.</p>\n<p>In this case, all the columns, such as <strong>exam_name </strong>and<strong> marks</strong>, will be grouped by value in <strong>exam</strong>_<strong>date</strong>, i.e 2016-11-11 18:30:00+0000, by default in ascending order .</p>\n<p>I hope these examples have helped you to clarify some of the concepts of data modeling in Cassandra. Please feel free to leave any comments.</p></div><div class=\"content-html\" itemprop=\"text\"><a>\n                        <img class=\"pub-image\" width=\"420\" itemprop=\"image\" src=\"src\" alt=\"image\" /></a></div>"}}]}},"pageContext":{"alternative_id":10868}}