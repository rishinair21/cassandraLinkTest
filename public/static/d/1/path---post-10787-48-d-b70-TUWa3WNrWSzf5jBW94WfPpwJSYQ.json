{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"Using Apache Cassandra — A few things before you start","alternative_id":10787,"content":"<p id=\"8aee\" class=\"graf graf--p graf-after--h3\">The <a href=\"https://www.slideshare.net/planetcassandra/cassandra-summit-2014-cql-under-the-hood-39445761\" data-href=\"https://www.slideshare.net/planetcassandra/cassandra-summit-2014-cql-under-the-hood-39445761\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">CQL</a> — Cassandra Query language gives an almost SQL type interface to Apache Cassandra. I have found many times,that many who use this,do not know about some important points of Cassandra that makes it different from SQL databases like Postgres. Same is the case for operations team, there are some aspects related to storage, GC settings , that many are not aware of. I am not an expert in Cassandra internals and don’t aspire to be if I can avoid it.This is mostly a note to myself, and something which I can ask others to refer to instead of repeating over email a gazillion times. There are lot of other parts like repair etc which I have left out. The intention here is to make this as short as possible, but if you feel somethings are to be added, please comment.</p><h4 id=\"2e37\" class=\"graf graf--h4 graf-after--p\">Cassandra has Tune-able Consistency — not just eventual consistency</h4><p id=\"0963\" class=\"graf graf--p graf-after--h4\">Many considering Cassandra as a replacement for SQL database like Postgres, MySQL or Oracle, shy away thinking that eventual consistency of NoSQL does not meet their requirement. In Cassandra ,however consistency is configurable. This means that with some write and read speed sacrifice, you can have strong consistency as well as high availability. Cassandra can be used for small data as well as big data; depending on your use case you can tune the consistency per key-space or even per-operation.</p><blockquote id=\"86c1\" class=\"graf graf--blockquote graf-after--p\"><div>Cassandra values Availability and Partitioning tolerance (AP). Tradeoffs between consistency and latency are tunable in Cassandra. You can get strong consistency with Cassandra (with an increased latency).<br /><a href=\"https://wiki.apache.org/cassandra/ArchitectureOverview\" data-href=\"https://wiki.apache.org/cassandra/ArchitectureOverview\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"nofollow noopener noopener\" target=\"_blank\">https://wiki.apache.org/cassandra/ArchitectureOverview</a></div></blockquote><p id=\"712d\" class=\"graf graf--p graf-after--blockquote\">At this point it may be a good idea to have a short recap of CAP theorem as there is a lot of confusion translating the theoretical surmise to the practical world.</p><blockquote id=\"e767\" class=\"graf graf--blockquote graf-after--p\"><div>In 2000, Dr. Eric Brewer gave a keynote at the <em class=\"markup--em markup--blockquote-em\">Proceedings of the Annual ACM Symposium on Principles of Distributed Computing</em> in which he laid out his famous CAP Theorem: <em class=\"markup--em markup--blockquote-em\">a shared-data system can have at most two of the three following properties: </em><strong class=\"markup--strong markup--blockquote-strong\"><em class=\"markup--em markup--blockquote-em\">C</em></strong><em class=\"markup--em markup--blockquote-em\">onsistency, </em><strong class=\"markup--strong markup--blockquote-strong\"><em class=\"markup--em markup--blockquote-em\">A</em></strong><em class=\"markup--em markup--blockquote-em\">vailability, and tolerance to network </em><strong class=\"markup--strong markup--blockquote-strong\"><em class=\"markup--em markup--blockquote-em\">P</em></strong><em class=\"markup--em markup--blockquote-em\">artitions.</em></div></blockquote><p id=\"cb8b\" class=\"graf graf--p graf-after--blockquote\">This applies to any distributed data base, not just Cassandra.So Cassandra can provide C and A not P ? Is it a big problem ?</p><p id=\"c5f4\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">Short answer — It is not. Skip the rest of the section if you are in a hurry.</strong></p><p id=\"b375\" class=\"graf graf--p graf-after--p\">Long answer read on.Here is the excerpt from Cassandra docs. (DataStax’s docs)</p><blockquote id=\"82aa\" class=\"graf graf--blockquote graf-after--p\"><div>… You can tune Cassandra’s consistency level per-operation, or set it globally for a cluster or datacenter. You can vary the consistency for individual read or write operations so that the data returned is more or less consistent, as required by the client application. This allows you to make Cassandra act more like a CP (consistent and partition tolerant) or AP (highly available and partition tolerant) system according to the CAP theorem, depending on the application requirements.</div></blockquote><blockquote id=\"8be4\" class=\"graf graf--blockquote graf-after--blockquote\"><div><strong class=\"markup--strong markup--blockquote-strong\">Note:</strong> It is not possible to “tune” Cassandra into a completely CA system. See <a href=\"https://codahale.com/you-cant-sacrifice-partition-tolerance/\" data-href=\"https://codahale.com/you-cant-sacrifice-partition-tolerance/\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"noopener\" target=\"_blank\">You Can’t Sacrifice Partition Tolerance</a> for a more detailed discussion. -<a href=\"https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlAboutDataConsistency.html#dmlAboutDataConsistency__eventual-consistency\" data-href=\"https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlAboutDataConsistency.html#dmlAboutDataConsistency__eventual-consistency\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlAboutDataConsistency.html</a></div></blockquote><p id=\"f1c2\" class=\"graf graf--p graf-after--blockquote\">Here is an excerpt from the article linked in the DataStax’ s Cassandra documentation page.</p><blockquote id=\"15b8\" class=\"graf graf--blockquote graf-after--p\"><div>Of the CAP theorem’s Consistency, Availability, and Partition Tolerance, <strong class=\"markup--strong markup--blockquote-strong\">Partition Tolerance is mandatory in distributed systems. You cannot not choose it. </strong>Instead of CAP, you should think about your availability in terms of <em class=\"markup--em markup--blockquote-em\">yield</em> (percent of requests answered successfully) and <em class=\"markup--em markup--blockquote-em\">harvest</em> (percent of required data actually included in the responses) and which of these two your system will sacrifice when failures happen. -<a href=\"https://codahale.com/you-cant-sacrifice-partition-tolerance/\" data-href=\"https://codahale.com/you-cant-sacrifice-partition-tolerance/\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://codahale.com/you-cant-sacrifice-partition-tolerance/</a></div></blockquote><p id=\"c333\" class=\"graf graf--p graf-after--blockquote\">What the above article explains in depth is that Availability is tied to Network Partitioning or Partition Tolerance.Worst case scenario network partitions are quite rare inside a Data Center network. Also network partitions cannot be prevented from happening. It is ever present, though mostly transient and intermittent. The risk of network partitioning across many nodes in a cluster so as to disrupt Availability for a multi-node cluster is very less.</p><p id=\"ddd6\" class=\"graf graf--p graf-after--p\">So with Cassandra you can have as good a C and A system as practically possible.</p><h4 id=\"f386\" class=\"graf graf--h4 graf-after--p\"><strong class=\"markup--strong markup--h4-strong\">Give Importance to modelling the Partition key</strong></h4><p id=\"607e\" class=\"graf graf--p graf-after--h4\">If there is only one thing that you should read,maybe it is the link below</p><p><a href=\"https://www.datastax.com/dev/blog/the-most-important-thing-to-know-in-cassandra-data-modeling-the-primary-key\" data-href=\"https://www.datastax.com/dev/blog/the-most-important-thing-to-know-in-cassandra-data-modeling-the-primary-key\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://www.datastax.com/dev/blog/the-most-important-thing-to-know-in-cassandra-data-modeling-the-primary-key\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">The most important thing to know in Cassandra data modeling: The primary key</strong><br /><em class=\"markup--em markup--mixtapeEmbed-em\">Patrick is regarded as one of the foremost experts of Apache Cassandra and data modeling techniques. As the Chief…</em>www.datastax.com</a></p><p id=\"958c\" class=\"graf graf--p graf-after--mixtapeEmbed\">What is the Partition Key ? It is the first part of the Primary Key or the Primary key itself if Primary key is not composite</p><p id=\"5327\" class=\"graf graf--p graf-after--p\">Why is this most important part ?</p><p id=\"fbfc\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">To have balanced write of data to multiple Cassandra nodes in the cluster and subsequent balanced reads of the data.</strong></p><blockquote id=\"fe60\" class=\"graf graf--blockquote graf-after--p\"><div>When data is inserted into the cluster, the first step is to apply a hash function to the partition key. The output is used to determine what node (and replicas) will get the data.-<a href=\"https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/architecture/archPartitionerM3P.html\" data-href=\"https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/architecture/archPartitionerM3P.html\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/architecture/archPartitionerM3P.html</a></div></blockquote><p id=\"1e3d\" class=\"graf graf--p graf-after--blockquote\">Here are two main goals to consider for modelling the data</p><p><a href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" data-href=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Basic Rules of Cassandra Data Modeling</strong><br /><em class=\"markup--em markup--mixtapeEmbed-em\">Learn more about Apache Cassandra and data modeling READ MORE DS:220 COURSE Picking the right data model is the hardest…</em>www.datastax.com</a></p><p id=\"1dab\" class=\"graf graf--p graf-after--mixtapeEmbed\">1. Spread data evenly around the cluster — Model Partition Key</p><p id=\"8ae6\" class=\"graf graf--p graf-after--p\">2. Minimize the number of partitions read -Model Partition Key and Clustering keys</p><p id=\"9ea6\" class=\"graf graf--p graf-after--p\">Let us take an example. Below is a initial modelling of table where the data is some events (say political rallies, speeches etc) that has occurred in a particular location, centered over latitude,longitude and say having a radius of 250 meters. Each location has an influential candidate of that area. Sometimes the same area can have multiple influential candidates. I have illustrated a slightly complex example so as to show the flexibility in data types present in Cassandra,and all the aspects to consider when modelling the key. The actual cell can be a telecom cell with multiple coverage by different operators or different technologies. The example I give here is a bit contrived and for illustration only.</p><figure id=\"716e\" class=\"graf graf--figure graf--iframe graf-after--p\"><p id=\"8775\" class=\"graf graf--p graf-after--figure\">Note that partition key is chosen assuming that events are distributed evenly across a city, the key will distribute the data from multiple locations evenly across available Cassandra nodes.</p><p id=\"9ffa\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">The partition query should be modeled for efficient retrieval of the data application needs</strong></p><p id=\"9633\" class=\"graf graf--p graf-after--p\">The modelling of Tables and thereby the partition key is primarily with consideration of efficient data retrieval.</p><p id=\"02b8\" class=\"graf graf--p graf-after--p\">Assume that we need to query all events happening in a location by a Candidate for a time interval.The queries will be a set of statements like</p><blockquote id=\"ec1c\" class=\"graf graf--blockquote graf-after--p\"><div>select * from demo_table where bin_cell_key = (1234, 222, ‘Candidate1’) and time_key &gt;= (‘06:00:00.000000000’, ‘06:00:00.000000000’) and time_key &lt; (‘07:30:00.000000000’, ‘07:30:00.000000000’)</div></blockquote><blockquote id=\"6b6b\" class=\"graf graf--blockquote graf-after--blockquote\"><div>select * from demo_table where bin_cell_key = (1234, 223, ‘Candidate1’) ..</div></blockquote><p id=\"feeb\" class=\"graf graf--p graf-after--blockquote\">But to compose this <em class=\"markup--em markup--p-em\">bin_cell_key</em> we need to know first which Candidates are there in which locations. For this we need to model helper tables. Note — Data duplication is okay in NoSQL data modelling and to have the same effect of JOINs this is needed. Some helper tables to get the bin_cell_key</p><blockquote id=\"42fa\" class=\"graf graf--blockquote graf-after--p\"><div>create table cell_bin (cell text, bin tuple&lt;int,int&gt;, PRIMARY KEY (cell,bin));</div></blockquote><p id=\"ac52\" class=\"graf graf--p graf-after--blockquote\">Example CQL:</p><blockquote id=\"011b\" class=\"graf graf--blockquote graf-after--p\"><div>select * from cell_bin where cell=’Candidate1’;</div></blockquote><blockquote id=\"f71c\" class=\"graf graf--blockquote graf-after--blockquote\"><div>cell | bin<br /> — — — — -+ — — — — —-<br />Candidate1| (1234, 222)<br />Candidate1| (1234, 223)</div></blockquote><p id=\"f849\" class=\"graf graf--p graf-after--blockquote\">And similarly for the other way round</p><blockquote id=\"caf0\" class=\"graf graf--blockquote graf-after--p\"><div>create table bin_cell (bin tuple&lt;int,int&gt;, cell text, PRIMARY KEY (bin,cell));</div></blockquote><p id=\"21a2\" class=\"graf graf--p graf-after--blockquote\">Example CQL:</p><blockquote id=\"0774\" class=\"graf graf--blockquote graf-after--p\"><div>cqlsh:demo_keyspace&gt; select * from bin_cell where bin = (1234, 222);<br /> bin | cell<br /> — — — — -+ — — — —— -<br /> (1234, 222) | Candidate1<br /> (1234, 222) | Candidate2</div></blockquote><p id=\"fca6\" class=\"graf graf--p graf-after--blockquote\">We can stop here. But if you are curious read on. What if we want to aggregate all events that has taken place in a region irrespective of the Candidate. For this we need to split the cell out. Why ? because in case of a composite partition key all the elements need to be specified in the query.</p><blockquote id=\"ebf9\" class=\"graf graf--blockquote graf-after--p\"><div>select * from demo_table where bin = (1234,222) and year=2017 and month=12 and day=1;</div></blockquote><p id=\"81aa\" class=\"graf graf--p graf-after--blockquote\">The table for below which also adds time to the partition key so that data from different days are distributed across available nodes are given below.</p><figure id=\"2100\" class=\"graf graf--figure graf--iframe graf-after--p\"><blockquote id=\"861f\" class=\"graf graf--blockquote graf-after--figure\"><div>create table demo_table( year int,month int,day int, bin tuple&lt;double,double&gt;, cell text, time_key tuple&lt;timestamp,timestamp&gt;,event text, PRIMARY KEY((bin,year,month,day),cell,time_key));</div></blockquote><h4 id=\"040b\" class=\"graf graf--h4 graf-after--blockquote\">Test and measure your reads &amp; write via nodetool cfstats</h4><p id=\"f60b\" class=\"graf graf--p graf-after--h4\">How do we know if our data model is distributing writes across nodes. How do we know if the write latency and read latency is distributed across nodes and if it is linearly scale able in proportional to the nodes added. The answer to all of this via node tool cfstats command</p><p><a href=\"https://docs.datastax.com/en/cassandra/2.1/cassandra/tools/toolsCFstats.html\" data-href=\"https://docs.datastax.com/en/cassandra/2.1/cassandra/tools/toolsCFstats.html\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://docs.datastax.com/en/cassandra/2.1/cassandra/tools/toolsCFstats.html\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">nodetool cfstats</strong><br /><em class=\"markup--em markup--mixtapeEmbed-em\">Provides statistics about tables.</em>docs.datastax.com</a></p><p id=\"0c51\" class=\"graf graf--p graf-after--mixtapeEmbed\">You need to run long runs with write and then read operations using multiple nodes and everyday update a table like one below based on the output from cfstats. Soon you will know if your write and read are balanced. Actually adding more nodes should also decrease your read time linearly. This is really beautiful.</p><figure id=\"f30b\" class=\"graf graf--figure graf--iframe graf-after--p\"><h4 id=\"73a0\" class=\"graf graf--h4 graf-after--figure\">Do not use ALLOW FILTERING and IN Clause in CQL indiscriminately</h4><p id=\"1258\" class=\"graf graf--p graf-after--h4\">If you feel that there is no way out; then please read the section above. Most probably your table modelling has to be refactored.</p><blockquote id=\"3ad8\" class=\"graf graf--blockquote graf-after--p\"><div>When your query is rejected by Cassandra because it needs filtering, you should resist the urge to just add ALLOW FILTERING to it. You should think about your data, your model and what you are trying to do. -<a href=\"https://www.datastax.com/dev/blog/allow-filtering-explained-2\" data-href=\"https://www.datastax.com/dev/blog/allow-filtering-explained-2\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://www.datastax.com/dev/blog/allow-filtering-explained-2</a></div></blockquote><p id=\"820a\" class=\"graf graf--p graf-after--blockquote\"><strong class=\"markup--strong markup--p-strong\">Or for that matter IF clause</strong></p><p id=\"fba3\" class=\"graf graf--p graf-after--p\">The new versions of Cassandra supports light-weight transactions. In CQL this is done via the IF clause. <em class=\"markup--em markup--p-em\">Insert into table IF NOT EXISTS</em>.</p><blockquote id=\"8bee\" class=\"graf graf--blockquote graf-after--p\"><a href=\"https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlLtwtTransactions.html\" data-href=\"https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlLtwtTransactions.html\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"noopener\" target=\"_blank\">Lightweight transactions</a><div> should not be used casually, as the latency of operations increases fourfold due to the due to the round-trips necessary between the CAS coordinators. -</div><a href=\"https://docs.datastax.com/en/cql/3.3/cql/cql_using/useInsertLWT.html\" data-href=\"https://docs.datastax.com/en/cql/3.3/cql/cql_using/useInsertLWT.html\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://docs.datastax.com/en/cql/3.3/cql/cql_using/useInsertLWT.html</a></blockquote><h4 id=\"185f\" class=\"graf graf--h4 graf-after--blockquote\">Be aware of the JVM GC Suck-age as JVM Heap Increases</h4><p id=\"e711\" class=\"graf graf--p graf-after--h4\">Cassandra runs on the JVM and relies on the OS page cache for improving performance. <em class=\"markup--em markup--p-em\">There is no need to throw huge amounts of RAM at Cassandra</em>. Cassandra performance should increase by adding more low powered nodes.We have run our long runs for about 2 weeks with load on 2 GB JVM heap, and Cassandra had never once gone down.</p><p id=\"df9c\" class=\"graf graf--p graf-after--p\">JVM GC suckage is directly proportional to the JVM heap. This is true for any Java process and also for Cassandra</p><figure id=\"be45\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*HQhjWbOdml9VTeSYo18Pdw.png\" data-width=\"533\" data-height=\"400\" src=\"https://cdn-images-1.medium.com/max/1600/1*HQhjWbOdml9VTeSYo18Pdw.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\">source-<a href=\"https://www.slideshare.net/mattdennis/cassandra-antipatterns\" data-href=\"https://www.slideshare.net/mattdennis/cassandra-antipatterns\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener noopener\" target=\"_blank\">https://www.slideshare.net/mattdennis/cassandra-antipatterns</a></figcaption></figure><p id=\"da9f\" class=\"graf graf--p graf-after--figure\"><em class=\"markup--em markup--p-em\">Some illuminating quotes</em></p><p id=\"3659\" class=\"graf graf--p graf-after--p\"><em class=\"markup--em markup--p-em\">Many users new to Cassandra are tempted to turn up Java heap size too high, which consumes the majority of the underlying system’s RAM. In most cases, increasing the Java heap size is actually </em><strong class=\"markup--strong markup--p-strong\"><em class=\"markup--em markup--p-em\">detrimental</em></strong><em class=\"markup--em markup--p-em\"> for these reasons:</em></p><p id=\"3569\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\"><em class=\"markup--em markup--p-em\">1</em>. <em class=\"markup--em markup--p-em\">In most cases, the capability of Java to gracefully handle garbage collection above 8GB quickly diminishes.</em></strong></p><p id=\"0c46\" class=\"graf graf--p graf-after--p\"><em class=\"markup--em markup--p-em\">2.Modern operating systems maintain the OS page cache for frequently accessed data and are very good at keeping this data in memory, but can be prevented from doing its job by an elevated Java heap size.</em></p><p id=\"f7a1\" class=\"graf graf--p graf-after--p\"><em class=\"markup--em markup--p-em\">If you have more than 2GB of system memory, which is typical, keep the size of the Java heap relatively small to allow more memory for the page cache .</em></p><p><a href=\"http://docs.datastax.com/en/cassandra/2.0/cassandra/operations/ops_tune_jvm_c.html\" data-href=\"http://docs.datastax.com/en/cassandra/2.0/cassandra/operations/ops_tune_jvm_c.html\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"http://docs.datastax.com/en/cassandra/2.0/cassandra/operations/ops_tune_jvm_c.html\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Tuning Java resources</strong><br /><em class=\"markup--em markup--mixtapeEmbed-em\">Consider tuning Java resources in the event of a performance degradation or high memory consumption.</em>docs.datastax.com</a></p><p id=\"4efa\" class=\"graf graf--p graf-after--mixtapeEmbed\">Database like <a href=\"http://www.scylladb.com/open-source/\" data-href=\"http://www.scylladb.com/open-source/\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">Scylla DB</a> have ported the Cassandra design on to C++ so as to avoid the GC pauses and other such problems related to JVM. But as long as you keep the JVM heap around 8 GB things should be fine.</p><p id=\"e23d\" class=\"graf graf--p graf-after--p\">An update here- While I was working with Cassandra G1GC was not deemed stable enough to be used. Now DataStax version of Cassandra used G1GC. G1GC can handle larger heaps; however Cassandra can use RAM heavily for page caches, filters etc, so all the above still makes sense. Limit JVM heap to the minimum you need and leave the rest of the memory for Cassandra process.</p><h4 id=\"a0f6\" class=\"graf graf--h4 graf-after--p\">Cassandra does not like SAN/Shared Storage</h4><p id=\"c898\" class=\"graf graf--p graf-after--h4\">Cassandra is designed for the low fetch times of spinning disks by only appending data to the end for writes and minimize disk seek time during read via application selected partition keys and thereby spreading reads across multiple nodes — Regarding storage a good slide to go through <a href=\"https://www.slideshare.net/johnny15676/why-does-my-choiceofstorage-matterwithcassandra\" data-href=\"https://www.slideshare.net/johnny15676/why-does-my-choiceofstorage-matterwithcassandra\" class=\"markup--anchor markup--p-anchor\" title=\"https://www.slideshare.net/johnny15676/why-does-my-choiceofstorage-matterwithcassandra\" rel=\"noreferrer noopener noopener noopener\" target=\"_blank\">https://www.slideshare.net/johnny15676/why-does-my-choiceofstorage-matterwithcassandra</a></p><figure id=\"9e1c\" class=\"graf graf--figure graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"><img class=\"graf-image\" data-image-id=\"1*SEX2I_8ohef5sG65VuX5ow.png\" data-width=\"613\" data-height=\"449\" data-is-featured=\"true\" src=\"https://cdn-images-1.medium.com/max/1600/1*SEX2I_8ohef5sG65VuX5ow.png\" alt=\"image\" /></div><figcaption class=\"imageCaption\">source-<a href=\"https://www.slideshare.net/johnny15676/why-does-my-choiceofstorage-matterwithcassandra\" data-href=\"https://www.slideshare.net/johnny15676/why-does-my-choiceofstorage-matterwithcassandra\" class=\"markup--anchor markup--figure-anchor\" title=\"https://www.slideshare.net/johnny15676/why-does-my-choiceofstorage-matterwithcassandra\" rel=\"noreferrer noopener noopener noopener noopener noopener\" target=\"_blank\">https://www.slideshare.net/johnny15676/why-does-my-choiceofstorage-matterwithcassandra</a></figcaption></figure><blockquote id=\"5b27\" class=\"graf graf--blockquote graf-after--figure\"><div>Customer/User — “We have an awesome SAN and would like to use it for Cassandra.”<br />DataStax — “We don’t recommend shared storage for Cassandra.”<br />Customer/User — “Why not.”<br />DataStax — “Two reasons really. One — performance suffers. Two — shared storage introduces a single point of failure into the architecture.”<br />Customer/User — “Our SAN is awesome and has never had any down time and can preform a kagillion IOPS. So why exactly shouldn’t we use shared storage.”</div></blockquote><blockquote id=\"8db5\" class=\"graf graf--blockquote graf-after--blockquote\"><a href=\"https://www.datastax.com/dev/blog/impact-of-shared-storage-on-apache-cassandra\" data-href=\"https://www.datastax.com/dev/blog/impact-of-shared-storage-on-apache-cassandra\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"nofollow noopener noopener\" target=\"_blank\">https://www.datastax.com/dev/blog/impact-of-shared-storage-on-apache-cassandra</a></blockquote><h4 id=\"2539\" class=\"graf graf--h4 graf-after--blockquote\">Horizontal Scale-ability -Transparent Sharding vs Application Level Sharding</h4><p id=\"f4c4\" class=\"graf graf--p graf-after--h4\">Database sharding is a way of horizontally scaling database. Application level sharding means that the logic of partitioning data across multiple node is done at the application level. That is based on some key- classic example — East Coast vs West Coast or <a href=\"http://www.malinga.me/application-aware-sharding-for-a-mysql-database/\" data-href=\"http://www.malinga.me/application-aware-sharding-for-a-mysql-database/\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">similar</a>; your DB write code will select a Database to connect , write and read. The problem is that the complexity of application level sharding quickly gets complex and it is not a good way to scale . Cassandra and most NoSQL databases does sharding transparently (as you have seen via the partition key). This is a pretty big advantage as without this horizontal scaling is a hard problem.</p><h4 id=\"db8e\" class=\"graf graf--h4 graf-after--p\">Open-Source and Commercial</h4><p id=\"a666\" class=\"graf graf--p graf-after--h4 graf--trailing\">As of the time of writing this, relations between Apache Foundation and Datastax- which was one of the largest contributor to Cassandra ? have soured. There is an commercial version of Cassandra — Datastax Enterprise Edition and open source version is the Apache Cassandra. The Java driver of Cassandra has two version, the open source and DSE provided, and you cannot use commercial driver with open source Cassandra. For other languages like Go the driver is open source.</p></figure></figure></figure>"}}]}},"pageContext":{"alternative_id":10787}}