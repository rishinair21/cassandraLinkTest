{"data":{"allAnantCassandralinks":{"edges":[{"node":{"title":"AWS Lambda with Managed Cassandra - Part 1: Let's Build a POC - Instaclustr","alternative_id":12168,"content":"<p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/picture-lambda-blog-2-1.png\"><img class=\"aligncenter size-full wp-image-11121\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/picture-lambda-blog-2-1.png\" alt=\"\" width=\"925\" height=\"471\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/picture-lambda-blog-2-1.png 925w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/picture-lambda-blog-2-1-300x153.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/picture-lambda-blog-2-1-768x391.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/picture-lambda-blog-2-1-640x326.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/picture-lambda-blog-2-1-94x48.png 94w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/picture-lambda-blog-2-1-212x108.png 212w\" /></a></p><p>Serverless architecture is an attractive solution for both small businesses and large enterprises. The former gains the ability to go to market quickly while the latter are able to reduce IT costs by abstracting away complexity. One of the key players in serverless architecture is AWS with its Lambda offering. Lambda is a simple way to execute small portions of code on demand and without the need to provision any servers. Alongside the growth in Lambda’s popularity has come a greater interest in combining it with our Cassandra managed service. As such, we thought it would be a good time to investigate the pros and cons of using Lambda with Cassandra and to share some tips. </p><p>This will be a three-part series of blog posts. The first post will focus on developing a POC at next to no cost and will look like a tutorial. The focus here is mostly functional. The second post will focus on performance. The last will cover security and cost savings.</p><p>In this POC we are going to build a minimalistic REST API with Cassandra as our backend storage. Here is what we will use:</p><ul><li><a href=\"https://console.instaclustr.com/user/signup\">Instaclustr managed service free trial</a> (14 day free trial on t2.small nodes)</li> <li><a href=\"https://aws.amazon.com/lambda/pricing/\">AWS Lambda free tier</a> (1 million requests per month, 400,000 GB-seconds)</li> <li><a href=\"https://aws.amazon.com/api-gateway/pricing/\">AWS API Gateway free tier</a> (1 million API calls per month for new customers)</li> </ul><p>Running this tutorial should incur next to no cost. Obviously, you are responsible for maintaining your usage within the free tier AWS allowance, and <a href=\"https://console.instaclustr.com/user/signup\">Instaclustr free trial</a>. Running this tutorial assumes you have some general AWS knowledge, though you don’t need to have experience with AWS Lambda or AWS API Gateway.</p><p>The architecture is quite simple:</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-2-1.png\"><img class=\"aligncenter size-full wp-image-11120\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-2-1.png\" alt=\"\" width=\"917\" height=\"151\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-2-1.png 917w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-2-1-300x49.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-2-1-768x126.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-2-1-640x105.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-2-1-291x48.png 291w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-2-1-600x99.png 600w\" /></a></p><p>The REST API will be minimalistic: We are going to create a service to create and retrieve orders. Here is an example using Swagger:</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-3-1.png\"><img class=\"aligncenter size-full wp-image-11119\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-3-1.png\" alt=\"\" width=\"1299\" height=\"564\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-3-1.png 1299w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-3-1-300x130.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-3-1-768x333.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-3-1-1024x445.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-3-1-1200x521.png 1200w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-3-1-966x419.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-3-1-640x278.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-3-1-111x48.png 111w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-3-1-249x108.png 249w\" /></a></p><h2>Step1: Create a Cassandra Cluster on AWS.</h2><p>This is extremely easy using Instaclustr’s managed service. You can use the <a href=\"https://console.instaclustr.com/user/signup\">14-day free trial</a> to create a 3 node t2.small cluster. This type of cluster is perfect for basic functional testing. Let’s break down this process:</p><h3>Step 1.a. Create an <a href=\"https://console.instaclustr.com/user/signup\">Instaclustr Account</a>:</h3><p>Once you create your account, you will be able to run a 14 day trial cluster for free.</p><h3>Step 1.b Create a Cluster, with the Following Properties:</h3><h3><b>Name</b>: aws-lambda-small</h3><h3><b>Applications</b>: Apache Cassandra 3.11.2 (latest as of today)</h3><ul><li><b>No add-ons</b></li> <li><b>Infrastructure provider</b>: AWS</li> <li><b>Region</b>: Choose something close to you. I’ll be using US West (Oregon)</li> <li><b>Custom Name</b>: Let’s leave it to the default, i.e. AWS_VPC_US_WEST_2 for me as I am running in Oregon. If you are running in another region, take note as you will need to use the data center name later in this tutorial</li> <li><b>Data Centre Network</b>: Let’s leave it to the default, i.e. 10.224.0.0/16</li> <li><b>Node Size</b>: You will need to choose the Starter node (t2.small)</li> <li><b>EBS Encryption</b>: not required</li> <li><b>Replication Factor</b>: Let’s choose the most common replication factor when using Cassandra: 3</li> <li><b>Nodes</b>: 3</li> <li><b>Network</b>: We are going to tick the box to use private IP for node broadcast. The client will need to connect to Cassandra using the private IP. <ul><li><b>Security</b>: You can let Instaclustr add your local IP address to the firewall, thought that’s not required.</li> <li><b>Password auth</b>: For simplicity, we are going to disable password authentication and user authorization. As your client can only connect to the cluster via private IP, this is not a huge risk for a Proof of Concept. Don’t do that in production.</li> <li><b>Client – Node encryption</b> this is not supported for nodes that are this small</li> </ul></li> </ul><p>And that’s it! Click on <b>Create Cluster</b>, and you will have it running within 5 minutes.</p><h2>Step 2: Configure the AWS VPC Infrastructure.</h2><p>This configuration step is to enable communication between the AWS Lambda you will create, and the Cassandra cluster you just created. It may seem like a boring ‘plumbing’ step, but pay close attention as you will not get traffic to flow correctly if you miss a step.</p><h3>Step 2.a Create an AWS Account.</h3><p>If you don’t have one, create an AWS account. You will need to provide a credit card.</p><h3>Step 2.b Create a VPC in your AWS Account</h3><p>Use the same region you chose for your Cassandra cluster. Importantly, choose a CIDR block that does not overlap with the CIDR block you choose for your Cassandra cluster. For example, 10.225.0.0/16</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-4-1.png\"><img class=\"aligncenter size-full wp-image-11118\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-4-1.png\" alt=\"\" width=\"904\" height=\"558\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-4-1.png 904w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-4-1-300x185.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-4-1-768x474.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-4-1-640x395.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-4-1-78x48.png 78w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-4-1-175x108.png 175w\" /></a></p><h3>Step 2.c. Create a subnet per availability zone.</h3><p>You will want to do that to achieve High Availability with your AWS Lambda. In my case, I use the subnet CIDR block as follow: 10.225.0.0/24 for us-west-2a; 10.225.1.0/24 for us-west-2b; and 10.225.2.0/24 for us-west-2c.</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-5-1.png\"><img class=\"aligncenter size-full wp-image-11117\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-5-1.png\" alt=\"\" width=\"1166\" height=\"621\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-5-1.png 1166w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-5-1-300x160.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-5-1-768x409.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-5-1-1024x545.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-5-1-966x514.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-5-1-640x341.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-5-1-90x48.png 90w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-5-1-203x108.png 203w\" /></a></p><h3>Step 2.d. Request VPC Peering between your Cassandra Cluster and your New VPC.</h3><p>The request needs to be initiated from the Instaclustr console. Look for the Settings section of your cluster at the bottom. You will need to provide your AWS account number, the id of your aws-lambda-small VPC, and it’s corresponding CIDR (in my case, 10.225.0.0/16). You should choose the option to have your VPC network added to the cluster firewall. Once you submit the VPC peering request, you need to accept it on your AWS account, and you need to update your VPC route table to route the traffic to Cassandra. In my case, the traffic to 10.224.0.0/16 needs to be routed to the new VPC peering connection.</p><p><a href=\"https://www.instaclustr.com/support/documentation/cluster-management/using-vpc-peering-aws/\">You can see the full details in this support article</a>. </p><h3>Step 2.e. Create a Security Group.</h3><p>You need to create a security group for you AWS Lambda as the Lambda containers will be executed in the VPC. At a minimum, a lot of outbound traffic to TCP port 9042 (Cassandra port) towards your Cassandra cluster, in my case 10.224.0.0/16</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-6-1.png\"><img class=\"aligncenter size-full wp-image-11116\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-6-1.png\" alt=\"\" width=\"1498\" height=\"713\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-6-1.png 1498w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-6-1-300x143.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-6-1-768x366.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-6-1-1024x487.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-6-1-1200x571.png 1200w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-6-1-966x460.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-6-1-640x305.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-6-1-101x48.png 101w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-6-1-227x108.png 227w\" /></a></p><h2><b>Step 3: Create your AWS Lambda.</b></h2><p>AWS Lambda are small portions of code that can be executed on demand on AWS, without the need for the user to provision an instance. Behind the scenes, Lambda are executed as containers. The very first time the Lambda is executed, AWS will instantiate the container and run the code. Once the Lambda application exits, AWS will freeze the container and keep it around ready to execute new Lambda requests. If it remains unused, the Lambda container is destroyed. </p><p>To achieve the best performance, code executed on Lambda can be split into initialization and execution. For working with Cassandra, we will create the cluster connection (which can take a few seconds), and create the prepared statement in the initialization phase, so that only the first execution will incur the initialization overhead, and subsequent execution will be much faster. For the purpose of this POC, I will create two Lambda that executes Python code. The first Lambda is responsible for creating the Cassandra data model schema and will be called only once. The second Lambda will receive the PUT and GET requests from the API gateway and will execute the write and read code.</p><h3>Step 3.a. Navigate to the AWS Lambda page, and Click to Create a Function</h3><p><b>Name</b>: cassandra-schema-init</p><p><b>Runtime</b>: Python 2.7</p><p><b>Role</b>: Create new role from template(s)</p><ul><li>Role name aws-lambda-small</li> <li>Policy templates: According to the documentation, you should be using “VPCAccess” that will allow the Lambda to create the NetworkInterface to run in the VPC. However, VPCAccess is not in the list of templates as of now. So just leave empty and we will fix that in a few steps.</li> </ul><h3>Step 3.b. Create and Upload the Python Code for cassandra-schema-init</h3><p>You will see that the AWS console lets you edit code directly. However, as we need to add some dependencies (<code>cassandra-driver</code>), we will need to edit the code from our computer and package the code with the dependencies. Change the “Code entry type” to “Upload a .ZIP file.” On your computer, create a directory, such as <code>aws-lambda-schema</code>, and start by downloading the dependencies. </p><p>If you are using Linux you can use the Python package manager ‘pip’ to install everything. To get the cassandra-driver, run this command: <code><code>pip install cassandra-driver -t</code> .</code> Then run this command to get the twisted library: <code><code>pip install twisted -t</code></code>. You may be wondering why we are downloading the twisted library. Twisted lets us reuse an existing Cassandra connection at each invocation of the AWS Lambda. This is the only way to achieve two digit millisecond level performance. Downloading the <code>cassandra-driver</code> and <code>twisted</code> will take a few minutes. Good time for a coffee break.</p><p>The Python code to create the schema is simple. Save the following into the file <code>cassandra_lambda.py</code>:</p><p>Your aws-lambda-schema directory should now contain cassandra_lambda.py, and all the dependencies downloaded by pip. The next step is to zip the contents of the directory and upload it to the AWS console. Importantly, <b>do not zip the directory.</b> <b>You need to zip the contents</b> of the directory in one file. AWS is sensitive about that.</p><h3>Step 3.c. Configure AWS Lambda Settings from the AWS Console</h3><p><b>Function code: </b>If you named your file cassandra_lambda.py, then make sure to update the Handler with <code>cassandra_lambda.lambda_handler</code></p><p><b>The environment variables</b>. In my case given the Cassandra IP addresses and the name of the data center:</p><ul><li>endpoint 10.224.17.181,10.224.97.78,10.224.188.162</li>\n<li>local_dc AWS_VPC_US_WEST_2</li>\n</ul><p>Those are used in the code.</p><p><b>Basic settings</b>: You will want to increase the timeout since initializing the Cassandra connection and updating the schema can take a few seconds. Ten seconds should be enough.</p><p><b>Network section</b>: you need to set your Lambda to execute in your aws-lambda-small VPC. Select the security group and three subnets you created earlier.</p><p><b>Execution Role</b>: You will need to create a new role using a template. The one that was created earlier did not automatically have permissions to create network interfaces. Now that you have chosen the VPC in the Network section, AWS will be able to automatically add the VPC Access policy to the role. Let’s call the role <code>aws-lambda-small-vpc</code>. No need to choose a template from the Policy.</p><p>click on <b>Save</b> at the top right.</p><h3>Step 3.d. Test the Lambda cassandra-schema-init</h3><p>Just click on “Test” at the top right. You will be prompted to configure a test event. This Lambda does not respond to events as it is used only for initializing the Cassandra schema. You can use the default <strong>Hello World</strong> event.</p><p>If everything works well, you should see some success logs on the AWS Lambda console and your schema will be created. Now let’s create the Lambda that will handle the POST and GET calls for your API. In this example, we will create a single Lambda to handle both POST and GET. In practice, you will need to consider the pros and cons of having multiple Lambdas for multiple methods.</p><h3>Step 3.e. Create a New Lambda: cassandra-api</h3><p><b>Name</b>: cassandra-api</p><p><b>Runtime</b>: Python 2.7</p><p><b>Role</b>: Choose an existing role</p><p><b>Existing role</b>: service-role/aws-lambda-small-vpc which is the one you created earlier</p><h3>Step 3.f. Configure the Lambda cassandra-api</h3><p><b>Function code</b>:</p><ul><li>Code entry type: Upload a ZIP file</li>\n<li><strong>Handler:</strong> <code>cassandra_lambda.lambda_handler</code> – That’s assuming you will name your python file cassandra_lambda.py</li>\n</ul><p><b>Environment variables:</b></p><ul><li>endpoint 10.224.18.118,10.224.75.58,10.224.133.133</li>\n<li>local_dc AWS_VPC_US_WEST_2</li>\n</ul><p><b>Basic settings</b>: set the timeout to 10 sec.</p><p><b>Network</b>: use VPC, and choose the existing subnets/securitygroups.</p><p>Click on <b>Save </b>at the top right of the screen.</p><h3>Step 3.g. Create and Upload the Code for cassandra-api</h3><p>Similar to what you did for <code>cassandra-schema-init</code>, you will need to create a directory, download the dependencies with pip, create and edit the file <code>cassandra_lambda.py</code>, zip the contents (<b>remember, don’t zip the parent directory</b>) and finally upload that to AWS. </p><p>Use the following code:</p><div id=\"crayon-5b9a772d2619a141924888\" class=\"crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-mac print-yes notranslate\" data-settings=\"minimize scroll-mouseover\"><div class=\"crayon-toolbar\" data-settings=\"mouseover overlay hide delay\"><div class=\"crayon-tools\">Python</div></div><div class=\"crayon-main\"><table class=\"crayon-table\"><tr class=\"crayon-row\"><td class=\"crayon-nums\" data-settings=\"show\"> <div class=\"crayon-nums-content\"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p></div></td>\n<td class=\"crayon-code\"><div class=\"crayon-pre\"><p>import time</p><p>import uuid</p><p>import json</p><p>import os</p><p>import boto3</p><p>from base64 import b64decode</p><p>from cassandra.cluster import Cluster</p><p>from cassandra.auth import PlainTextAuthProvider</p><p>from cassandra.policies import DCAwareRoundRobinPolicy</p><p>from cassandra.io.twistedreactor import TwistedConnection</p><p>from cassandra import ConsistencyLevel</p><p># Keep track of container id, for perf testing.</p><p>container_id=uuid.uuid4()</p><p># Get Cassandra endpoint from aws Lambda env variables</p><p>ENDPOINT = os.environ['endpoint']</p><p>LOCAL_DC = os.environ['local_dc']</p><p># the cassandra session, and prepared statement will</p><p>cassandra_session = None</p><p>cassandra_insert = None</p><p>cassandra_lookup = None</p><p># the code to handle POST calls.</p><p># In practice, you will want to use your favorite API framework, i.e. Flask</p><p>def post(event):</p><p>   myjson = json.loads(event['body'])</p><p>   order_id=uuid.uuid4()</p><p>   name = myjson['name']</p><p>   address = myjson['address']</p><p>   phone = myjson['phone']</p><p>   item = myjson['item']</p><p>   cassandra_session.execute(cassandra_insert, [order_id, name, address, phone, item])</p><p>   return {</p><p>       'isBase64Encoded': False,</p><p>       'statusCode': 200,</p><p>       'body': json.dumps({\"order_id\": str(order_id)}),</p><p>       'headers': {}</p><p>   }</p><p># the code to handle GET calls</p><p># In practice, you will want to use your favorite API framework, i.e. Flask</p><p>def get(event):</p><p>   order_id = event['pathParameters']['id']</p><p>   rows = cassandra_session.execute(cassandra_lookup, [uuid.UUID(order_id)])</p><p>   if not rows:</p><p>       return {</p><p>           'isBase64Encoded': False,</p><p>           'statusCode': 404,</p><p>           'body': {},</p><p>           'headers': {}</p><p>       }</p><p>   return {</p><p>       'isBase64Encoded': False,</p><p>       'statusCode': 200,</p><p>       'body': json.dumps({\"order_id\": order_id,</p><p>                           \"name\": rows[0].name,</p><p>                           \"address\": rows[0].address,</p><p>                           \"phone\": rows[0].phone,</p><p>                           \"item\": rows[0].item}),</p><p>       'headers': {}</p><p>   }</p><p>method_map = {'GET': get, 'POST': post}</p><p>def Lambda_handler(event, context):</p><p>   global container_id, cassandra_session, cassandra_insert, cassandra_lookup</p><p>   print('Running container', container_id)</p><p>   if not cassandra_session:</p><p>       cluster = Cluster(ENDPOINT.split(\",\"),connection_class=TwistedConnection, load_balancing_policy=DCAwareRoundRobinPolicy(local_dc=LOCAL_DC))</p><p>       cassandra_session = cluster.connect()</p><p>       cassandra_session.default_consistency_level = ConsistencyLevel.QUORUM</p><p>       cassandra_insert = cassandra_session.prepare(\"INSERT INTO ks.tb (order_id, name, address, phone, item) VALUES (?, ?, ?, ?, ?)\")</p><p>       cassandra_lookup = cassandra_session.prepare(\"SELECT name, address, phone, item FROM ks.tb WHERE order_id = ?\")</p><p>   method = event['httpMethod']</p><p>   return method_map[method](event)</p></div></td>\n</tr></table></div></div><p>You might want to use the AWS command line interface (aws-cli) at this stage. Assuming you have configured your AWS profile(s), this could look like:</p><p>By the way, as you may have noticed, you will have to zip the python files and the dependencies quite often. To accelerate this, have a look at the -u option of the zip command (Linux / OSX): it will only update the archive with the changed file (which should only be your python file), making the process much faster.</p><h3>Step 3.h Test your cassandra-api</h3><p>If you look at the code of cassandra-api, you will see that the GET and PUT methods expect some json extracted from the body of an HTTP request. We are going to set up two tests: one for GET, and one for POST.</p><p>Click on <strong>Test</strong> (top right)</p><p>Configure your test event:</p><ul><li><strong>Event name:</strong> post</li>\n<li><strong>Content of the event:</strong> use the following.</li>\n</ul><div id=\"crayon-5b9a772d261a4749147695\" class=\"crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-mac print-yes notranslate\" data-settings=\"minimize scroll-mouseover\"><div class=\"crayon-toolbar\" data-settings=\"mouseover overlay hide delay\"><div class=\"crayon-tools\">JavaScript</div></div><div class=\"crayon-main\"><table class=\"crayon-table\"><tr class=\"crayon-row\"><td class=\"crayon-nums\" data-settings=\"show\"> <div class=\"crayon-nums-content\"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p></div></td>\n<td class=\"crayon-code\"><div class=\"crayon-pre\"><p>{</p><p> \"resource\": \"/order\",</p><p> \"path\": \"/order\",</p><p> \"httpMethod\": \"POST\",</p><p> \"headers\": null,</p><p> \"queryStringParameters\": null,</p><p> \"pathParameters\": null,</p><p> \"stageVariables\": null,</p><p> \"requestContext\": {</p><p>   \"path\": \"/order\",</p><p>   \"accountId\": \"597284863061\",</p><p>   \"resourceId\": \"rmbyew\",</p><p>   \"stage\": \"test-invoke-stage\",</p><p>   \"requestId\": \"dca8be26-7816-11e8-a831-6dbe534d0ae4\",</p><p>   \"identity\": {</p><p>     \"cognitoIdentityPoolId\": null,</p><p>     \"cognitoIdentityId\": null,</p><p>     \"apiKey\": \"test-invoke-api-key\",</p><p>     \"cognitoAuthenticationType\": null,</p><p>     \"userArn\": \"arn:aws:iam::597284863061:user/christophe-workshop\",</p><p>     \"apiKeyId\": \"test-invoke-api-key-id\",</p><p>     \"userAgent\": \"aws-internal/3\",</p><p>     \"accountId\": \"597284863061\",</p><p>     \"caller\": \"AIDAJBAW4OXNUFHSWCLF4\",</p><p>     \"sourceIp\": \"test-invoke-source-ip\",</p><p>     \"accessKey\": \"ASIAIS5LPR47MN7RRAVA\",</p><p>     \"cognitoAuthenticationProvider\": null,</p><p>     \"user\": \"AIDAJBAW4OXNUFHSWCLF4\"</p><p>   },</p><p>   \"resourcePath\": \"/order\",</p><p>   \"httpMethod\": \"POST\",</p><p>   \"extendedRequestId\": \"JA-z9HWIjoEFqdA=\",</p><p>   \"apiId\": \"f6ugtbwyjg\"</p><p> },</p><p> \"body\": \"{\\n    \\\"name\\\" :\\\"joe\\\",\\n    \\\"address\\\" : \\\"Sydney\\\",\\n    \\\"phone\\\": \\\"0123456789\\\",\\n \\\"item\\\": \\\"pizza\\\"}\"</p><p>}</p></div></td>\n</tr></table></div></div><p>Now test your POST a few times. Keep track of one value for order_id uuid as you will need it in a moment. Did you notice the first invocation took longer (maybe a few seconds), while other invocations took a few milliseconds? That’s because at the first invocation, there is some overhead:</p><ul><li>AWS creates one container to run the Lambda</li>\n<li>AWS create a network interface in the VPC, and attaches it to the Lambda</li>\n<li>The Lambda initializes the Cassandra connection.</li>\n</ul><p>AWS will keep around your container for some indeterminate amount of time. Most user reports that the container will stay around for a few hours after the last invocation. That’s something to keep in mind. Importantly, in our test, we are doing serial invocations of our Lambda. If running in parallel, multiple containers will be created by AWS (Lambda auto scale), and the initialization cost will be paid a few times. We will see in our next blog how to optimize this.</p><p>Let’s try our GET method. For that, create a new Test (Configure test events). Let’s call it “get”, and let’s use the following event:</p><div id=\"crayon-5b9a772d261a8623796114\" class=\"crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-mac print-yes notranslate\" data-settings=\"minimize scroll-mouseover\"><div class=\"crayon-toolbar\" data-settings=\"mouseover overlay hide delay\"><div class=\"crayon-tools\">JavaScript</div></div><div class=\"crayon-main\"><table class=\"crayon-table\"><tr class=\"crayon-row\"><td class=\"crayon-nums\" data-settings=\"show\"> <div class=\"crayon-nums-content\"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p></div></td>\n<td class=\"crayon-code\"><div class=\"crayon-pre\"><p>{</p><p> \"resource\": \"/order/{id+}\",</p><p> \"path\": \"/order/INSERT_YOUR_UUID\",</p><p> \"httpMethod\": \"GET\",</p><p> \"headers\": null,</p><p> \"queryStringParameters\": null,</p><p> \"pathParameters\": {</p><p>   \"id\": \"INSERT_YOUR_UUID\"</p><p> },</p><p> \"stageVariables\": null,</p><p> \"requestContext\": {</p><p>   \"path\": \"/order/{id+}\",</p><p>   \"accountId\": \"597284863061\",</p><p>   \"resourceId\": \"wm947q\",</p><p>   \"stage\": \"test-invoke-stage\",</p><p>   \"requestId\": \"f88fdaa2-781a-11e8-8075-79171804d71a\",</p><p>   \"identity\": {</p><p>     \"cognitoIdentityPoolId\": null,</p><p>     \"cognitoIdentityId\": null,</p><p>     \"apiKey\": \"test-invoke-api-key\",</p><p>     \"cognitoAuthenticationType\": null,</p><p>     \"userArn\": \"arn:aws:iam::597284863061:user/christophe-workshop\",</p><p>     \"apiKeyId\": \"test-invoke-api-key-id\",</p><p>     \"userAgent\": \"aws-internal/3\",</p><p>     \"accountId\": \"597284863061\",</p><p>     \"caller\": \"AIDAJBAW4OXNUFHSWCLF4\",</p><p>     \"sourceIp\": \"test-invoke-source-ip\",</p><p>     \"accessKey\": \"ASIAIS5LPR47MN7RRAVA\",</p><p>     \"cognitoAuthenticationProvider\": null,</p><p>     \"user\": \"AIDAJBAW4OXNUFHSWCLF4\"</p><p>   },</p><p>   \"resourcePath\": \"/order/{id+}\",</p><p>   \"httpMethod\": \"GET\",</p><p>   \"extendedRequestId\": \"JBDHtGUFjoEFfEg=\",</p><p>   \"apiId\": \"f6ugtbwyjg\"</p><p> },</p><p> \"body\": null,</p><p> \"isBase64Encoded\": false</p><p>}</p></div></td>\n</tr></table></div></div><p>You will need to update (in two places) the code above to replace INSERT_YOUR_UUID with a uuid of an order you posted earlier. Using this you can test your GET command.</p><p>You now have a one time use Lambda for creating the schema and you have Lambdas that handle POST and GET requests.  For now, you can only trigger a test manually. The next step is to hook this up with the API gateway so that requests can be triggered programmatically from the internet.</p><h2>Step 4: Create the AWS API gateway.</h2><h3>Step 4.a Create an empty API.</h3><p>Navigate to the AWS API Gateway console, and create a New API.</p><p><strong>Name:</strong> cassandra-api</p><p><strong>Endpoint Type:</strong> Regional</p><h3>Step 4.b. Create a new order resource.</h3><p>Click on <strong>Actions</strong> drop-down menu and create a new order Resource:</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-7-1.png\"><img class=\"aligncenter wp-image-11115 size-full\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-7-1.png\" alt=\"\" width=\"1600\" height=\"462\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-7-1.png 1600w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-7-1-300x87.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-7-1-768x222.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-7-1-1024x296.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-7-1-1200x347.png 1200w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-7-1-966x279.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-7-1-640x185.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-7-1-166x48.png 166w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-7-1-374x108.png 374w\" /></a></p><h3>Step 4.c. Create a POST method</h3><p>Make sure the <strong>/order</strong> resource is selected, then click on the drop down menu <strong>Actions</strong> and create a new POST method, configured as follow:</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-8-1.png\"><img class=\"aligncenter size-full wp-image-11114\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-8-1.png\" alt=\"\" width=\"1600\" height=\"618\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-8-1.png 1600w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-8-1-300x116.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-8-1-768x297.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-8-1-1024x396.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-8-1-1200x464.png 1200w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-8-1-966x373.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-8-1-640x247.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-8-1-124x48.png 124w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-8-1-280x108.png 280w\" /></a></p><p>Let’s test your POST method. Make sure to select the POST method, then click on TEST. All you need to do is to add a Request Body string, such as:</p><p>If everything works well, you should get an order_id back. Copy the order_id as you will use it soon.</p><h3>Step 4.d. Create a greedy resource</h3><p>Make sure <strong>/order</strong> resource is select, click on <strong>Actions</strong> and create a new resource configured as follow:</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-9-1.png\"><img class=\"aligncenter size-full wp-image-11113\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-9-1.png\" alt=\"\" width=\"1590\" height=\"535\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-9-1.png 1590w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-9-1-300x101.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-9-1-768x258.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-9-1-1024x345.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-9-1-1200x404.png 1200w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-9-1-966x325.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-9-1-640x215.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-9-1-143x48.png 143w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-9-1-321x108.png 321w\" /></a></p><p>You will see that it automatically created the ANY method. You can delete it, and create a GET method:</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-10-1.png\"><img class=\"aligncenter size-full wp-image-11112\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-10-1.png\" alt=\"\" width=\"1600\" height=\"552\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-10-1.png 1600w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-10-1-300x104.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-10-1-768x265.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-10-1-1024x353.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-10-1-1200x414.png 1200w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-10-1-966x333.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-10-1-640x221.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-10-1-139x48.png 139w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-10-1-313x108.png 313w\" /></a></p><p>Let’s test our GET method. Make sure to select the GET method, then click on TEST. This time you will provide the order_id uuid (from Step 4.c.) in the PATH {id} box. If everything works well, you should get back the order.</p><h3>Step 4.e. Deploy your API.</h3><p>Click on the <strong>Actions</strong> drop down menu, and deploy API. Give it a Deployment stage name, let’s use “test”</p><p>The first thing you will want to do is to throttle your API to a low number, i.e. 1 per seconds, just to make sure your API won’t be called a large number of times, as the cost will apply beyond the free tier.</p><h3>Step 4.f Create an API Key (optional)</h3><p>If you want to control the access to your API, you might consider creating an API Key as follow.</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-11-1.png\"><img class=\"aligncenter size-full wp-image-11111\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-11-1.png\" alt=\"\" width=\"1600\" height=\"670\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-11-1.png 1600w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-11-1-300x126.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-11-1-768x322.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-11-1-1024x429.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-11-1-1200x503.png 1200w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-11-1-966x405.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-11-1-640x268.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-11-1-115x48.png 115w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-11-1-258x108.png 258w\" /></a></p><p>Click on <strong>Show</strong> to revel the key, and keep it for later usage.</p><h3>Step 4.g Create a usage plan for your API key (optional)</h3><p>Usage plan lets you control how an API key can be used. Click on Usage Plans. You might need to click on <strong>Enable Usage Plans</strong> first. The AWS page is a little bit buggy here, and you might need to reload the page a few time with your browser.</p><p>Once you have access to the create button, create your Usage Plan, and associate it with the cassandra-api API, with the test Stage. Then associate the Usage Plan with the API key you created.</p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-12-1.png\"><img class=\"aligncenter size-full wp-image-11110\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-12-1.png\" alt=\"\" width=\"1600\" height=\"866\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-12-1.png 1600w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-12-1-300x162.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-12-1-768x416.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-12-1-1024x554.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-12-1-1200x650.png 1200w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-12-1-966x523.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-12-1-640x346.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-12-1-89x48.png 89w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-12-1-200x108.png 200w\" /></a></p><h3>Step 4.h Add Authentication to your GET and POST Method (optional)</h3><p>You will need to navigate to the POST resource, and click on the <b>Method Request</b></p><p><a href=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-13-1.png\"><img class=\"aligncenter size-full wp-image-11109\" src=\"https://www.instaclustr.com/wp-content/uploads/2018/08/awslambda-13-1.png\" alt=\"\" width=\"1208\" height=\"367\" srcset=\"https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-13-1.png 1208w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-13-1-300x91.png 300w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-13-1-768x233.png 768w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-13-1-1024x311.png 1024w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-13-1-1200x365.png 1200w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-13-1-966x293.png 966w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-13-1-640x194.png 640w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-13-1-158x48.png 158w, https://24b4dt1v60e526bo2p349l4c-wpengine.netdna-ssl.com/wp-content/uploads/2018/08/awslambda-13-1-355x108.png 355w\" /></a></p><p>Then, set the API Key Required to True. Repeat for the GET method. Don’t forget to redeploy your API (use the same stages: test).</p><h3>Step 4.i Test your API from your Computer.</h3><p>First, retrieve your API endpoint by navigating to the Stages section of your API and clicking on the POST method. This will provide you with the Invoke URL.</p><p>Second, make sure you have your API Keys.</p><p>You can now do a post from a curl / postman etc… Below is an example with curl, in which I am providing an AWS API KEY. If you didn’t configure the API Key, you don’t need to provide it.</p><p>Assuming the id of the new resource is: <code>fb72a94f-c0d9-4bd5-a355-fc8014d125fd</code>, you can retrieve your resource with the following curl command:</p><p>We built a simple scalable REST API using AWS API Gateway to receive API calls, AWS Lambda to execute code, and Cassandra as our backend storage. This POC can be built at next to no cost as <a href=\"https://console.instaclustr.com/user/signup\">Instaclustr provides 14 </a>day free trial on the small developer cluster, and using AWS gateway / AWS Lambda for this POC should remain within the free tier usage (you might still have some small cost, i.e. a few dollars, for data transfer, or for using cloudwatch). This POC demonstrates the simplicity of using a serverless approach where the code is executed by AWS Lambda without managing any ec2 instances. Furthermore the data is stored in a fully managed, scalable, highly available and low latency database –  Cassandra. </p><p>The next step would be to consider performance, which will be the focus of our next blog post.</p>"}}]}},"pageContext":{"alternative_id":12168}}